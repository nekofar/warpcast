// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

export const zProfilePicture = z.object({
	url: z.optional(z.url()),
	verified: z.optional(z.boolean()),
});

export const zBio = z.object({
	text: z.optional(z.string()),
	mentions: z.optional(z.array(z.unknown())),
	channelMentions: z.optional(z.array(z.unknown())),
});

export const zLocation = z.object({
	placeId: z.optional(z.string()),
	description: z.optional(z.string()),
});

export const zProfile = z.object({
	bio: z.optional(zBio),
	location: z.optional(zLocation),
});

export const zViewerContext = z.object({
	following: z.optional(z.boolean()),
	followedBy: z.optional(z.boolean()),
	enableNotifications: z.optional(z.boolean()),
	canSendDirectCasts: z.optional(z.boolean()),
	hasUploadedInboxKeys: z.optional(z.boolean()),
});

export const zUser = z.object({
	fid: z.int(),
	username: z.string(),
	displayName: z.string(),
	pfp: z.optional(zProfilePicture),
	profile: z.optional(zProfile),
	followerCount: z.optional(z.int()),
	followingCount: z.optional(z.int()),
	viewerContext: z.optional(zViewerContext),
});

export const zOnboardingState = z.object({
	id: z.optional(z.uuid()),
	email: z.optional(z.email()),
	user: z.optional(zUser),
	hasOnboarding: z.optional(z.boolean()),
	hasConfirmedEmail: z.optional(z.boolean()),
	handledConnectAddress: z.optional(z.boolean()),
	canRegisterUsername: z.optional(z.boolean()),
	needsRegistrationPayment: z.optional(z.boolean()),
	hasFid: z.optional(z.boolean()),
	hasFname: z.optional(z.boolean()),
	hasDelegatedSigner: z.optional(z.boolean()),
	hasSetupProfile: z.optional(z.boolean()),
	hasCompletedRegistration: z.optional(z.boolean()),
	hasStorage: z.optional(z.boolean()),
	handledPushNotificationsNudge: z.optional(z.boolean()),
	handledContactsNudge: z.optional(z.boolean()),
	handledInterestsNudge: z.optional(z.boolean()),
	hasValidPaidInvite: z.optional(z.boolean()),
	hasWarpcastWalletAddress: z.optional(z.boolean()),
	hasPhone: z.optional(z.boolean()),
	needsPhone: z.optional(z.boolean()),
	sponsoredRegisterEligible: z.optional(z.boolean()),
	geoRestricted: z.optional(z.boolean()),
});

export const zOnboardingStateResponse = z.object({
	result: z.optional(
		z.object({
			state: z.optional(zOnboardingState),
		}),
	),
});

export const zErrorResponse = z.object({
	errors: z.optional(
		z.array(
			z.object({
				message: z.optional(
					z.string().register(z.globalRegistry, {
						description: "Error message describing the issue",
					}),
				),
			}),
		),
	),
});

export const zUserWithExtras = zUser.and(
	z.object({
		connectedAccounts: z.optional(z.array(z.unknown())),
	}),
);

export const zUserExtras = z.object({
	fid: z.optional(z.int()),
	custodyAddress: z.optional(z.string()),
	ethWallets: z.optional(z.array(z.string())),
	solanaWallets: z.optional(z.array(z.string())),
	walletLabels: z.optional(
		z.array(
			z.object({
				address: z.optional(z.string()),
				labels: z.optional(z.array(z.string())),
			}),
		),
	),
	v2: z.optional(z.boolean()),
	publicSpamLabel: z.optional(z.string()),
});

export const zUserByFidResponse = z.object({
	result: z.optional(
		z.object({
			user: z.optional(zUserWithExtras),
			collectionsOwned: z.optional(z.array(z.unknown())),
			extras: z.optional(zUserExtras),
		}),
	),
});

/**
 * Represents a single validation error
 */
export const zValidationError = z
	.object({
		instancePath: z.string().register(z.globalRegistry, {
			description:
				"JSON Pointer to the part of the request that failed validation",
		}),
		schemaPath: z.string().register(z.globalRegistry, {
			description: "JSON Schema path that was violated",
		}),
		keyword: z.string().register(z.globalRegistry, {
			description: "The JSON Schema keyword that failed",
		}),
		params: z.optional(
			z.record(z.string(), z.unknown()).register(z.globalRegistry, {
				description: "Additional parameters describing the validation error",
			}),
		),
		message: z.string().register(z.globalRegistry, {
			description: "Human-readable error description",
		}),
	})
	.register(z.globalRegistry, {
		description: "Represents a single validation error",
	});

/**
 * Standard 400 Bad Request error response
 */
export const zBadRequestError = z
	.object({
		errors: z.array(zValidationError).register(z.globalRegistry, {
			description: "Array of validation errors",
		}),
	})
	.register(z.globalRegistry, {
		description: "Standard 400 Bad Request error response",
	});

export const zDirectCastMessageReaction = z.object({
	reaction: z.string().register(z.globalRegistry, {
		description: "Emoji used for the reaction",
	}),
	count: z.int().gte(1).register(z.globalRegistry, {
		description: "Number of users who reacted with this emoji",
	}),
	emoji: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Emoji used for the reaction (legacy field)",
		}),
	),
	userFids: z.optional(
		z.array(z.int()).register(z.globalRegistry, {
			description: "List of Farcaster IDs who reacted",
		}),
	),
});

export const zDirectCastMessageViewerContext = z.object({
	isLastReadMessage: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether this is the last read message",
		}),
	),
	focused: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the message is focused",
		}),
	),
	reactions: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "User's reactions to this message",
		}),
	),
});

export const zDirectCastMessageMetadata = z.object({
	casts: z.optional(
		z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
			description: "Cast metadata if message contains cast references",
		}),
	),
	urls: z.optional(
		z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
			description: "URL metadata if message contains links",
		}),
	),
	medias: z.optional(
		z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
			description: "Media metadata if message contains media",
		}),
	),
});

export const zDirectCastMessageMention = z.object({
	user: zUser,
	textIndex: z.int().register(z.globalRegistry, {
		description: "Starting index of the mention in the message text",
	}),
	length: z.int().register(z.globalRegistry, {
		description: "Length of the mention text",
	}),
});

export const zDirectCastMessage = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation this message belongs to",
	}),
	senderFid: z.int().register(z.globalRegistry, {
		description: "Farcaster ID of the message sender",
	}),
	messageId: z.string().register(z.globalRegistry, {
		description: "Unique identifier for the message",
	}),
	serverTimestamp: z.coerce.bigint().register(z.globalRegistry, {
		description: "Server timestamp when message was sent (Unix milliseconds)",
	}),
	type: z
		.enum([
			"text",
			"image",
			"reaction",
			"link",
			"group_membership_addition",
			"pin_message",
			"message_ttl_change",
		])
		.register(z.globalRegistry, {
			description: "Type of the message",
		}),
	message: z.string().register(z.globalRegistry, {
		description: "Content of the message",
	}),
	hasMention: z.boolean().register(z.globalRegistry, {
		description: "Whether the message contains mentions",
	}),
	reactions: z.array(zDirectCastMessageReaction).register(z.globalRegistry, {
		description: "List of reactions to the message",
	}),
	isPinned: z.boolean().register(z.globalRegistry, {
		description: "Whether the message is pinned",
	}),
	isDeleted: z.boolean().register(z.globalRegistry, {
		description: "Whether the message is deleted",
	}),
	senderContext: zUser,
	viewerContext: z.optional(zDirectCastMessageViewerContext),
	get inReplyTo(): z.ZodOptional {
		return z.optional(
			z.lazy((): any => {
				return zDirectCastMessage;
			}),
		);
	},
	metadata: z.optional(zDirectCastMessageMetadata),
	actionTargetUserContext: z.optional(zUser),
	isProgrammatic: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the message was sent programmatically",
		}),
	),
	mentions: z.optional(
		z.array(zDirectCastMessageMention).register(z.globalRegistry, {
			description: "List of mentions in the message",
		}),
	),
});

export const zDirectCastConversationViewerContext = z.object({
	access: z.optional(
		z.enum(["read-write", "read-only"]).register(z.globalRegistry, {
			description: "Access level for the conversation",
		}),
	),
	category: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Category of the conversation",
		}),
	),
	archived: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation is archived",
		}),
	),
	lastReadAt: z.optional(
		z.coerce.bigint().register(z.globalRegistry, {
			description: "Timestamp of last read (Unix milliseconds)",
		}),
	),
	muted: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation is muted",
		}),
	),
	manuallyMarkedUnread: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation is manually marked as unread",
		}),
	),
	pinned: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation is pinned",
		}),
	),
	unreadCount: z.optional(
		z.int().gte(0).register(z.globalRegistry, {
			description: "Number of unread messages",
		}),
	),
	unreadMentionsCount: z.optional(
		z.int().gte(0).register(z.globalRegistry, {
			description: "Number of unread mentions",
		}),
	),
	counterParty: z.optional(zUser),
	tag: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Tag associated with the conversation",
		}),
	),
});

export const zDirectCastConversation = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "Unique identifier for the conversation",
	}),
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Name of the conversation (for group conversations)",
		}),
	),
	description: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Description of the conversation",
		}),
	),
	photoUrl: z.optional(
		z.url().register(z.globalRegistry, {
			description: "URL of the conversation photo",
		}),
	),
	adminFids: z.array(z.int()).register(z.globalRegistry, {
		description: "List of admin Farcaster IDs",
	}),
	removedFids: z.optional(
		z.array(z.int()).register(z.globalRegistry, {
			description: "List of removed Farcaster IDs",
		}),
	),
	participants: z.optional(
		z.array(zUser).register(z.globalRegistry, {
			description: "List of conversation participants",
		}),
	),
	lastReadTime: z.coerce.bigint().register(z.globalRegistry, {
		description: "Timestamp of last read time (Unix milliseconds)",
	}),
	selfLastReadTime: z.optional(
		z.coerce.bigint().register(z.globalRegistry, {
			description: "Timestamp of viewer's last read time (Unix milliseconds)",
		}),
	),
	pinnedMessages: z.optional(
		z.array(zDirectCastMessage).register(z.globalRegistry, {
			description: "List of pinned messages in the conversation",
		}),
	),
	hasPinnedMessages: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation has pinned messages",
		}),
	),
	isGroup: z.boolean().register(z.globalRegistry, {
		description: "Whether this is a group conversation",
	}),
	isCollectionTokenGated: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation is collection token gated",
		}),
	),
	activeParticipantsCount: z.optional(
		z.int().gte(0).register(z.globalRegistry, {
			description: "Number of active participants in the conversation",
		}),
	),
	messageTTLDays: z.optional(
		z.union([
			z.int().gte(0).register(z.globalRegistry, {
				description: "Number of days until message expires",
			}),
			z.enum(["Infinity"]).register(z.globalRegistry, {
				description: "Messages never expire",
			}),
		]),
	),
	createdAt: z.coerce.bigint().register(z.globalRegistry, {
		description: "Timestamp when conversation was created (Unix milliseconds)",
	}),
	unreadCount: z.optional(
		z.int().gte(0).register(z.globalRegistry, {
			description: "Number of unread messages",
		}),
	),
	muted: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation is muted",
		}),
	),
	hasMention: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation has mentions",
		}),
	),
	lastMessage: z.optional(zDirectCastMessage),
	viewerContext: zDirectCastConversationViewerContext,
});

export const zDirectCastInboxResult = z.object({
	hasArchived: z.boolean().register(z.globalRegistry, {
		description: "Whether user has archived conversations",
	}),
	hasUnreadRequests: z.boolean().register(z.globalRegistry, {
		description: "Whether user has unread conversation requests",
	}),
	requestsCount: z.int().gte(0).register(z.globalRegistry, {
		description: "Total number of conversation requests",
	}),
	conversations: z.array(zDirectCastConversation),
});

export const zPaginationCursor = z.object({
	cursor: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Base64 encoded cursor for pagination",
		}),
	),
});

export const zDirectCastInboxResponse = z.object({
	result: zDirectCastInboxResult,
	next: z.optional(zPaginationCursor),
});

export const zCastAction = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	octicon: z.optional(z.string()),
	actionUrl: z.optional(z.string()),
	action: z.optional(
		z.object({
			actionType: z.optional(z.string()),
			postUrl: z.optional(z.string()),
		}),
	),
});

export const zUserAppContextResponse = z.object({
	result: z.optional(
		z.object({
			context: z.optional(
				z.object({
					canAddLinks: z.optional(z.boolean()),
					showConnectedApps: z.optional(z.boolean()),
					signerRequestsEnabled: z.optional(z.boolean()),
					prompts: z.optional(z.array(z.unknown())),
					adminForChannelKeys: z.optional(z.array(z.string())),
					modOfChannelKeys: z.optional(z.array(z.string())),
					memberOfChannelKeys: z.optional(z.array(z.string())),
					canEditAllChannels: z.optional(z.boolean()),
					canUploadVideo: z.optional(z.boolean()),
					statsigEnabled: z.optional(z.boolean()),
					shouldPromptForPushNotifications: z.optional(z.boolean()),
					shouldPromptForUserFollowsSyncContacts: z.optional(z.boolean()),
					castActions: z.optional(z.array(zCastAction)),
					canAddCastAction: z.optional(z.boolean()),
					enabledCastAction: z.optional(zCastAction),
					notificationTabsV2: z.optional(
						z.array(
							z.object({
								id: z.optional(z.string()),
								name: z.optional(z.string()),
							}),
						),
					),
					enabledVideoAutoplay: z.optional(z.boolean()),
					regularCastByteLimit: z.optional(z.int()),
					longCastByteLimit: z.optional(z.int()),
					newUserStatus: z.optional(z.record(z.string(), z.unknown())),
					country: z.optional(z.string()),
					higherClientEventSamplingRateEnabled: z.optional(z.boolean()),
				}),
			),
		}),
	),
});

export const zUserPreferencesResponse = z.object({
	result: z.optional(
		z.object({
			preferences: z.optional(z.record(z.string(), z.unknown())),
		}),
	),
});

export const zChannel = z.object({
	type: z.optional(z.string()),
	key: z.optional(z.string()),
	name: z.optional(z.string()),
	imageUrl: z.optional(z.string()),
	fastImageUrl: z.optional(z.string()),
	feeds: z.optional(
		z.array(
			z.object({
				name: z.optional(z.string()),
				type: z.optional(z.string()),
			}),
		),
	),
	description: z.optional(z.string()),
	followerCount: z.optional(z.int()),
	memberCount: z.optional(z.int()),
	showCastSourceLabels: z.optional(z.boolean()),
	showCastTags: z.optional(z.boolean()),
	sectionRank: z.optional(z.int()),
	subscribable: z.optional(z.boolean()),
	publicCasting: z.optional(z.boolean()),
	inviteCode: z.optional(z.string()),
	headerImageUrl: z.optional(z.string()),
	headerAction: z.optional(
		z.object({
			title: z.optional(z.string()),
			target: z.optional(z.string()),
		}),
	),
	headerActionMetadata: z.optional(z.record(z.string(), z.unknown())),
	viewerContext: z.optional(
		z.object({
			following: z.optional(z.boolean()),
			isMember: z.optional(z.boolean()),
			hasUnseenItems: z.optional(z.boolean()),
			favoritePosition: z.optional(z.int()),
			activityRank: z.optional(z.int()),
			canCast: z.optional(z.boolean()),
		}),
	),
});

export const zHighlightedChannelsResponse = z.object({
	result: z.optional(
		z.object({
			channels: z.optional(z.array(zChannel)),
			viewerContext: z.optional(
				z.object({
					defaultFeed: z.optional(z.string()),
				}),
			),
		}),
	),
});

export const zImageEmbed = z.object({
	type: z.optional(z.enum(["image"])),
	url: z.optional(z.string()),
	sourceUrl: z.optional(z.string()),
	media: z.optional(
		z.object({
			version: z.optional(z.string()),
			width: z.optional(z.int()),
			height: z.optional(z.int()),
			staticRaster: z.optional(z.string()),
			mimeType: z.optional(z.string()),
		}),
	),
	alt: z.optional(z.string()),
});

export const zUrlEmbed = z.object({
	type: z.enum(["url"]),
	openGraph: z.object({
		url: z.string(),
		sourceUrl: z.optional(z.string()),
		title: z.optional(z.string()),
		description: z.optional(z.string()),
		domain: z.optional(z.string()),
		image: z.optional(z.string()),
		useLargeImage: z.optional(z.boolean()),
	}),
});

export const zVideoEmbed = z.object({
	type: z.optional(z.enum(["video"])),
});

export const zRecaster = z.object({
	fid: z.optional(z.int()),
	username: z.optional(z.string()),
	displayName: z.optional(z.string()),
	recastHash: z.optional(z.string()),
});

export const zCast = z.object({
	hash: z.string().register(z.globalRegistry, {
		description: "Unique hash identifier for the cast",
	}),
	threadHash: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Hash identifier for the thread this cast belongs to",
		}),
	),
	parentHash: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Hash identifier of the parent cast (if this is a reply)",
		}),
	),
	parentSource: z.optional(
		z.object({
			type: z.optional(z.enum(["url"])),
			url: z.optional(z.string()),
		}),
	),
	author: zUser,
	text: z.string().register(z.globalRegistry, {
		description: "The text content of the cast",
	}),
	timestamp: z.coerce.bigint().register(z.globalRegistry, {
		description: "Unix timestamp in milliseconds",
	}),
	mentions: z.optional(z.array(zUser)),
	embeds: z.optional(
		z.object({
			images: z.optional(z.array(zImageEmbed)),
			urls: z.optional(z.array(zUrlEmbed)),
			videos: z.optional(z.array(zVideoEmbed)),
			unknowns: z.optional(z.array(z.record(z.string(), z.unknown()))),
			processedCastText: z.optional(z.string()),
			groupInvites: z.optional(z.array(z.record(z.string(), z.unknown()))),
		}),
	),
	replies: z.object({
		count: z.int(),
	}),
	reactions: z.object({
		count: z.int(),
	}),
	recasts: z.object({
		count: z.int(),
		recasters: z.optional(z.array(zRecaster)),
	}),
	watches: z.object({
		count: z.int(),
	}),
	recast: z.optional(z.boolean()),
	tags: z.optional(
		z.array(
			z.object({
				type: z.optional(z.string()),
				id: z.optional(z.string()),
				name: z.optional(z.string()),
				imageUrl: z.optional(z.string()),
			}),
		),
	),
	quoteCount: z.optional(z.int()),
	combinedRecastCount: z.optional(z.int()),
	channel: z.optional(
		z.object({
			key: z.optional(z.string()),
			name: z.optional(z.string()),
			imageUrl: z.optional(z.string()),
			authorContext: z.optional(
				z.object({
					role: z.optional(z.string()),
					restricted: z.optional(z.boolean()),
					banned: z.optional(z.boolean()),
				}),
			),
			authorRole: z.optional(z.string()),
		}),
	),
	viewerContext: z.optional(
		z.object({
			reacted: z.optional(z.boolean()),
			recast: z.optional(z.boolean()),
			bookmarked: z.optional(z.boolean()),
		}),
	),
});

export const zFeedItemsResponse = z.object({
	result: z.object({
		items: z.array(
			z.object({
				id: z.string(),
				timestamp: z.int(),
				cast: zCast,
				otherParticipants: z.optional(z.array(zUser)),
			}),
		),
		latestMainCastTimestamp: z.optional(z.int()),
		feedTopSeenAtTimestamp: z.optional(z.int()),
		replaceFeed: z.boolean(),
	}),
});

export const zGenericResponse = z.object({
	result: z.record(z.string(), z.unknown()),
});

export const zUserResponse = zGenericResponse.and(
	z.object({
		result: z.object({
			user: z.optional(zUserWithExtras),
			collectionsOwned: z.optional(z.array(z.record(z.string(), z.unknown()))),
			extras: z.optional(zUserExtras),
		}),
	}),
);

export const zPaginatedResponse = z.object({
	result: z.record(z.string(), z.unknown()),
	next: z.optional(zPaginationCursor),
});

export const zSuggestedUsersResponse = zPaginatedResponse.and(
	z.object({
		result: z.optional(
			z.object({
				users: z.optional(z.array(z.record(z.string(), z.unknown()))),
			}),
		),
	}),
);

export const zFavoriteFramesResponse = z.object({
	result: z.object({
		frames: z.array(z.record(z.string(), z.unknown())),
	}),
});

export const zChannelStreaksResponse = z.object({
	result: z.record(z.string(), z.unknown()),
});

export const zUnseenCountsResponse = z.object({
	result: z.object({
		notificationsCount: z.optional(z.int()),
		notificationTabs: z.optional(
			z.array(
				z.object({
					tab: z.string(),
					unseenCount: z.int(),
				}),
			),
		),
		inboxCount: z.optional(z.int()),
		channelFeeds: z.optional(
			z.array(
				z.object({
					channelKey: z.string(),
					feedType: z.string(),
					hasNewItems: z.boolean(),
				}),
			),
		),
		warpTransactionCount: z.optional(z.int()),
	}),
});

export const zUserThreadCastsResponse = z.object({
	result: z.object({
		casts: z.array(z.record(z.string(), z.unknown())),
	}),
});

export const zChannelFollowersYouKnowResponse = z.object({
	result: z.object({
		users: z.array(z.record(z.string(), z.unknown())),
		totalCount: z.int(),
	}),
});

export const zSuccessResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				success: z.boolean().register(z.globalRegistry, {
					description: "Whether the operation was successful",
				}),
			}),
		),
	}),
);

export const zNotificationsResponse = z.object({
	result: z.object({
		notifications: z.optional(z.array(z.record(z.string(), z.unknown()))),
	}),
});

export const zDirectCastConversationResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				conversation: zDirectCastConversation,
			}),
		),
	}),
);

export const zDirectCastConversationCategorizationRequest = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation to categorize",
	}),
	category: z.string().register(z.globalRegistry, {
		description: "Category to assign to the conversation",
	}),
});

export const zDirectCastConversationMessagesResponse = zPaginatedResponse.and(
	z.object({
		result: z.optional(
			z.object({
				messages: z.array(zDirectCastMessage),
			}),
		),
	}),
);

export const zDirectCastConversationMessageTtlRequest = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation to set message TTL for",
	}),
	ttl: z.int().register(z.globalRegistry, {
		description: "Time to live for messages in days",
	}),
});

export const zDirectCastConversationNotificationsRequest = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation to update notification settings for",
	}),
	muted: z.boolean().register(z.globalRegistry, {
		description: "Whether to mute notifications for this conversation",
	}),
});

export const zDirectCastSendRequest = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation to send the message to",
	}),
	recipientFids: z.array(z.int()).register(z.globalRegistry, {
		description: "Array of Farcaster IDs of message recipients",
	}),
	messageId: z.string().register(z.globalRegistry, {
		description: "Unique identifier for the message",
	}),
	type: z
		.enum(["text", "image", "reaction", "link"])
		.register(z.globalRegistry, {
			description: "Type of the message",
		}),
	message: z.string().register(z.globalRegistry, {
		description: "Content of the message",
	}),
	inReplyToId: z.optional(
		z.string().register(z.globalRegistry, {
			description: "ID of the message this is replying to (optional)",
		}),
	),
});

export const zDirectCastManuallyMarkUnreadRequest = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation to mark as unread",
	}),
});

export const zDirectCastMessageReactionRequest = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation containing the message",
	}),
	messageId: z.string().register(z.globalRegistry, {
		description: "ID of the message to react to",
	}),
	reaction: z.string().register(z.globalRegistry, {
		description: "Emoji reaction to add or remove",
	}),
});

export const zDirectCastPinConversationRequest = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation to pin",
	}),
});

export const zDiscoverChannelsResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				channels: z.optional(z.array(z.record(z.string(), z.unknown()))),
			}),
		),
	}),
);

export const zInvitesAvailableResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				allocatedInvitesCount: z.int().register(z.globalRegistry, {
					description: "Total number of invites allocated to the user",
				}),
				availableInvitesCount: z.int().register(z.globalRegistry, {
					description: "Number of invites currently available to send",
				}),
			}),
		),
	}),
);

export const zSponsoredInvitesResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				invites: z.optional(z.array(z.record(z.string(), z.unknown()))),
			}),
		),
	}),
);

export const zRewardsLeaderboardResponse = z.object({
	result: z.object({
		leaderboard: z.object({
			type: z.string(),
			users: z.array(
				z.object({
					user: z.optional(z.record(z.string(), z.unknown())),
					score: z.optional(z.int()),
					rank: z.optional(z.int()),
				}),
			),
		}),
	}),
});

export const zRewardsScoresResponse = z.object({
	result: z.object({
		scores: z.array(
			z.object({
				type: z.optional(z.string()),
				user: z.optional(z.record(z.string(), z.unknown())),
				allTimeScore: z.optional(z.int()),
				currentPeriodScore: z.optional(z.int()),
				previousPeriodScore: z.optional(z.int()),
			}),
		),
	}),
});

export const zRewardsMetadataResponse = z.object({
	result: z.object({
		metadata: z.optional(
			z.object({
				type: z.optional(z.string()),
				lastUpdateTimestamp: z.optional(z.int()),
				currentPeriodStartTimestamp: z.optional(z.int()),
				currentPeriodEndTimestamp: z.optional(z.int()),
				tiers: z.optional(z.array(z.record(z.string(), z.unknown()))),
				proportionalPayout: z.optional(
					z.object({
						numWinners: z.optional(z.int()),
						totalRewardCents: z.optional(z.int()),
					}),
				),
			}),
		),
	}),
});

export const zBookmarkedCast = z.record(z.string(), z.unknown());

export const zBookmarkedCastsResponse = z.object({
	result: z.object({
		bookmarks: z.optional(z.array(zBookmarkedCast)),
	}),
});

export const zStarterPack = z.object({
	id: z.string().register(z.globalRegistry, {
		description: "Unique identifier for the starter pack",
	}),
	creator: z.optional(zUser),
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Display name of the starter pack",
		}),
	),
	description: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Description of the starter pack",
		}),
	),
	openGraphImageUrl: z.optional(
		z.url().register(z.globalRegistry, {
			description: "URL for OG image preview",
		}),
	),
	itemCount: z.optional(
		z.int().register(z.globalRegistry, {
			description: "Number of items in the starter pack",
		}),
	),
	items: z.optional(
		z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
			description: "Items contained in the starter pack",
		}),
	),
	labels: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "Labels/tags for the starter pack",
		}),
	),
});

export const zStarterPacksResponse = z.object({
	result: z.object({
		starterPacks: z.array(zStarterPack),
	}),
});

export const zStarterPackResponse = z.object({
	result: z.object({
		starterPack: zStarterPack,
	}),
});

export const zStarterPackUpdateRequest = z.object({
	id: z.string().register(z.globalRegistry, {
		description: "Unique identifier for the starter pack to update",
	}),
	name: z.string().register(z.globalRegistry, {
		description: "Display name of the starter pack",
	}),
	description: z.string().register(z.globalRegistry, {
		description: "Description of the starter pack",
	}),
	fids: z.array(z.int()).register(z.globalRegistry, {
		description: "List of FIDs included in the starter pack",
	}),
	labels: z.array(z.string()).register(z.globalRegistry, {
		description: "Labels/tags for the starter pack",
	}),
});

export const zStarterPackUsersResponse = z.object({
	result: z.object({
		users: z.array(zUser),
	}),
});

export const zChannelResponse = z.object({
	result: z.object({
		channel: z.optional(zChannel),
	}),
});

export const zChannelUsersResponse = z.object({
	result: z.object({
		users: z.optional(z.array(zUser)),
	}),
});

export const zUsersResponse = z.object({
	result: z.object({
		users: z.array(zUser),
	}),
});

export const zUsersWithCountResponse = z.object({
	result: z.object({
		users: z.array(zUser),
		totalCount: z.int(),
	}),
});

export const zFrameApp = z.record(z.string(), z.unknown());

export const zFrameAppsResponse = z.object({
	result: z.optional(
		z.object({
			frames: z.optional(z.array(zFrameApp)),
		}),
	),
});

/**
 * Context information for the viewer
 */
export const zMiniAppViewerContext = z
	.record(z.string(), z.unknown())
	.register(z.globalRegistry, {
		description: "Context information for the viewer",
	});

export const zMiniApp = z.object({
	domain: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The domain of the mini app",
		}),
	),
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The name of the mini app",
		}),
	),
	iconUrl: z.optional(
		z.string().register(z.globalRegistry, {
			description: "URL to the mini app's icon",
		}),
	),
	homeUrl: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The home URL of the mini app",
		}),
	),
	author: z.optional(zUser),
	supportsNotifications: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the mini app supports notifications",
		}),
	),
	id: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Unique identifier for the mini app",
		}),
	),
	shortId: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Short identifier for the mini app",
		}),
	),
	imageUrl: z.optional(
		z.string().register(z.globalRegistry, {
			description: "URL to the mini app's main image",
		}),
	),
	buttonTitle: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Title for the action button",
		}),
	),
	splashImageUrl: z.optional(
		z.string().register(z.globalRegistry, {
			description: "URL to the splash screen image",
		}),
	),
	splashBackgroundColor: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Background color for the splash screen",
		}),
	),
	castShareUrl: z.optional(
		z.string().register(z.globalRegistry, {
			description: "URL for sharing casts",
		}),
	),
	subtitle: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Subtitle of the mini app",
		}),
	),
	description: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Description of the mini app",
		}),
	),
	tagline: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Tagline of the mini app",
		}),
	),
	heroImageUrl: z.optional(
		z.string().register(z.globalRegistry, {
			description: "URL to the hero image",
		}),
	),
	primaryCategory: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Primary category of the mini app",
		}),
	),
	tags: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "Tags associated with the mini app",
		}),
	),
	screenshotUrls: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "URLs to screenshot images",
		}),
	),
	noindex: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the mini app should be indexed",
		}),
	),
	ogTitle: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Open Graph title",
		}),
	),
	ogDescription: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Open Graph description",
		}),
	),
	ogImageUrl: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Open Graph image URL",
		}),
	),
	requiredCapabilities: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "Required capabilities for the mini app",
		}),
	),
	requiredChains: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "Required blockchain chains",
		}),
	),
	viewerContext: z.optional(zMiniAppViewerContext),
});

export const zRankedMiniApp = z.object({
	rank: z.optional(
		z.int().register(z.globalRegistry, {
			description: "Current rank of the mini app",
		}),
	),
	miniApp: z.optional(zMiniApp),
	rank72hChange: z.optional(
		z.int().register(z.globalRegistry, {
			description: "Change in rank over the last 72 hours",
		}),
	),
});

export const zTopMiniAppsResponse = z.object({
	result: z.optional(
		z.object({
			miniApps: z.optional(z.array(zRankedMiniApp)),
			next: z.optional(zPaginationCursor),
		}),
	),
});

export const zVerifiedAddress = z.object({
	fid: z.optional(z.int()),
	address: z.optional(z.string()),
	timestamp: z.optional(z.int()),
	version: z.optional(z.string()),
	protocol: z.optional(z.string()),
	isPrimary: z.optional(z.boolean()),
	labels: z.optional(z.array(z.string())),
});

export const zMutedKeywordProperties = z.object({
	channels: z.optional(z.boolean()),
	frames: z.optional(z.boolean()),
	notifications: z.optional(z.boolean()),
});

export const zMutedKeyword = z.object({
	keyword: z.string(),
	properties: zMutedKeywordProperties,
});

export const zMutedKeywordsResponse = z.object({
	success: z.boolean(),
	result: z.object({
		keywords: z.array(z.string()),
		mutedKeywords: z.array(zMutedKeyword),
	}),
});

export const zCastHashResponse = z.object({
	result: z.object({
		castHash: z.optional(z.string()),
	}),
});

export const zAttachEmbedsResponse = z.object({
	result: z.record(z.string(), z.unknown()),
});

export const zCastRecastersResponse = z.object({
	result: z.object({
		users: z.optional(z.array(zUser)),
	}),
});

export const zCastQuote = z.object({
	hash: z.optional(z.string()),
	threadHash: z.optional(z.string()),
	parentSource: z.optional(
		z.object({
			type: z.optional(z.string()),
			url: z.optional(z.string()),
		}),
	),
	author: z.optional(zUser),
	text: z.optional(z.string()),
	timestamp: z.optional(z.int()),
});

export const zCastQuotesResponse = z.object({
	result: z.object({
		quotes: z.optional(z.array(zCastQuote)),
	}),
});

export const zUserResponseUserResponse = z.object({
	result: z.object({
		user: zUser,
	}),
});

export const zSearchChannelsResponse = z.object({
	result: z.optional(
		z.object({
			channels: z.optional(z.array(zChannel)),
		}),
	),
});

export const zDraftsResponse = z.object({
	result: z.optional(
		z.object({
			drafts: z.optional(z.array(z.unknown())),
		}),
	),
});

export const zDraftCast = z.object({
	text: z.optional(z.string()),
	embeds: z.optional(z.array(z.unknown())),
});

export const zDraft = z.object({
	draftId: z.optional(z.string()),
	casts: z.optional(z.array(zDraftCast)),
});

export const zDraftCreatedResponse = z.object({
	result: z.optional(
		z.object({
			draft: z.optional(zDraft),
		}),
	),
});

export const zCastCreatedResponse = z.object({
	result: z.optional(
		z.object({
			cast: z.optional(zCast),
		}),
	),
});

export const zRawChannel = z.object({
	id: z.optional(z.string()),
	url: z.optional(z.string()),
	name: z.optional(z.string()),
	description: z.optional(z.string()),
	descriptionMentions: z.optional(z.array(z.int())),
	descriptionMentionsPositions: z.optional(z.array(z.int())),
	imageUrl: z.optional(z.string()),
	headerImageUrl: z.optional(z.string()),
	leadFid: z.optional(z.int()),
	moderatorFids: z.optional(z.array(z.int())),
	createdAt: z.optional(z.int()),
	followerCount: z.optional(z.int()),
	memberCount: z.optional(z.int()),
	pinnedCastHash: z.optional(z.string()),
	publicCasting: z.optional(z.boolean()),
	externalLink: z.optional(
		z.object({
			title: z.optional(z.string()),
			url: z.optional(z.string()),
		}),
	),
});

export const zChannelListResponse = z.object({
	result: z.optional(
		z.object({
			channels: z.optional(z.array(zRawChannel)),
		}),
	),
});

export const zRawChannelResponse = z.object({
	result: z.optional(
		z.object({
			channel: z.optional(zRawChannel),
		}),
	),
});

export const zChannelFollower = z.object({
	fid: z.optional(z.int()),
	followedAt: z.optional(z.int()),
});

export const zChannelFollowersResponse = zPaginatedResponse.and(
	z.object({
		result: z.optional(
			z.object({
				users: z.optional(z.array(zChannelFollower)),
			}),
		),
	}),
);

export const zChannelFollowStatus = z.object({
	following: z.optional(z.boolean()),
	followedAt: z.optional(z.int()),
});

export const zChannelFollowStatusResponse = z.object({
	result: z.optional(zChannelFollowStatus),
});

export const zAction = z.object({
	name: z.optional(z.string()),
	icon: z.optional(z.string()),
	description: z.optional(z.string()),
	aboutUrl: z.optional(z.url()),
	imageUrl: z.optional(z.url()),
	actionUrl: z.optional(z.url()),
	action: z.optional(
		z.object({
			actionType: z.optional(z.enum(["post", "get", "put", "delete"])),
			postUrl: z.optional(z.url()),
		}),
	),
});

export const zWinner = z.object({
	fid: z.optional(
		z.int().register(z.globalRegistry, {
			description: "The fid of the winner",
		}),
	),
	domain: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The domain of the winner",
		}),
	),
	frameName: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The name of the frame (mini app)",
		}),
	),
	score: z.optional(
		z.int().register(z.globalRegistry, {
			description: "The score of the winner",
		}),
	),
	rank: z.optional(
		z.int().register(z.globalRegistry, {
			description: "The rank of the winner",
		}),
	),
	rewardCents: z.optional(
		z.int().register(z.globalRegistry, {
			description: "The reward amount in cents",
		}),
	),
	walletAddress: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The wallet address of the winner (optional)",
		}),
	),
});

export const zFrame = z.object({
	domain: z.optional(z.string()),
	name: z.optional(z.string()),
	iconUrl: z.optional(z.string()),
	homeUrl: z.optional(z.string()),
	splashImageUrl: z.optional(z.string()),
	splashBackgroundColor: z.optional(z.string()),
	buttonTitle: z.optional(z.union([z.string(), z.null()])),
	imageUrl: z.optional(z.union([z.string(), z.null()])),
	supportsNotifications: z.optional(z.boolean()),
	viewerContext: z.optional(z.record(z.string(), z.unknown())),
	author: z.optional(zUser),
});

export const zAppsByAuthorResponse = z.object({
	result: z.optional(
		z.object({
			frames: z.optional(z.array(zFrame)),
		}),
	),
});

export const zApiKey = z.object({
	id: z.uuid().register(z.globalRegistry, {
		description: "Unique identifier for the API key",
	}),
	createdAt: z.coerce.bigint().register(z.globalRegistry, {
		description:
			"Timestamp when the API key was created (in milliseconds since epoch)",
	}),
	expiresAt: z.coerce.bigint().register(z.globalRegistry, {
		description:
			"Timestamp when the API key expires (in milliseconds since epoch)",
	}),
	revokedAt: z.optional(z.union([z.string(), z.null()])),
	tag: z.string().register(z.globalRegistry, {
		description: "Short identifier tag for the API key",
	}),
	description: z.string().register(z.globalRegistry, {
		description: "User-provided description of the API key's purpose",
	}),
});

/**
 * Generic 400 Bad Request error for simple error messages
 */
export const zGenericBadRequestError = z
	.object({
		errors: z.array(
			z.object({
				message: z.string().register(z.globalRegistry, {
					description: "Error message describing the issue",
				}),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Generic 400 Bad Request error for simple error messages",
	});

export const zDirectCastSendResponse = zSuccessResponse;

export const zDirectCastConversationCategorizationResponse = zSuccessResponse;

export const zDirectCastConversationNotificationsResponse = zSuccessResponse;

export const zDirectCastConversationMessageTtlResponse = zSuccessResponse;

export const zDirectCastMessageReactionResponse = zSuccessResponse;

/**
 * The user's FID (Farcaster ID)
 */
export const zFidParam = z.int().register(z.globalRegistry, {
	description: "The user's FID (Farcaster ID)",
});

/**
 * Maximum number of items to return
 */
export const zLimitParam = z
	.int()
	.gte(1)
	.lte(100)
	.register(z.globalRegistry, {
		description: "Maximum number of items to return",
	})
	.default(50);

/**
 * Base64 encoded cursor for pagination
 */
export const zCursorParam = z.string().register(z.globalRegistry, {
	description: "Base64 encoded cursor for pagination",
});

export const zGetUserOnboardingStateData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful retrieval of onboarding state
 */
export const zGetUserOnboardingStateResponse = zOnboardingStateResponse;

export const zGetUserByFidData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
	}),
});

/**
 * Successful retrieval of user by fid
 */
export const zGetUserByFidResponse = zUserByFidResponse;

export const zGetDirectCastInboxData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
			category: z.optional(
				z.enum(["default", "requests", "spam"]).register(z.globalRegistry, {
					description: "Category of conversations to retrieve",
				}),
			),
			filter: z.optional(
				z.enum(["unread", "group", "1-1"]).register(z.globalRegistry, {
					description: "Filter for conversations (e.g., unread, all)",
				}),
			),
			cursor: z.optional(
				z.string().register(z.globalRegistry, {
					description: "Base64 encoded cursor from previous response",
				}),
			),
		}),
	),
});

/**
 * Successful retrieval of direct cast inbox
 */
export const zGetDirectCastInboxResponse = zDirectCastInboxResponse;

export const zGetUserAppContextData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful retrieval of user app context
 */
export const zGetUserAppContextResponse = zUserAppContextResponse;

export const zGetUserPreferencesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful retrieval of user preferences
 */
export const zGetUserPreferencesResponse = zUserPreferencesResponse;

export const zGetHighlightedChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful retrieval of highlighted channels
 */
export const zGetHighlightedChannelsResponse = zHighlightedChannelsResponse;

export const zGetFeedItemsData = z.object({
	body: z.object({
		feedKey: z.string().register(z.globalRegistry, {
			description: "Identifier for the specific feed",
		}),
		feedType: z.string().register(z.globalRegistry, {
			description: "Type of feed to retrieve",
		}),
		olderThan: z.optional(
			z.coerce.bigint().register(z.globalRegistry, {
				description: "Only return items older than this timestamp (ms)",
			}),
		),
		latestMainCastTimestamp: z.optional(
			z.coerce.bigint().register(z.globalRegistry, {
				description: "Latest main cast timestamp used for pagination (ms)",
			}),
		),
		excludeItemIdPrefixes: z.optional(
			z.array(z.string()).register(z.globalRegistry, {
				description: "List of item ID prefixes to exclude from the response",
			}),
		),
		castViewEvents: z.optional(
			z
				.array(
					z.object({
						ts: z.coerce.bigint().register(z.globalRegistry, {
							description: "Event timestamp in ms",
						}),
						hash: z.string().register(z.globalRegistry, {
							description: "Cast hash",
						}),
						on: z.string().register(z.globalRegistry, {
							description: "Context of the view event",
						}),
						channel: z.string().register(z.globalRegistry, {
							description: "Channel key",
						}),
						feed: z.string().register(z.globalRegistry, {
							description: "Feed type where event occurred",
						}),
					}),
				)
				.register(z.globalRegistry, {
					description: "View events for casts",
				}),
		),
		updateState: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Whether to update the feed state",
			}),
		),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful retrieval of feed items
 */
export const zGetFeedItemsResponse = zFeedItemsResponse;

export const zGetUserData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
	}),
});

/**
 * Successful retrieval of user information
 */
export const zGetUserResponse = zUserResponse;

export const zGetUserFollowingChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			forComposer: z.optional(
				z.boolean().register(z.globalRegistry, {
					description:
						"Whether results are intended for the composer interface",
				}),
			),
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
		}),
	),
});

/**
 * Successful retrieval of followed channels
 */
export const zGetUserFollowingChannelsResponse = zHighlightedChannelsResponse;

export const zGetSuggestedUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
			randomized: z.optional(z.boolean()),
		}),
	),
});

/**
 * Successful retrieval of suggested users
 */
export const zGetSuggestedUsersResponse = zSuggestedUsersResponse;

export const zGetUserFavoriteFramesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
		}),
	),
});

/**
 * Successful retrieval of favorite frames
 */
export const zGetUserFavoriteFramesResponse = zFavoriteFramesResponse;

export const zGetUserByUsernameData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		username: z.string().register(z.globalRegistry, {
			description: "The username to look up",
		}),
	}),
});

/**
 * Successful retrieval of user by username
 */
export const zGetUserByUsernameResponse = zUserByFidResponse;

export const zGetChannelStreaksForUserData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
	}),
});

/**
 * Successful retrieval of channel streaks
 */
export const zGetChannelStreaksForUserResponse = zChannelStreaksResponse;

export const zGetUnseenCountsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful retrieval of unseen feed and notification data
 */
export const zGetUnseenCountsResponse = zUnseenCountsResponse;

export const zGetUserThreadCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of items to return",
				}),
			)
			.default(50),
		castHashPrefix: z.string().register(z.globalRegistry, {
			description: "The hash prefix of the cast",
		}),
		username: z.string().register(z.globalRegistry, {
			description: "The username of the user",
		}),
	}),
});

/**
 * Successful retrieval of user thread casts
 */
export const zGetUserThreadCastsResponse = zUserThreadCastsResponse;

export const zGetChannelFollowersYouKnowData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelKey: z.string(),
		limit: z.optional(z.int()),
	}),
});

/**
 * Successful retrieval of known channel followers
 */
export const zGetChannelFollowersYouKnowResponse =
	zChannelFollowersYouKnowResponse;

export const zMarkAllNotificationsReadData = z.object({
	body: z.record(z.string(), z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful mark-all-read operation
 */
export const zMarkAllNotificationsReadResponse = zSuccessResponse;

export const zGetNotificationsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		tab: z
			.enum(["all", "follows", "reactions", "mentions", "replies"])
			.register(z.globalRegistry, {
				description: "Notification tab type",
			}),
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Number of notifications to return",
				}),
			)
			.default(15),
	}),
});

/**
 * A list of notifications
 */
export const zGetNotificationsResponse = zNotificationsResponse;

export const zSetLastCheckedTimestampData = z.object({
	body: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
		description: "Empty object for now",
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Success
 */
export const zSetLastCheckedTimestampResponse = zSuccessResponse;

export const zGetDirectCastConversationData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		conversationId: z.string().register(z.globalRegistry, {
			description:
				'Conversation ID. Format depends on conversation type:\n- 1:1 conversations: "fid1-fid2" (e.g., "123-456")\n- Group conversations: Hash format (e.g., "a1b2c3d4e5f6...")\n',
		}),
	}),
});

/**
 * A direct cast conversation object
 */
export const zGetDirectCastConversationResponse =
	zDirectCastConversationResponse;

export const zCategorizeDirectCastConversationData = z.object({
	body: zDirectCastConversationCategorizationRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Conversation categorized successfully
 */
export const zCategorizeDirectCastConversationResponse = zSuccessResponse;

export const zGetDirectCastConversationMessagesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		conversationId: z.string().register(z.globalRegistry, {
			description:
				'Conversation ID. Format depends on conversation type:\n- 1:1 conversations: "fid1-fid2" (e.g., "123-456")\n- Group conversations: Hash format (e.g., "c9e139dcbc9423cf")\n',
		}),
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of messages to return",
				}),
			)
			.default(50),
	}),
});

/**
 * A list of direct cast conversation messages with pagination
 */
export const zGetDirectCastConversationMessagesResponse =
	zDirectCastConversationMessagesResponse;

export const zSetDirectCastConversationMessageTtlData = z.object({
	body: zDirectCastConversationMessageTtlRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Message TTL set successfully
 */
export const zSetDirectCastConversationMessageTtlResponse = zSuccessResponse;

export const zUpdateDirectCastConversationNotificationsData = z.object({
	body: zDirectCastConversationNotificationsRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Notification settings updated successfully
 */
export const zUpdateDirectCastConversationNotificationsResponse =
	zSuccessResponse;

export const zGetDirectCastConversationRecentMessagesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		conversationId: z.string().register(z.globalRegistry, {
			description:
				'Conversation ID. Format depends on conversation type:\n- 1:1 conversations: "fid1-fid2" (e.g., "123-456")\n- Group conversations: Hash format (e.g., "c9e139dcbc9423cf")\n',
		}),
	}),
});

/**
 * A list of recent direct cast conversation messages
 */
export const zGetDirectCastConversationRecentMessagesResponse =
	zDirectCastConversationMessagesResponse;

export const zSendDirectCastMessageData = z.object({
	body: zDirectCastSendRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Direct cast message sent successfully
 */
export const zSendDirectCastMessageResponse = zSuccessResponse;

export const zDirectCastManuallyMarkUnreadData = z.object({
	body: zDirectCastManuallyMarkUnreadRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Direct cast conversation marked as unread successfully
 */
export const zDirectCastManuallyMarkUnreadResponse = zSuccessResponse;

export const zRemoveDirectCastMessageReactionData = z.object({
	body: zDirectCastMessageReactionRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Reaction removed successfully
 */
export const zRemoveDirectCastMessageReactionResponse = zSuccessResponse;

export const zAddDirectCastMessageReactionData = z.object({
	body: zDirectCastMessageReactionRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Reaction added successfully
 */
export const zAddDirectCastMessageReactionResponse = zSuccessResponse;

export const zUnpinDirectCastConversationData = z.object({
	body: zDirectCastPinConversationRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Direct cast conversation unpinned successfully
 */
export const zUnpinDirectCastConversationResponse = zSuccessResponse;

export const zPinDirectCastConversationData = z.object({
	body: zDirectCastPinConversationRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Direct cast conversation pinned successfully
 */
export const zPinDirectCastConversationResponse = zSuccessResponse;

export const zDiscoverChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of channels to retrieve",
					}),
				)
				.default(15),
		}),
	),
});

/**
 * A list of channels
 */
export const zDiscoverChannelsResponse2 = zDiscoverChannelsResponse;

export const zGetAvailableInvitesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Invite count information
 */
export const zGetAvailableInvitesResponse = zInvitesAvailableResponse;

export const zGetSponsoredInvitesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * List of sponsored invites
 */
export const zGetSponsoredInvitesResponse = zSponsoredInvitesResponse;

export const zGetRewardsLeaderboardData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of items to return",
				}),
			)
			.default(50),
		rewardsType: z.enum(["invite"]),
		cursor: z.optional(z.string()),
	}),
});

/**
 * Rewards leaderboard
 */
export const zGetRewardsLeaderboardResponse = zRewardsLeaderboardResponse;

export const zGetUserRewardsScoresData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
		rewardsType: z.enum(["invite"]),
	}),
});

/**
 * User rewards scores
 */
export const zGetUserRewardsScoresResponse = zRewardsScoresResponse;

export const zGetRewardsMetadataData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		rewardsType: z.enum(["invite"]),
	}),
});

/**
 * Invite rewards metadata
 */
export const zGetRewardsMetadataResponse = zRewardsMetadataResponse;

export const zGetBookmarkedCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
		}),
	),
});

/**
 * A list of bookmarked casts
 */
export const zGetBookmarkedCastsResponse = zBookmarkedCastsResponse;

export const zGetUserStarterPacksData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()).default(15),
	}),
});

/**
 * A list of starter packs
 */
export const zGetUserStarterPacksResponse = zStarterPacksResponse;

export const zGetSuggestedStarterPacksData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int()).default(15),
		}),
	),
});

/**
 * A list of suggested starter packs
 */
export const zGetSuggestedStarterPacksResponse = zStarterPacksResponse;

export const zGetStarterPackData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		id: z.string(),
	}),
});

/**
 * A starter pack object
 */
export const zGetStarterPackResponse = zStarterPackResponse;

export const zUpdateStarterPackData = z.object({
	body: zStarterPackUpdateRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
	headers: z.optional(
		z.object({
			"idempotency-key": z.optional(
				z.string().register(z.globalRegistry, {
					description:
						"Idempotency key to safely retry the request without performing the operation multiple times.",
				}),
			),
		}),
	),
});

/**
 * Update status
 */
export const zUpdateStarterPackResponse = zSuccessResponse;

export const zGetStarterPackUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of items to return",
				}),
			)
			.default(50),
		id: z.string(),
	}),
});

/**
 * List of users in the starter pack
 */
export const zGetStarterPackUsersResponse = zStarterPackUsersResponse;

export const zGetChannelData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		key: z.string(),
	}),
});

/**
 * Channel metadata
 */
export const zGetChannelResponse = zChannelResponse;

export const zGetChannelUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of items to return",
				}),
			)
			.default(50),
		channelKey: z.string(),
		filterToMembers: z.optional(z.boolean()),
		query: z.optional(z.string()),
	}),
});

/**
 * A list of users in the specified channel
 */
export const zGetChannelUsersResponse = zChannelUsersResponse;

export const zGetFollowingData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()),
	}),
});

/**
 * A list of followed users
 */
export const zGetFollowingResponse = zUsersResponse;

export const zGetFollowersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()),
	}),
});

/**
 * A list of followers
 */
export const zGetFollowersResponse = zUsersResponse;

export const zGetMutualFollowersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()),
	}),
});

/**
 * A list of mutual followers
 */
export const zGetMutualFollowersResponse = zUsersWithCountResponse;

export const zGetTopFrameAppsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
			cursor: z.optional(z.string()),
		}),
	),
});

/**
 * A list of FrameApps
 */
export const zGetTopFrameAppsResponse = zFrameAppsResponse;

export const zGetTopMiniAppsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
			cursor: z.optional(
				z.string().register(z.globalRegistry, {
					description: "Base64 encoded cursor for pagination",
				}),
			),
		}),
	),
});

/**
 * A list of top mini apps
 */
export const zGetTopMiniAppsResponse = zTopMiniAppsResponse;

export const zGetVerificationsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of items to return",
				}),
			)
			.default(50),
	}),
});

/**
 * A list of verifications
 */
export const zGetVerificationsResponse = z
	.object({
		result: z.optional(
			z.object({
				verifications: z.optional(z.array(zVerifiedAddress)),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "A list of verifications",
	});

export const zGetMutedKeywordsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * A list of muted keywords
 */
export const zGetMutedKeywordsResponse = zMutedKeywordsResponse;

export const zMuteKeywordData = z.object({
	body: z.object({
		keyword: z.optional(z.string()),
		properties: z.optional(zMutedKeywordProperties),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * The muted keyword and its settings
 */
export const zMuteKeywordResponse = zMutedKeywordsResponse;

export const zUnmuteKeywordData = z.object({
	body: z.object({
		keyword: z.optional(z.string()),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Keyword unmuted
 */
export const zUnmuteKeywordResponse = zMutedKeywordsResponse;

export const zUnlikeCastData = z.object({
	body: z.object({
		castHash: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Unlike response
 */
export const zUnlikeCastResponse = z
	.object({
		result: z.optional(
			z.object({
				success: z.optional(z.boolean()),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Unlike response",
	});

export const zGetCastLikesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		castHash: z.string(),
		limit: z.optional(z.int()).default(15),
	}),
});

/**
 * A list of cast likes
 */
export const zGetCastLikesResponse = z
	.object({
		result: z.optional(
			z.object({
				likes: z.optional(
					z.array(
						z.object({
							type: z.optional(z.string()),
							hash: z.optional(z.string()),
							castHash: z.optional(z.string()),
							timestamp: z.optional(z.int()),
							reactor: z.optional(zUser),
						}),
					),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "A list of cast likes",
	});

export const zLikeCastData = z.object({
	body: z.object({
		castHash: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Like response
 */
export const zLikeCastResponse = z
	.object({
		result: z.optional(
			z.object({
				like: z.optional(
					z.object({
						type: z.optional(z.string()),
						hash: z.optional(z.string()),
						castHash: z.optional(z.string()),
						timestamp: z.optional(z.int()),
						reactor: z.optional(zUser),
					}),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Like response",
	});

export const zUndoRecastData = z.object({
	body: z.object({
		castHash: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Undo recast response
 */
export const zUndoRecastResponse = zSuccessResponse;

export const zRecastCastData = z.object({
	body: z.object({
		castHash: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Recast response
 */
export const zRecastCastResponse = zCastHashResponse;

export const zAttachEmbedsData = z.object({
	body: z.object({
		text: z.optional(z.string()),
		embeds: z.optional(z.array(z.url())),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Attachment response
 */
export const zAttachEmbedsResponse2 = zAttachEmbedsResponse;

export const zGetCastRecastersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of items to return",
				}),
			)
			.default(50),
		castHash: z.string(),
	}),
});

/**
 * A list of users who recasted the cast
 */
export const zGetCastRecastersResponse = zCastRecastersResponse;

export const zGetCastQuotesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		castHash: z.string(),
		limit: z.optional(z.int()).default(15),
	}),
});

/**
 * A list of quote casts referencing the given cast
 */
export const zGetCastQuotesResponse = zCastQuotesResponse;

export const zGetCurrentUserData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful retrieval of current user
 */
export const zGetCurrentUserResponse = zUserResponseUserResponse;

export const zSearchChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
			q: z.optional(z.string()),
			prioritizeFollowed: z.optional(z.boolean()).default(true),
			forComposer: z.optional(z.boolean()).default(false),
		}),
	),
});

/**
 * A list of matched channels
 */
export const zSearchChannelsResponse2 = zSearchChannelsResponse;

export const zGetDraftCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int()).default(15),
		}),
	),
});

/**
 * A list of draft cast storms
 */
export const zGetDraftCastsResponse = zDraftsResponse;

export const zCreateDraftCastsData = z.object({
	body: z.object({
		caststorm: z.optional(
			z.object({
				casts: z.optional(z.array(zDraftCast)),
			}),
		),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
	headers: z.object({
		"idempotency-key": z.uuid(),
	}),
});

/**
 * Created draft caststorm
 */
export const zCreateDraftCastsResponse = zDraftCreatedResponse;

export const zDeleteDraftCastData = z.object({
	body: z.object({
		draftId: z.optional(z.string()),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Draft cast deleted
 */
export const zDeleteDraftCastResponse = zSuccessResponse;

export const zDeleteCastData = z.object({
	body: z.object({
		castHash: z.optional(z.string()),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Cast deleted successfully
 */
export const zDeleteCastResponse = zSuccessResponse;

export const zGetCastsByFidData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The FID (Farcaster ID) of the user whose casts to retrieve",
		}),
		limit: z
			.optional(
				z.int().register(z.globalRegistry, {
					description: "Maximum number of casts to return",
				}),
			)
			.default(15),
	}),
});

/**
 * Successfully retrieved casts
 */
export const zGetCastsByFidResponse = z
	.object({
		result: z.optional(
			z.object({
				casts: z.optional(z.array(zCast)),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successfully retrieved casts",
	});

export const zCreateCastData = z.object({
	body: z.object({
		text: z.string(),
		embeds: z.optional(z.array(z.unknown())),
		channelKey: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Optional channel to post the cast to",
			}),
		),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Cast created successfully
 */
export const zCreateCastResponse = zCastCreatedResponse;

export const zGetAllChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const zGetAllChannelsResponse = zChannelListResponse;

export const zGetChannelDetailsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
	}),
});

/**
 * Channel details
 */
export const zGetChannelDetailsResponse = zRawChannelResponse;

export const zGetChannelFollowersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
		cursor: z.optional(z.string()),
	}),
});

/**
 * A list of channel followers
 */
export const zGetChannelFollowersResponse = zChannelFollowersResponse;

export const zGetUserFollowedChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
	}),
});

/**
 * Successful response with list of followed channels
 */
export const zGetUserFollowedChannelsResponse = zChannelListResponse;

export const zCheckUserChannelFollowStatusData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
		channelId: z.string(),
	}),
});

/**
 * Successful response with follow status
 */
export const zCheckUserChannelFollowStatusResponse =
	zChannelFollowStatusResponse;

export const zGetChannelMembersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
	}),
});

/**
 * Successful response with list of members
 */
export const zGetChannelMembersResponse = z
	.object({
		result: z.object({
			members: z.array(
				z.object({
					fid: z.int().register(z.globalRegistry, {
						description: "Farcaster ID of the member",
					}),
					memberAt: z.int().register(z.globalRegistry, {
						description: "Timestamp when the user became a member",
					}),
				}),
			),
		}),
		next: z.optional(
			z.object({
				cursor: z.optional(
					z.string().register(z.globalRegistry, {
						description: "Cursor for pagination",
					}),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successful response with list of members",
	});

export const zRemoveChannelInviteData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description:
				"ID of the channel from which the user's invite is being removed",
		}),
		removeFid: z.int().register(z.globalRegistry, {
			description: "Farcaster ID of the user whose invite is being removed",
		}),
		role: z.enum(["member", "admin"]).register(z.globalRegistry, {
			description: "Role associated with the invite being removed",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful removal of invite
 */
export const zRemoveChannelInviteResponse = zSuccessResponse;

export const zGetChannelInvitesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
	}),
});

/**
 * Successful response with list of channel invites
 */
export const zGetChannelInvitesResponse = z
	.object({
		result: z.optional(
			z.object({
				invites: z.optional(
					z.array(
						z.object({
							channelId: z.string(),
							invitedFid: z.int(),
							invitedAt: z.int(),
							inviterFid: z.int(),
							role: z.enum(["member", "admin"]),
						}),
					),
				),
			}),
		),
		next: z.optional(
			z.object({
				cursor: z.optional(z.string()),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successful response with list of channel invites",
	});

export const zAcceptChannelInviteData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel for which the invite is being accepted",
		}),
		role: z.enum(["member", "admin"]).register(z.globalRegistry, {
			description: "Role that the user will have in the channel",
		}),
		accept: z.boolean().register(z.globalRegistry, {
			description: "Flag indicating whether to accept the invite",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful acceptance of invite
 */
export const zAcceptChannelInviteResponse = zSuccessResponse;

export const zInviteUserToChannelData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel to invite the user to",
		}),
		inviteFid: z.int().register(z.globalRegistry, {
			description: "Farcaster ID of the user being invited",
		}),
		role: z.enum(["member", "admin"]).register(z.globalRegistry, {
			description: "Role of the invited user within the channel",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful invite operation
 */
export const zInviteUserToChannelResponse = zSuccessResponse;

export const zGetChannelModeratedCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel to get moderation actions for",
		}),
	}),
});

/**
 * Successful response with list of moderation actions
 */
export const zGetChannelModeratedCastsResponse = z
	.object({
		result: z.object({
			moderationActions: z.array(
				z.object({
					castHash: z.string().register(z.globalRegistry, {
						description: "Hash of the moderated cast",
					}),
					channelId: z.string().register(z.globalRegistry, {
						description: "ID of the channel where the cast was moderated",
					}),
					action: z.enum(["hide"]).register(z.globalRegistry, {
						description: "Type of moderation action applied",
					}),
					moderatedAt: z.int().register(z.globalRegistry, {
						description:
							"Unix timestamp of when the moderation action was taken",
					}),
				}),
			),
		}),
		next: z.optional(
			z.object({
				cursor: z.optional(
					z.string().register(z.globalRegistry, {
						description:
							"Pagination cursor for fetching the next set of results",
					}),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successful response with list of moderation actions",
	});

export const zGetChannelRestrictedUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel to get restricted users for",
		}),
	}),
});

/**
 * Successful response with list of restricted users
 */
export const zGetChannelRestrictedUsersResponse = z
	.object({
		result: z.object({
			restrictedUsers: z.array(
				z.object({
					fid: z.int().register(z.globalRegistry, {
						description: "Farcaster ID of the restricted user",
					}),
					channelId: z.string().register(z.globalRegistry, {
						description: "ID of the channel where the user is restricted",
					}),
					restrictedAt: z.int().register(z.globalRegistry, {
						description: "Unix timestamp of when the user was restricted",
					}),
				}),
			),
		}),
		next: z.optional(
			z.object({
				cursor: z.optional(
					z.string().register(z.globalRegistry, {
						description:
							"Pagination cursor for fetching the next set of results",
					}),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successful response with list of restricted users",
	});

export const zUnbanUserFromChannelData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel from which to unban the user",
		}),
		banFid: z.int().register(z.globalRegistry, {
			description: "Farcaster ID of the user to unban",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful unban operation
 */
export const zUnbanUserFromChannelResponse = zSuccessResponse;

export const zGetChannelBannedUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel to get banned users for",
		}),
	}),
});

/**
 * Successful response with list of banned users
 */
export const zGetChannelBannedUsersResponse = z
	.object({
		result: z.object({
			bannedUsers: z.array(
				z.object({
					fid: z.int().register(z.globalRegistry, {
						description: "Farcaster ID of the banned user",
					}),
					channelId: z.string().register(z.globalRegistry, {
						description: "ID of the channel where the user is banned",
					}),
					bannedAt: z.int().register(z.globalRegistry, {
						description: "Unix timestamp of when the user was banned",
					}),
				}),
			),
		}),
		next: z.optional(
			z.object({
				cursor: z.optional(
					z.string().register(z.globalRegistry, {
						description:
							"Pagination cursor for fetching the next set of banned users",
					}),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successful response with list of banned users",
	});

export const zBanUserFromChannelData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel from which to ban the user",
		}),
		banFid: z.int().register(z.globalRegistry, {
			description: "Farcaster ID of the user to ban",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful ban operation
 */
export const zBanUserFromChannelResponse = zSuccessResponse;

export const zUnfollowChannelData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel to unfollow",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful unfollow operation
 */
export const zUnfollowChannelResponse = zSuccessResponse;

export const zFollowChannelData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel to follow",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful follow operation
 */
export const zFollowChannelResponse = zSuccessResponse;

export const zModerateCastData = z.object({
	body: z.object({
		castHash: z.string().register(z.globalRegistry, {
			description: "Hash of the cast to moderate",
		}),
		action: z.enum(["hide"]).register(z.globalRegistry, {
			description: "Type of moderation action to apply",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful moderation action
 */
export const zModerateCastResponse = zSuccessResponse;

export const zUnpinCastFromChannelData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel from which to unpin a cast",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful unpin operation
 */
export const zUnpinCastFromChannelResponse = zSuccessResponse;

export const zPinCastToChannelData = z.object({
	body: z.object({
		castHash: z.string().register(z.globalRegistry, {
			description: "Hash of the cast to pin",
		}),
		notifyChannelFollowers: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Whether to notify followers of the channel about the pin",
			}),
		),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful pin operation
 */
export const zPinCastToChannelResponse = zSuccessResponse;

export const zGetDiscoverableActionsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		list: z.string(),
		limit: z.optional(z.int()),
	}),
});

/**
 * Successful response with list of discoverable actions
 */
export const zGetDiscoverableActionsResponse = z
	.object({
		result: z.optional(
			z.object({
				actions: z.optional(z.array(zAction)),
				next: z.optional(
					z.object({
						cursor: z.optional(z.string()),
					}),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successful response with list of discoverable actions",
	});

export const zGetDiscoverableComposerActionsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		list: z.string(),
		limit: z.optional(z.int()),
	}),
});

/**
 * Successful response with list of discoverable composer actions
 */
export const zGetDiscoverableComposerActionsResponse = z
	.object({
		result: z.optional(
			z.object({
				actions: z.optional(z.array(zAction)),
				next: z.optional(
					z.object({
						cursor: z.optional(z.string()),
					}),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description:
			"Successful response with list of discoverable composer actions",
	});

export const zUnblockUserData = z.object({
	body: z.object({
		unblockFid: z.int().register(z.globalRegistry, {
			description: "Farcaster ID of the user to unblock",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful unblock operation
 */
export const zUnblockUserResponse = z
	.object({
		result: z.object({
			success: z.boolean().register(z.globalRegistry, {
				description: "Indicates whether the unblock operation was successful",
			}),
		}),
	})
	.register(z.globalRegistry, {
		description: "Successful unblock operation",
	});

export const zGetBlockedUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful response with list of blocked users
 */
export const zGetBlockedUsersResponse = z
	.object({
		result: z.object({
			blockedUsers: z.array(
				z.object({
					blockerFid: z.int().register(z.globalRegistry, {
						description: "Farcaster ID of the user who blocked",
					}),
					blockedFid: z.int().register(z.globalRegistry, {
						description: "Farcaster ID of the user who was blocked",
					}),
					createdAt: z.int().register(z.globalRegistry, {
						description: "Unix timestamp of when the user was blocked",
					}),
				}),
			),
			next: z.optional(zPaginationCursor),
		}),
	})
	.register(z.globalRegistry, {
		description: "Successful response with list of blocked users",
	});

export const zBlockUserData = z.object({
	body: z.object({
		blockFid: z.int().register(z.globalRegistry, {
			description: "Farcaster ID of the user to block",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful block operation
 */
export const zBlockUserResponse = zSuccessResponse;

export const zGetAccountVerificationsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
	}),
});

/**
 * Successful response with list of account verifications
 */
export const zGetAccountVerificationsResponse = z
	.object({
		result: z.optional(
			z.object({
				verifications: z.optional(
					z.array(
						z.object({
							fid: z.optional(z.int()),
							platform: z.optional(z.string()),
							platformId: z.optional(z.string()),
							platformUsername: z.optional(z.string()),
							verifiedAt: z.optional(z.int()),
						}),
					),
				),
			}),
		),
		next: z.optional(zPaginationCursor),
	})
	.register(z.globalRegistry, {
		description: "Successful response with list of account verifications",
	});

export const zGetCreatorRewardWinnersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			periodsAgo: z.optional(
				z.int().register(z.globalRegistry, {
					description:
						"How many periods ago to fetch the results for. 0 or undefined returns results for the most recent period.",
				}),
			),
		}),
	),
});

/**
 * Successful response with creator reward winners history
 */
export const zGetCreatorRewardWinnersResponse = z
	.object({
		result: z.optional(
			z.object({
				periodStartTimestamp: z.optional(z.coerce.bigint()),
				periodEndTimestamp: z.optional(z.coerce.bigint()),
				winners: z.optional(
					z.array(
						z.object({
							fid: z.optional(z.int()),
							score: z.optional(z.int()),
							rank: z.optional(z.int()),
							rewardCents: z.optional(z.int()),
							walletAddress: z.optional(z.string()),
						}),
					),
				),
			}),
		),
		next: z.optional(
			z.object({
				cursor: z.optional(z.string()),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successful response with creator reward winners history",
	});

export const zGetUserPrimaryAddressData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
		protocol: z.enum(["ethereum", "solana"]).register(z.globalRegistry, {
			description: "The protocol of the address to fetch.",
		}),
	}),
});

/**
 * Successful response with the user's primary address.
 */
export const zGetUserPrimaryAddressResponse = z
	.object({
		result: z.optional(
			z.object({
				address: z.optional(zVerifiedAddress),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successful response with the user's primary address.",
	});

export const zGetUserPrimaryAddressesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fids: z.string().register(z.globalRegistry, {
			description:
				"Comma-separated list of FIDs to fetch primary addresses for.",
		}),
		protocol: z.enum(["ethereum", "solana"]).register(z.globalRegistry, {
			description: "The protocol of the addresses to fetch.",
		}),
	}),
});

/**
 * Successful response with list of primary addresses.
 */
export const zGetUserPrimaryAddressesResponse = z
	.object({
		result: z.optional(
			z.object({
				addresses: z.optional(
					z.array(
						z.object({
							fid: z.int().register(z.globalRegistry, {
								description: "The Farcaster ID of the user",
							}),
							success: z.boolean().register(z.globalRegistry, {
								description: "Whether the address was successfully retrieved",
							}),
							address: z.optional(zVerifiedAddress),
						}),
					),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successful response with list of primary addresses.",
	});

export const zGetStarterPackMembersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		id: z.string().register(z.globalRegistry, {
			description:
				"Starter pack ID, as found in the public Warpcast pack URL or in the non-authed public API of starter pack metadata.\n",
		}),
	}),
});

/**
 * Successful response with list of starter pack members.
 */
export const zGetStarterPackMembersResponse = z
	.object({
		result: z.optional(
			z.object({
				members: z.optional(
					z.array(
						z.object({
							fid: z.int().register(z.globalRegistry, {
								description: "The Farcaster ID of the starter pack member",
							}),
							memberAt: z.coerce.bigint().register(z.globalRegistry, {
								description:
									"Timestamp in milliseconds when the user became a member",
							}),
						}),
					),
				),
			}),
		),
		next: z.optional(
			z.object({
				cursor: z.optional(
					z.string().register(z.globalRegistry, {
						description:
							"Pagination cursor for fetching the next set of results",
					}),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successful response with list of starter pack members.",
	});

export const zSendDirectCastData = z.object({
	body: z.object({
		recipientFid: z.int().register(z.globalRegistry, {
			description: "The Farcaster ID of the recipient.",
		}),
		message: z.string().register(z.globalRegistry, {
			description: "The direct cast message.",
		}),
		idempotencyKey: z.uuid().register(z.globalRegistry, {
			description: "A unique key to ensure idempotency.",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Direct cast sent successfully
 */
export const zSendDirectCastResponse = z
	.object({
		result: z.object({
			success: z.boolean().register(z.globalRegistry, {
				description: "Indicates if the direct cast was sent successfully",
			}),
		}),
	})
	.register(z.globalRegistry, {
		description: "Direct cast sent successfully",
	});

export const zGetUserByVerificationAddressData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		address: z.string().register(z.globalRegistry, {
			description: "Ethereum address used for user verification",
		}),
	}),
});

/**
 * User data successfully retrieved
 */
export const zGetUserByVerificationAddressResponse = zUserResponse;

export const zGetDeveloperRewardWinnersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			periodsAgo: z.optional(
				z.int().register(z.globalRegistry, {
					description:
						"How many periods ago to fetch the results for. 0 or undefined returns results for the most recent period.",
				}),
			),
		}),
	),
});

/**
 * A paginated list of developer reward winners
 */
export const zGetDeveloperRewardWinnersResponse = z
	.object({
		result: z.optional(
			z.object({
				periodStartTimestamp: z.optional(
					z.int().register(z.globalRegistry, {
						description: "Unix time in milliseconds when rewards period began",
					}),
				),
				periodEndTimestamp: z.optional(
					z.int().register(z.globalRegistry, {
						description: "Unix time in milliseconds when rewards period ended",
					}),
				),
				winners: z.optional(z.array(zWinner)),
			}),
		),
		next: z.optional(
			z.object({
				cursor: z.optional(
					z.string().register(z.globalRegistry, {
						description: "Pagination cursor for the next set of results",
					}),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "A paginated list of developer reward winners",
	});

export const zGetAppsByAuthorData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of items to return",
				}),
			)
			.default(50),
	}),
});

/**
 * A list of frames by the author
 */
export const zGetAppsByAuthorResponse = zAppsByAuthorResponse;

export const zGetDomainManifestData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		domain: z.string().register(z.globalRegistry, {
			description: "The domain to retrieve manifest information for",
		}),
	}),
});

/**
 * Successfully retrieved domain manifest
 */
export const zGetDomainManifestResponse = z
	.object({
		result: z.optional(
			z.object({
				state: z.optional(
					z.object({
						verified: z.optional(
							z.boolean().register(z.globalRegistry, {
								description: "Indicates if the domain is verified",
							}),
						),
						manifest: z.optional(
							z.string().register(z.globalRegistry, {
								description: "JSON string containing the raw manifest data",
							}),
						),
						decodedManifest: z.optional(
							z.object({
								accountAssociation: z.optional(
									z.object({
										fid: z.optional(
											z.int().register(z.globalRegistry, {
												description: "Farcaster ID associated with the domain",
											}),
										),
										key: z.optional(
											z.string().register(z.globalRegistry, {
												description: "Public key associated with the domain",
											}),
										),
										domain: z.optional(
											z.string().register(z.globalRegistry, {
												description: "The domain name",
											}),
										),
										signature: z.optional(
											z.string().register(z.globalRegistry, {
												description: "Signature proving domain ownership",
											}),
										),
									}),
								),
							}),
						),
						frameConfig: z.optional(
							z
								.object({
									name: z.optional(
										z.string().register(z.globalRegistry, {
											description: "Name of the Frame",
										}),
									),
									version: z.optional(
										z.string().register(z.globalRegistry, {
											description: "Version of the Frame",
										}),
									),
									iconUrl: z.optional(
										z.string().register(z.globalRegistry, {
											description: "URL to the Frame's icon",
										}),
									),
									homeUrl: z.optional(
										z.string().register(z.globalRegistry, {
											description: "Home URL of the Frame",
										}),
									),
									imageUrl: z.optional(
										z.string().register(z.globalRegistry, {
											description: "Image URL for the Frame",
										}),
									),
									buttonTitle: z.optional(
										z.string().register(z.globalRegistry, {
											description: "Title for the Frame's button",
										}),
									),
									splashImageUrl: z.optional(
										z.string().register(z.globalRegistry, {
											description: "URL for the splash image",
										}),
									),
									splashBackgroundColor: z.optional(
										z.string().register(z.globalRegistry, {
											description: "Background color for splash screen",
										}),
									),
									webhookUrl: z.optional(
										z.string().register(z.globalRegistry, {
											description: "Webhook URL for the Frame",
										}),
									),
								})
								.register(z.globalRegistry, {
									description: "Configuration for Farcaster Frames",
								}),
						),
						updatedAt: z.optional(
							z.int().register(z.globalRegistry, {
								description: "Timestamp of when the data was last updated",
							}),
						),
					}),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successfully retrieved domain manifest",
	});

export const zGetMetaTagsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		url: z.url().register(z.globalRegistry, {
			description: "The URL to fetch metadata from",
		}),
	}),
});

/**
 * Successfully retrieved metadata
 */
export const zGetMetaTagsResponse = z
	.object({
		viewport: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Viewport meta tag content",
			}),
		),
		"theme-color": z.optional(
			z.array(z.string()).register(z.globalRegistry, {
				description: "Theme color values",
			}),
		),
		"color-scheme": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Color scheme preference",
			}),
		),
		description: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Page description",
			}),
		),
		"apple-mobile-web-app-capable": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Apple mobile web app capability setting",
			}),
		),
		"apple-mobile-web-app-title": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Apple mobile web app title",
			}),
		),
		"apple-mobile-web-app-status-bar-style": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Apple mobile status bar style",
			}),
		),
		"og:title": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Open Graph title",
			}),
		),
		"og:description": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Open Graph description",
			}),
		),
		"og:url": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Open Graph URL",
			}),
		),
		"og:site_name": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Open Graph site name",
			}),
		),
		"og:image:alt": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Open Graph image alt text",
			}),
		),
		"og:image:type": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Open Graph image MIME type",
			}),
		),
		"og:image:width": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Open Graph image width",
			}),
		),
		"og:image:height": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Open Graph image height",
			}),
		),
		"og:image": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Open Graph image URL",
			}),
		),
		"og:type": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Open Graph content type",
			}),
		),
		"twitter:card": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Twitter card type",
			}),
		),
		"twitter:title": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Twitter card title",
			}),
		),
		"twitter:description": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Twitter card description",
			}),
		),
		"twitter:image:alt": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Twitter image alt text",
			}),
		),
		"twitter:image:type": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Twitter image MIME type",
			}),
		),
		"twitter:image:width": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Twitter image width",
			}),
		),
		"twitter:image:height": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Twitter image height",
			}),
		),
		"twitter:image": z.optional(
			z.string().register(z.globalRegistry, {
				description: "Twitter image URL",
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successfully retrieved metadata",
	});

export const zGetFarcasterJsonData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		domain: z.string().register(z.globalRegistry, {
			description: "The domain to fetch Farcaster JSON data from",
		}),
	}),
});

/**
 * Successfully retrieved Farcaster JSON data
 */
export const zGetFarcasterJsonResponse = z
	.object({
		accountAssociation: z.optional(
			z
				.object({
					header: z.optional(
						z.string().register(z.globalRegistry, {
							description:
								"Base64 encoded header containing FID, type, and key information",
						}),
					),
					payload: z.optional(
						z.string().register(z.globalRegistry, {
							description:
								"Base64 encoded payload containing domain information",
						}),
					),
					signature: z.optional(
						z.string().register(z.globalRegistry, {
							description: "Cryptographic signature for verification",
						}),
					),
				})
				.register(z.globalRegistry, {
					description: "Farcaster account association information",
				}),
		),
		frame: z.optional(
			z
				.object({
					homeUrl: z.optional(
						z.url().register(z.globalRegistry, {
							description: "URL of the frame's home page",
						}),
					),
					iconUrl: z.optional(
						z.url().register(z.globalRegistry, {
							description: "URL of the frame's icon",
						}),
					),
					name: z.optional(
						z.string().register(z.globalRegistry, {
							description: "Name of the frame",
						}),
					),
					splashBackgroundColor: z.optional(
						z.string().register(z.globalRegistry, {
							description:
								"Background color for the splash screen in hex format",
						}),
					),
					splashImageUrl: z.optional(
						z.url().register(z.globalRegistry, {
							description: "URL of the splash image",
						}),
					),
					version: z.optional(
						z.string().register(z.globalRegistry, {
							description: "Version of the frame",
						}),
					),
					webhookUrl: z.optional(
						z.url().register(z.globalRegistry, {
							description: "URL of the frame's webhook",
						}),
					),
				})
				.register(z.globalRegistry, {
					description: "Farcaster frame configuration",
				}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successfully retrieved Farcaster JSON data",
	});

export const zGetOwnedDomainsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successfully retrieved owned domains
 */
export const zGetOwnedDomainsResponse = z
	.object({
		result: z.object({
			domains: z.optional(
				z.array(z.string()).register(z.globalRegistry, {
					description: "List of domains owned by the authenticated user",
				}),
			),
		}),
	})
	.register(z.globalRegistry, {
		description: "Successfully retrieved owned domains",
	});

export const zGetApiKeysData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successfully retrieved API keys
 */
export const zGetApiKeysResponse = z
	.object({
		result: z.object({
			apiKeys: z.array(zApiKey),
		}),
	})
	.register(z.globalRegistry, {
		description: "Successfully retrieved API keys",
	});

export const zCreateApiKeyData = z.object({
	body: z.object({
		description: z.string().register(z.globalRegistry, {
			description: "User-provided description of the API key's purpose",
		}),
		expiresAt: z.coerce.bigint().register(z.globalRegistry, {
			description:
				"Timestamp when the API key should expire (in milliseconds since epoch)",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
	headers: z.optional(
		z.object({
			"idempotency-key": z.optional(
				z.uuid().register(z.globalRegistry, {
					description: "A unique key to ensure idempotency of the request",
				}),
			),
		}),
	),
});

/**
 * Successfully created API key
 */
export const zCreateApiKeyResponse = z
	.object({
		result: z.object({
			id: z.uuid().register(z.globalRegistry, {
				description: "Unique identifier for the created API key",
			}),
			secretKey: z.string().register(z.globalRegistry, {
				description:
					"The secret key value that should be used for authentication (only returned once at creation)",
			}),
		}),
	})
	.register(z.globalRegistry, {
		description: "Successfully created API key",
	});

export const zRevokeApiKeyData = z.object({
	body: z.object({
		id: z.uuid().register(z.globalRegistry, {
			description: "ID of the API key to revoke",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
	headers: z.optional(
		z.object({
			"idempotency-key": z.optional(
				z.uuid().register(z.globalRegistry, {
					description: "A unique key to ensure idempotency of the request",
				}),
			),
		}),
	),
});

/**
 * Successfully revoked the API key
 */
export const zRevokeApiKeyResponse = z
	.object({
		result: z.object({
			success: z.boolean(),
		}),
	})
	.register(z.globalRegistry, {
		description: "Successfully revoked the API key",
	});

export const zGetConnectedAccountsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().register(z.globalRegistry, {
						description: "Maximum number of connected accounts to return",
					}),
				)
				.default(15),
		}),
	),
});

/**
 * List of connected accounts
 */
export const zGetConnectedAccountsResponse = z
	.object({
		result: z.object({
			accounts: z.optional(
				z.array(
					z.object({
						connectedAccountId: z.optional(
							z.string().register(z.globalRegistry, {
								description: "Unique identifier for the connected account",
							}),
						),
						platform: z.optional(
							z
								.enum(["x", "github", "lens", "ethereum"])
								.register(z.globalRegistry, {
									description: "Social platform name (e.g., x, github, lens)",
								}),
						),
						username: z.optional(
							z.string().register(z.globalRegistry, {
								description: "Username on the connected platform",
							}),
						),
						expired: z.optional(
							z.boolean().register(z.globalRegistry, {
								description: "Whether the connection has expired",
							}),
						),
					}),
				),
			),
		}),
	})
	.register(z.globalRegistry, {
		description: "List of connected accounts",
	});

export const zGetProfileCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "Farcaster ID of the user",
		}),
		limit: z
			.optional(
				z.int().register(z.globalRegistry, {
					description: "Maximum number of casts to return",
				}),
			)
			.default(15),
		cursor: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Cursor for pagination",
			}),
		),
	}),
});

/**
 * Successfully retrieved user's casts
 */
export const zGetProfileCastsResponse = z
	.object({
		result: z.object({
			casts: z.array(zCast),
		}),
		next: z.optional(
			z.object({
				cursor: z.optional(
					z.string().register(z.globalRegistry, {
						description: "Cursor for fetching the next page of results",
					}),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successfully retrieved user's casts",
	});

export const zGetUserLikedCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description:
				"The user's fid (user id) whose liked casts are to be retrieved.",
		}),
		limit: z
			.optional(
				z.int().register(z.globalRegistry, {
					description: "Number of results to limit per request.",
				}),
			)
			.default(15),
	}),
});

/**
 * Successfully retrieved liked casts.
 */
export const zGetUserLikedCastsResponse = z
	.object({
		result: z.object({
			casts: z.optional(z.array(zCast)),
			next: z.optional(
				z.object({
					cursor: z.optional(z.string()),
				}),
			),
		}),
	})
	.register(z.globalRegistry, {
		description: "Successfully retrieved liked casts.",
	});

export const zGetMiniAppAnalyticsRollupData = z.object({
	body: z.object({
		dateRange: z.object({
			startDate: z.string().register(z.globalRegistry, {
				description:
					"Start date in format 'YYYY-MM-DD' or relative like '28daysago'",
			}),
			endDate: z.string().register(z.globalRegistry, {
				description: "End date in format 'YYYY-MM-DD' or relative like 'today'",
			}),
		}),
		measures: z
			.array(
				z.enum([
					"miniapp_opens",
					"miniapp_transactions",
					"miniapp_users_w_transaction",
					"miniapp_users_w_open",
					"miniapp_users_w_notifications_enabled",
					"miniapp_users_w_notifications_disabled",
					"miniapp_users_w_app_favorited",
					"miniapp_users_w_app_unfavorited",
				]),
			)
			.register(z.globalRegistry, {
				description: "Analytics metrics to retrieve",
			}),
		restrictions: z
			.array(
				z.object({
					dimension: z.string().register(z.globalRegistry, {
						description: "Dimension to filter on",
					}),
					values: z.array(z.string()).register(z.globalRegistry, {
						description: "Values to filter the dimension by",
					}),
				}),
			)
			.register(z.globalRegistry, {
				description: "Filtering restrictions for the data",
			}),
		breakdownSettings: z.optional(
			z
				.object({
					dimensions: z.optional(
						z.array(z.string()).register(z.globalRegistry, {
							description: "Dimensions to break down the data by",
						}),
					),
					order: z.optional(
						z.enum(["asc", "desc"]).register(z.globalRegistry, {
							description: "Sort order for the breakdown results",
						}),
					),
				})
				.register(z.globalRegistry, {
					description: "Configuration for data breakdown",
				}),
		),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful analytics rollup retrieval
 */
export const zGetMiniAppAnalyticsRollupResponse = z
	.object({
		result: z.optional(
			z.object({
				rollup: z.optional(
					z.object({
						dateRange: z.optional(
							z.object({
								startDate: z.optional(z.iso.date()),
								endDate: z.optional(z.iso.date()),
							}),
						),
						restrictions: z.optional(
							z.array(
								z.object({
									dimension: z.optional(z.string()),
									values: z.optional(z.array(z.string())),
								}),
							),
						),
						totals: z.optional(
							z
								.array(
									z.object({
										name: z.optional(z.string()),
										value: z.optional(z.int()),
									}),
								)
								.register(z.globalRegistry, {
									description: "Aggregate metric totals",
								}),
						),
						breakdown: z.optional(
							z
								.array(
									z.object({
										slices: z.optional(
											z.array(
												z.object({
													dimension: z.optional(z.string()),
													values: z.optional(z.array(z.string())),
												}),
											),
										),
										measures: z.optional(
											z.array(
												z.object({
													name: z.optional(z.string()),
													value: z.optional(z.int()),
												}),
											),
										),
									}),
								)
								.register(z.globalRegistry, {
									description: "Metrics broken down by dimensions",
								}),
						),
					}),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successful analytics rollup retrieval",
	});

export const zInspectMiniAppUrlData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		url: z.url().register(z.globalRegistry, {
			description: "The URL of the Mini App to inspect",
		}),
	}),
});

/**
 * Successful inspection of the Mini App URL
 */
export const zInspectMiniAppUrlResponse = z
	.object({
		result: z.optional(
			z.object({
				facts: z.optional(
					z.object({
						url: z.optional(
							z.url().register(z.globalRegistry, {
								description: "The URL that was inspected",
							}),
						),
						statusCode: z.optional(
							z.int().register(z.globalRegistry, {
								description: "HTTP status code returned by the URL",
							}),
						),
						miniAppEmbedPresent: z.optional(
							z.boolean().register(z.globalRegistry, {
								description:
									"Indicates if the Mini App embedding code is present",
							}),
						),
						miniAppManifestPresent: z.optional(
							z.boolean().register(z.globalRegistry, {
								description: "Indicates if the Mini App manifest is present",
							}),
						),
						miniAppEmbedValid: z.optional(
							z.boolean().register(z.globalRegistry, {
								description:
									"Indicates if the Mini App embedding code is valid",
							}),
						),
						miniAppManifestValid: z.optional(
							z.boolean().register(z.globalRegistry, {
								description: "Indicates if the Mini App manifest is valid",
							}),
						),
					}),
				),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Successful inspection of the Mini App URL",
	});

export const zInspectImageUrlData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		url: z.url().register(z.globalRegistry, {
			description: "The URL of the image to inspect",
		}),
	}),
});

/**
 * Image inspection successful
 */
export const zInspectImageUrlResponse = z
	.object({
		result: z.object({
			facts: z.optional(
				z.object({
					url: z.optional(
						z.string().register(z.globalRegistry, {
							description: "The URL of the inspected image",
						}),
					),
					statusCode: z.optional(
						z.int().register(z.globalRegistry, {
							description: "HTTP status code of the response",
						}),
					),
					cacheHeader: z.optional(
						z.string().register(z.globalRegistry, {
							description: "The cache header used by the image",
						}),
					),
					cacheAge: z.optional(
						z.int().register(z.globalRegistry, {
							description: "Cache age in seconds",
						}),
					),
					imageSizeBytes: z.optional(
						z.int().register(z.globalRegistry, {
							description: "Size of the image in bytes",
						}),
					),
					imageLoadTimeMs: z.optional(
						z.int().register(z.globalRegistry, {
							description: "Time taken to load the image in milliseconds",
						}),
					),
				}),
			),
		}),
	})
	.register(z.globalRegistry, {
		description: "Image inspection successful",
	});

export const zExportMiniAppUserDataData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		domain: z.string().register(z.globalRegistry, {
			description: "The domain name of the mini app to export user data for",
		}),
	}),
});

/**
 * Successfully retrieved mini app user data
 */
export const zExportMiniAppUserDataResponse = z
	.object({
		result: z.object({
			users: z.optional(
				z.array(
					z.object({
						fid: z.int().register(z.globalRegistry, {
							description: "Farcaster ID of the user",
						}),
						notificationToken: z.optional(z.union([z.string(), z.null()])),
						added: z.boolean().register(z.globalRegistry, {
							description:
								"Whether the user has been added/registered with the mini app",
						}),
					}),
				),
			),
		}),
	})
	.register(z.globalRegistry, {
		description: "Successfully retrieved mini app user data",
	});
