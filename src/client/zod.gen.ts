// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

export const zProfilePicture = z.object({
	url: z.optional(z.url()),
	verified: z.optional(z.boolean()),
});

export const zBio = z.object({
	text: z.optional(z.string()),
	mentions: z.optional(z.array(z.unknown())),
	channelMentions: z.optional(z.array(z.unknown())),
});

export const zLocation = z.object({
	placeId: z.optional(z.string()),
	description: z.optional(z.string()),
});

export const zProfile = z.object({
	bio: z.optional(zBio),
	location: z.optional(zLocation),
});

export const zViewerContext = z.object({
	following: z.optional(z.boolean()),
	followedBy: z.optional(z.boolean()),
	enableNotifications: z.optional(z.boolean()),
	canSendDirectCasts: z.optional(z.boolean()),
	hasUploadedInboxKeys: z.optional(z.boolean()),
});

export const zUser = z.object({
	fid: z.int(),
	username: z.string(),
	displayName: z.string(),
	pfp: z.optional(zProfilePicture),
	profile: z.optional(zProfile),
	followerCount: z.optional(z.int()),
	followingCount: z.optional(z.int()),
	viewerContext: z.optional(zViewerContext),
});

export const zOnboardingState = z.object({
	id: z.optional(z.uuid()),
	email: z.optional(z.email()),
	user: z.optional(zUser),
	hasOnboarding: z.optional(z.boolean()),
	hasConfirmedEmail: z.optional(z.boolean()),
	handledConnectAddress: z.optional(z.boolean()),
	canRegisterUsername: z.optional(z.boolean()),
	needsRegistrationPayment: z.optional(z.boolean()),
	hasFid: z.optional(z.boolean()),
	hasFname: z.optional(z.boolean()),
	hasDelegatedSigner: z.optional(z.boolean()),
	hasSetupProfile: z.optional(z.boolean()),
	hasCompletedRegistration: z.optional(z.boolean()),
	hasStorage: z.optional(z.boolean()),
	handledPushNotificationsNudge: z.optional(z.boolean()),
	handledContactsNudge: z.optional(z.boolean()),
	handledInterestsNudge: z.optional(z.boolean()),
	hasValidPaidInvite: z.optional(z.boolean()),
	hasWarpcastWalletAddress: z.optional(z.boolean()),
	hasPhone: z.optional(z.boolean()),
	needsPhone: z.optional(z.boolean()),
	sponsoredRegisterEligible: z.optional(z.boolean()),
	geoRestricted: z.optional(z.boolean()),
});

export const zOnboardingStateResponse = z.object({
	result: z.optional(
		z.object({
			state: z.optional(zOnboardingState),
		}),
	),
});

export const zErrorResponse = z.object({
	errors: z.optional(
		z.array(
			z.object({
				message: z.optional(
					z.string().register(z.globalRegistry, {
						description: "Error message describing the issue",
					}),
				),
			}),
		),
	),
});

export const zUserWithExtras = zUser.and(
	z.object({
		connectedAccounts: z.optional(z.array(z.unknown())),
	}),
);

export const zUserExtras = z.object({
	fid: z.optional(z.int()),
	custodyAddress: z.optional(z.string()),
	ethWallets: z.optional(z.array(z.string())),
	solanaWallets: z.optional(z.array(z.string())),
	walletLabels: z.optional(
		z.array(
			z.object({
				address: z.optional(z.string()),
				labels: z.optional(z.array(z.string())),
			}),
		),
	),
	v2: z.optional(z.boolean()),
	publicSpamLabel: z.optional(z.string()),
});

export const zUserByFidResponse = z.object({
	result: z.optional(
		z.object({
			user: z.optional(zUserWithExtras),
			collectionsOwned: z.optional(z.array(z.unknown())),
			extras: z.optional(zUserExtras),
		}),
	),
});

/**
 * Represents a single validation error
 */
export const zValidationError = z
	.object({
		instancePath: z.string().register(z.globalRegistry, {
			description:
				"JSON Pointer to the part of the request that failed validation",
		}),
		schemaPath: z.string().register(z.globalRegistry, {
			description: "JSON Schema path that was violated",
		}),
		keyword: z.string().register(z.globalRegistry, {
			description: "The JSON Schema keyword that failed",
		}),
		params: z.optional(
			z.record(z.string(), z.unknown()).register(z.globalRegistry, {
				description: "Additional parameters describing the validation error",
			}),
		),
		message: z.string().register(z.globalRegistry, {
			description: "Human-readable error description",
		}),
	})
	.register(z.globalRegistry, {
		description: "Represents a single validation error",
	});

/**
 * Standard 400 Bad Request error response
 */
export const zBadRequestError = z
	.object({
		errors: z.array(zValidationError).register(z.globalRegistry, {
			description: "Array of validation errors",
		}),
	})
	.register(z.globalRegistry, {
		description: "Standard 400 Bad Request error response",
	});

export const zDirectCastMessageReaction = z.object({
	reaction: z.string().register(z.globalRegistry, {
		description: "Emoji used for the reaction",
	}),
	count: z.int().gte(1).register(z.globalRegistry, {
		description: "Number of users who reacted with this emoji",
	}),
	emoji: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Emoji used for the reaction (legacy field)",
		}),
	),
	userFids: z.optional(
		z.array(z.int()).register(z.globalRegistry, {
			description: "List of Farcaster IDs who reacted",
		}),
	),
});

export const zDirectCastMessageViewerContext = z.object({
	isLastReadMessage: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether this is the last read message",
		}),
	),
	focused: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the message is focused",
		}),
	),
	reactions: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "User's reactions to this message",
		}),
	),
});

export const zDirectCastMessageMetadata = z.object({
	casts: z.optional(
		z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
			description: "Cast metadata if message contains cast references",
		}),
	),
	urls: z.optional(
		z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
			description: "URL metadata if message contains links",
		}),
	),
	medias: z.optional(
		z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
			description: "Media metadata if message contains media",
		}),
	),
});

export const zDirectCastMessageMention = z.object({
	user: zUser,
	textIndex: z.int().register(z.globalRegistry, {
		description: "Starting index of the mention in the message text",
	}),
	length: z.int().register(z.globalRegistry, {
		description: "Length of the mention text",
	}),
});

export const zDirectCastMessage = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation this message belongs to",
	}),
	senderFid: z.int().register(z.globalRegistry, {
		description: "Farcaster ID of the message sender",
	}),
	messageId: z.string().register(z.globalRegistry, {
		description: "Unique identifier for the message",
	}),
	serverTimestamp: z.coerce.bigint().register(z.globalRegistry, {
		description: "Server timestamp when message was sent (Unix milliseconds)",
	}),
	type: z
		.enum([
			"text",
			"image",
			"reaction",
			"link",
			"group_membership_addition",
			"pin_message",
			"message_ttl_change",
		])
		.register(z.globalRegistry, {
			description: "Type of the message",
		}),
	message: z.string().register(z.globalRegistry, {
		description: "Content of the message",
	}),
	hasMention: z.boolean().register(z.globalRegistry, {
		description: "Whether the message contains mentions",
	}),
	reactions: z.array(zDirectCastMessageReaction).register(z.globalRegistry, {
		description: "List of reactions to the message",
	}),
	isPinned: z.boolean().register(z.globalRegistry, {
		description: "Whether the message is pinned",
	}),
	isDeleted: z.boolean().register(z.globalRegistry, {
		description: "Whether the message is deleted",
	}),
	senderContext: zUser,
	viewerContext: z.optional(zDirectCastMessageViewerContext),
	get inReplyTo(): z.ZodOptional {
		return z.optional(
			z.lazy((): any => {
				return zDirectCastMessage;
			}),
		);
	},
	metadata: z.optional(zDirectCastMessageMetadata),
	actionTargetUserContext: z.optional(zUser),
	isProgrammatic: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the message was sent programmatically",
		}),
	),
	mentions: z.optional(
		z.array(zDirectCastMessageMention).register(z.globalRegistry, {
			description: "List of mentions in the message",
		}),
	),
});

export const zDirectCastConversationViewerContext = z.object({
	access: z.optional(
		z.enum(["read-write", "read-only"]).register(z.globalRegistry, {
			description: "Access level for the conversation",
		}),
	),
	category: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Category of the conversation",
		}),
	),
	archived: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation is archived",
		}),
	),
	lastReadAt: z.optional(
		z.coerce.bigint().register(z.globalRegistry, {
			description: "Timestamp of last read (Unix milliseconds)",
		}),
	),
	muted: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation is muted",
		}),
	),
	manuallyMarkedUnread: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation is manually marked as unread",
		}),
	),
	pinned: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation is pinned",
		}),
	),
	unreadCount: z.optional(
		z.int().gte(0).register(z.globalRegistry, {
			description: "Number of unread messages",
		}),
	),
	unreadMentionsCount: z.optional(
		z.int().gte(0).register(z.globalRegistry, {
			description: "Number of unread mentions",
		}),
	),
	counterParty: z.optional(zUser),
	tag: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Tag associated with the conversation",
		}),
	),
});

export const zDirectCastConversation = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "Unique identifier for the conversation",
	}),
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Name of the conversation (for group conversations)",
		}),
	),
	description: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Description of the conversation",
		}),
	),
	photoUrl: z.optional(
		z.url().register(z.globalRegistry, {
			description: "URL of the conversation photo",
		}),
	),
	adminFids: z.array(z.int()).register(z.globalRegistry, {
		description: "List of admin Farcaster IDs",
	}),
	removedFids: z.optional(
		z.array(z.int()).register(z.globalRegistry, {
			description: "List of removed Farcaster IDs",
		}),
	),
	participants: z.optional(
		z.array(zUser).register(z.globalRegistry, {
			description: "List of conversation participants",
		}),
	),
	lastReadTime: z.coerce.bigint().register(z.globalRegistry, {
		description: "Timestamp of last read time (Unix milliseconds)",
	}),
	selfLastReadTime: z.optional(
		z.coerce.bigint().register(z.globalRegistry, {
			description: "Timestamp of viewer's last read time (Unix milliseconds)",
		}),
	),
	pinnedMessages: z.optional(
		z.array(zDirectCastMessage).register(z.globalRegistry, {
			description: "List of pinned messages in the conversation",
		}),
	),
	hasPinnedMessages: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation has pinned messages",
		}),
	),
	isGroup: z.boolean().register(z.globalRegistry, {
		description: "Whether this is a group conversation",
	}),
	isCollectionTokenGated: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation is collection token gated",
		}),
	),
	activeParticipantsCount: z.optional(
		z.int().gte(0).register(z.globalRegistry, {
			description: "Number of active participants in the conversation",
		}),
	),
	messageTTLDays: z.optional(
		z.union([
			z.int().gte(0).register(z.globalRegistry, {
				description: "Number of days until message expires",
			}),
			z.enum(["Infinity"]).register(z.globalRegistry, {
				description: "Messages never expire",
			}),
		]),
	),
	createdAt: z.coerce.bigint().register(z.globalRegistry, {
		description: "Timestamp when conversation was created (Unix milliseconds)",
	}),
	unreadCount: z.optional(
		z.int().gte(0).register(z.globalRegistry, {
			description: "Number of unread messages",
		}),
	),
	muted: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation is muted",
		}),
	),
	hasMention: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the conversation has mentions",
		}),
	),
	lastMessage: z.optional(zDirectCastMessage),
	viewerContext: zDirectCastConversationViewerContext,
});

export const zDirectCastInboxResult = z.object({
	hasArchived: z.boolean().register(z.globalRegistry, {
		description: "Whether user has archived conversations",
	}),
	hasUnreadRequests: z.boolean().register(z.globalRegistry, {
		description: "Whether user has unread conversation requests",
	}),
	requestsCount: z.int().gte(0).register(z.globalRegistry, {
		description: "Total number of conversation requests",
	}),
	conversations: z.array(zDirectCastConversation),
});

export const zPaginationCursor = z.object({
	cursor: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Base64 encoded cursor for pagination",
		}),
	),
});

export const zDirectCastInboxResponse = z.object({
	result: zDirectCastInboxResult,
	next: z.optional(zPaginationCursor),
});

export const zCastAction = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	octicon: z.optional(z.string()),
	actionUrl: z.optional(z.string()),
	action: z.optional(
		z.object({
			actionType: z.optional(z.string()),
			postUrl: z.optional(z.string()),
		}),
	),
});

export const zUserAppContextResponse = z.object({
	result: z.optional(
		z.object({
			context: z.optional(
				z.object({
					canAddLinks: z.optional(z.boolean()),
					showConnectedApps: z.optional(z.boolean()),
					signerRequestsEnabled: z.optional(z.boolean()),
					prompts: z.optional(z.array(z.unknown())),
					adminForChannelKeys: z.optional(z.array(z.string())),
					modOfChannelKeys: z.optional(z.array(z.string())),
					memberOfChannelKeys: z.optional(z.array(z.string())),
					canEditAllChannels: z.optional(z.boolean()),
					canUploadVideo: z.optional(z.boolean()),
					statsigEnabled: z.optional(z.boolean()),
					shouldPromptForPushNotifications: z.optional(z.boolean()),
					shouldPromptForUserFollowsSyncContacts: z.optional(z.boolean()),
					castActions: z.optional(z.array(zCastAction)),
					canAddCastAction: z.optional(z.boolean()),
					enabledCastAction: z.optional(zCastAction),
					notificationTabsV2: z.optional(
						z.array(
							z.object({
								id: z.optional(z.string()),
								name: z.optional(z.string()),
							}),
						),
					),
					enabledVideoAutoplay: z.optional(z.boolean()),
					regularCastByteLimit: z.optional(z.int()),
					longCastByteLimit: z.optional(z.int()),
					newUserStatus: z.optional(z.record(z.string(), z.unknown())),
					country: z.optional(z.string()),
					higherClientEventSamplingRateEnabled: z.optional(z.boolean()),
				}),
			),
		}),
	),
});

export const zUserPreferencesResponse = z.object({
	result: z.optional(
		z.object({
			preferences: z.optional(z.record(z.string(), z.unknown())),
		}),
	),
});

export const zChannel = z.object({
	type: z.optional(z.string()),
	key: z.optional(z.string()),
	name: z.optional(z.string()),
	imageUrl: z.optional(z.string()),
	fastImageUrl: z.optional(z.string()),
	feeds: z.optional(
		z.array(
			z.object({
				name: z.optional(z.string()),
				type: z.optional(z.string()),
			}),
		),
	),
	description: z.optional(z.string()),
	followerCount: z.optional(z.int()),
	memberCount: z.optional(z.int()),
	showCastSourceLabels: z.optional(z.boolean()),
	showCastTags: z.optional(z.boolean()),
	sectionRank: z.optional(z.int()),
	subscribable: z.optional(z.boolean()),
	publicCasting: z.optional(z.boolean()),
	inviteCode: z.optional(z.string()),
	headerImageUrl: z.optional(z.string()),
	headerAction: z.optional(
		z.object({
			title: z.optional(z.string()),
			target: z.optional(z.string()),
		}),
	),
	headerActionMetadata: z.optional(z.record(z.string(), z.unknown())),
	viewerContext: z.optional(
		z.object({
			following: z.optional(z.boolean()),
			isMember: z.optional(z.boolean()),
			hasUnseenItems: z.optional(z.boolean()),
			favoritePosition: z.optional(z.int()),
			activityRank: z.optional(z.int()),
			canCast: z.optional(z.boolean()),
		}),
	),
});

export const zHighlightedChannelsResponse = z.object({
	result: z.optional(
		z.object({
			channels: z.optional(z.array(zChannel)),
			viewerContext: z.optional(
				z.object({
					defaultFeed: z.optional(z.string()),
				}),
			),
		}),
	),
});

export const zImageEmbed = z.object({
	type: z.optional(z.enum(["image"])),
	url: z.optional(z.string()),
	sourceUrl: z.optional(z.string()),
	media: z.optional(
		z.object({
			version: z.optional(z.string()),
			width: z.optional(z.int()),
			height: z.optional(z.int()),
			staticRaster: z.optional(z.string()),
			mimeType: z.optional(z.string()),
		}),
	),
	alt: z.optional(z.string()),
});

export const zUrlEmbed = z.object({
	type: z.enum(["url"]),
	openGraph: z.object({
		url: z.string(),
		sourceUrl: z.optional(z.string()),
		title: z.optional(z.string()),
		description: z.optional(z.string()),
		domain: z.optional(z.string()),
		image: z.optional(z.string()),
		useLargeImage: z.optional(z.boolean()),
	}),
});

export const zVideoEmbed = z.object({
	type: z.optional(z.enum(["video"])),
});

export const zRecaster = z.object({
	fid: z.optional(z.int()),
	username: z.optional(z.string()),
	displayName: z.optional(z.string()),
	recastHash: z.optional(z.string()),
});

export const zCast = z.object({
	hash: z.string().register(z.globalRegistry, {
		description: "Unique hash identifier for the cast",
	}),
	threadHash: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Hash identifier for the thread this cast belongs to",
		}),
	),
	parentHash: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Hash identifier of the parent cast (if this is a reply)",
		}),
	),
	parentSource: z.optional(
		z.object({
			type: z.optional(z.enum(["url"])),
			url: z.optional(z.string()),
		}),
	),
	author: zUser,
	text: z.string().register(z.globalRegistry, {
		description: "The text content of the cast",
	}),
	timestamp: z.coerce.bigint().register(z.globalRegistry, {
		description: "Unix timestamp in milliseconds",
	}),
	mentions: z.optional(z.array(zUser)),
	embeds: z.optional(
		z.object({
			images: z.optional(z.array(zImageEmbed)),
			urls: z.optional(z.array(zUrlEmbed)),
			videos: z.optional(z.array(zVideoEmbed)),
			unknowns: z.optional(z.array(z.record(z.string(), z.unknown()))),
			processedCastText: z.optional(z.string()),
			groupInvites: z.optional(z.array(z.record(z.string(), z.unknown()))),
		}),
	),
	replies: z.object({
		count: z.int(),
	}),
	reactions: z.object({
		count: z.int(),
	}),
	recasts: z.object({
		count: z.int(),
		recasters: z.optional(z.array(zRecaster)),
	}),
	watches: z.object({
		count: z.int(),
	}),
	recast: z.optional(z.boolean()),
	tags: z.optional(
		z.array(
			z.object({
				type: z.optional(z.string()),
				id: z.optional(z.string()),
				name: z.optional(z.string()),
				imageUrl: z.optional(z.string()),
			}),
		),
	),
	quoteCount: z.optional(z.int()),
	combinedRecastCount: z.optional(z.int()),
	channel: z.optional(
		z.object({
			key: z.optional(z.string()),
			name: z.optional(z.string()),
			imageUrl: z.optional(z.string()),
			authorContext: z.optional(
				z.object({
					role: z.optional(z.string()),
					restricted: z.optional(z.boolean()),
					banned: z.optional(z.boolean()),
				}),
			),
			authorRole: z.optional(z.string()),
		}),
	),
	viewerContext: z.optional(
		z.object({
			reacted: z.optional(z.boolean()),
			recast: z.optional(z.boolean()),
			bookmarked: z.optional(z.boolean()),
		}),
	),
});

export const zFeedItemsResponse = z.object({
	result: z.object({
		items: z.array(
			z.object({
				id: z.string(),
				timestamp: z.int(),
				cast: zCast,
				otherParticipants: z.optional(z.array(zUser)),
			}),
		),
		latestMainCastTimestamp: z.optional(z.int()),
		feedTopSeenAtTimestamp: z.optional(z.int()),
		replaceFeed: z.boolean(),
	}),
});

export const zGenericResponse = z.object({
	result: z.record(z.string(), z.unknown()),
});

export const zUserResponse = zGenericResponse.and(
	z.object({
		result: z.object({
			user: z.optional(zUserWithExtras),
			collectionsOwned: z.optional(z.array(z.record(z.string(), z.unknown()))),
			extras: z.optional(zUserExtras),
		}),
	}),
);

export const zPaginatedResponse = z.object({
	result: z.record(z.string(), z.unknown()),
	next: z.optional(zPaginationCursor),
});

export const zSuggestedUsersResponse = zPaginatedResponse.and(
	z.object({
		result: z.optional(
			z.object({
				users: z.optional(z.array(z.record(z.string(), z.unknown()))),
			}),
		),
	}),
);

export const zFavoriteFramesResponse = z.object({
	result: z.object({
		frames: z.array(z.record(z.string(), z.unknown())),
	}),
});

export const zChannelStreaksResponse = z.object({
	result: z.record(z.string(), z.unknown()),
});

export const zUnseenCountsResponse = z.object({
	result: z.object({
		notificationsCount: z.optional(z.int()),
		notificationTabs: z.optional(
			z.array(
				z.object({
					tab: z.string(),
					unseenCount: z.int(),
				}),
			),
		),
		inboxCount: z.optional(z.int()),
		channelFeeds: z.optional(
			z.array(
				z.object({
					channelKey: z.string(),
					feedType: z.string(),
					hasNewItems: z.boolean(),
				}),
			),
		),
		warpTransactionCount: z.optional(z.int()),
	}),
});

export const zUserThreadCastsResponse = z.object({
	result: z.object({
		casts: z.array(z.record(z.string(), z.unknown())),
	}),
});

export const zChannelFollowersYouKnowResponse = z.object({
	result: z.object({
		users: z.array(z.record(z.string(), z.unknown())),
		totalCount: z.int(),
	}),
});

export const zSuccessResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				success: z.boolean().register(z.globalRegistry, {
					description: "Whether the operation was successful",
				}),
			}),
		),
	}),
);

export const zNotificationsResponse = z.object({
	result: z.object({
		notifications: z.optional(z.array(z.record(z.string(), z.unknown()))),
	}),
});

export const zDirectCastConversationResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				conversation: zDirectCastConversation,
			}),
		),
	}),
);

export const zDirectCastConversationCategorizationRequest = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation to categorize",
	}),
	category: z.string().register(z.globalRegistry, {
		description: "Category to assign to the conversation",
	}),
});

export const zDirectCastConversationMessagesResponse = zPaginatedResponse.and(
	z.object({
		result: z.optional(
			z.object({
				messages: z.array(zDirectCastMessage),
			}),
		),
	}),
);

export const zDirectCastConversationMessageTtlRequest = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation to set message TTL for",
	}),
	ttl: z.int().register(z.globalRegistry, {
		description: "Time to live for messages in days",
	}),
});

export const zDirectCastConversationNotificationsRequest = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation to update notification settings for",
	}),
	muted: z.boolean().register(z.globalRegistry, {
		description: "Whether to mute notifications for this conversation",
	}),
});

export const zDirectCastSendRequest = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation to send the message to",
	}),
	recipientFids: z.array(z.int()).register(z.globalRegistry, {
		description: "Array of Farcaster IDs of message recipients",
	}),
	messageId: z.string().register(z.globalRegistry, {
		description: "Unique identifier for the message",
	}),
	type: z
		.enum(["text", "image", "reaction", "link"])
		.register(z.globalRegistry, {
			description: "Type of the message",
		}),
	message: z.string().register(z.globalRegistry, {
		description: "Content of the message",
	}),
	inReplyToId: z.optional(
		z.string().register(z.globalRegistry, {
			description: "ID of the message this is replying to (optional)",
		}),
	),
});

export const zDirectCastManuallyMarkUnreadRequest = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation to mark as unread",
	}),
});

export const zDirectCastMessageReactionRequest = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation containing the message",
	}),
	messageId: z.string().register(z.globalRegistry, {
		description: "ID of the message to react to",
	}),
	reaction: z.string().register(z.globalRegistry, {
		description: "Emoji reaction to add or remove",
	}),
});

export const zDirectCastPinConversationRequest = z.object({
	conversationId: z.string().register(z.globalRegistry, {
		description: "ID of the conversation to pin",
	}),
});

export const zDiscoverChannelsResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				channels: z.optional(z.array(z.record(z.string(), z.unknown()))),
			}),
		),
	}),
);

export const zInvitesAvailableResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				allocatedInvitesCount: z.int().register(z.globalRegistry, {
					description: "Total number of invites allocated to the user",
				}),
				availableInvitesCount: z.int().register(z.globalRegistry, {
					description: "Number of invites currently available to send",
				}),
			}),
		),
	}),
);

export const zSponsoredInvitesResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				invites: z.optional(z.array(z.record(z.string(), z.unknown()))),
			}),
		),
	}),
);

export const zRewardsLeaderboardResponse = z.object({
	result: z.object({
		leaderboard: z.object({
			type: z.string(),
			users: z.array(
				z.object({
					user: z.optional(z.record(z.string(), z.unknown())),
					score: z.optional(z.int()),
					rank: z.optional(z.int()),
				}),
			),
		}),
	}),
});

export const zRewardsScoresResponse = z.object({
	result: z.object({
		scores: z.array(
			z.object({
				type: z.optional(z.string()),
				user: z.optional(z.record(z.string(), z.unknown())),
				allTimeScore: z.optional(z.int()),
				currentPeriodScore: z.optional(z.int()),
				previousPeriodScore: z.optional(z.int()),
			}),
		),
	}),
});

export const zRewardsMetadataResponse = z.object({
	result: z.object({
		metadata: z.optional(
			z.object({
				type: z.optional(z.string()),
				lastUpdateTimestamp: z.optional(z.int()),
				currentPeriodStartTimestamp: z.optional(z.int()),
				currentPeriodEndTimestamp: z.optional(z.int()),
				tiers: z.optional(z.array(z.record(z.string(), z.unknown()))),
				proportionalPayout: z.optional(
					z.object({
						numWinners: z.optional(z.int()),
						totalRewardCents: z.optional(z.int()),
					}),
				),
			}),
		),
	}),
});

export const zBookmarkedCast = z.record(z.string(), z.unknown());

export const zBookmarkedCastsResponse = z.object({
	result: z.object({
		bookmarks: z.optional(z.array(zBookmarkedCast)),
	}),
});

export const zStarterPack = z.object({
	id: z.string().register(z.globalRegistry, {
		description: "Unique identifier for the starter pack",
	}),
	creator: z.optional(zUser),
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Display name of the starter pack",
		}),
	),
	description: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Description of the starter pack",
		}),
	),
	openGraphImageUrl: z.optional(
		z.url().register(z.globalRegistry, {
			description: "URL for OG image preview",
		}),
	),
	itemCount: z.optional(
		z.int().register(z.globalRegistry, {
			description: "Number of items in the starter pack",
		}),
	),
	items: z.optional(
		z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
			description: "Items contained in the starter pack",
		}),
	),
	labels: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "Labels/tags for the starter pack",
		}),
	),
});

export const zStarterPacksResponse = z.object({
	result: z.object({
		starterPacks: z.array(zStarterPack),
	}),
});

export const zStarterPackResponse = z.object({
	result: z.object({
		starterPack: zStarterPack,
	}),
});

export const zStarterPackUpdateRequest = z.object({
	id: z.string().register(z.globalRegistry, {
		description: "Unique identifier for the starter pack to update",
	}),
	name: z.string().register(z.globalRegistry, {
		description: "Display name of the starter pack",
	}),
	description: z.string().register(z.globalRegistry, {
		description: "Description of the starter pack",
	}),
	fids: z.array(z.int()).register(z.globalRegistry, {
		description: "List of FIDs included in the starter pack",
	}),
	labels: z.array(z.string()).register(z.globalRegistry, {
		description: "Labels/tags for the starter pack",
	}),
});

export const zStarterPackUsersResponse = z.object({
	result: z.object({
		users: z.array(zUser),
	}),
});

export const zChannelResponse = z.object({
	result: z.object({
		channel: z.optional(zChannel),
	}),
});

export const zChannelUsersResponse = z.object({
	result: z.object({
		users: z.optional(z.array(zUser)),
	}),
});

export const zUsersResponse = z.object({
	result: z.object({
		users: z.array(zUser),
	}),
});

export const zUsersWithCountResponse = z.object({
	result: z.object({
		users: z.array(zUser),
		totalCount: z.int(),
	}),
});

export const zFrameApp = z.record(z.string(), z.unknown());

export const zFrameAppsResponse = z.object({
	result: z.optional(
		z.object({
			frames: z.optional(z.array(zFrameApp)),
		}),
	),
});

/**
 * Context information for the viewer
 */
export const zMiniAppViewerContext = z
	.record(z.string(), z.unknown())
	.register(z.globalRegistry, {
		description: "Context information for the viewer",
	});

export const zMiniApp = z.object({
	domain: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The domain of the mini app",
		}),
	),
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The name of the mini app",
		}),
	),
	iconUrl: z.optional(
		z.string().register(z.globalRegistry, {
			description: "URL to the mini app's icon",
		}),
	),
	homeUrl: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The home URL of the mini app",
		}),
	),
	author: z.optional(zUser),
	supportsNotifications: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the mini app supports notifications",
		}),
	),
	id: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Unique identifier for the mini app",
		}),
	),
	shortId: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Short identifier for the mini app",
		}),
	),
	imageUrl: z.optional(
		z.string().register(z.globalRegistry, {
			description: "URL to the mini app's main image",
		}),
	),
	buttonTitle: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Title for the action button",
		}),
	),
	splashImageUrl: z.optional(
		z.string().register(z.globalRegistry, {
			description: "URL to the splash screen image",
		}),
	),
	splashBackgroundColor: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Background color for the splash screen",
		}),
	),
	castShareUrl: z.optional(
		z.string().register(z.globalRegistry, {
			description: "URL for sharing casts",
		}),
	),
	subtitle: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Subtitle of the mini app",
		}),
	),
	description: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Description of the mini app",
		}),
	),
	tagline: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Tagline of the mini app",
		}),
	),
	heroImageUrl: z.optional(
		z.string().register(z.globalRegistry, {
			description: "URL to the hero image",
		}),
	),
	primaryCategory: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Primary category of the mini app",
		}),
	),
	tags: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "Tags associated with the mini app",
		}),
	),
	screenshotUrls: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "URLs to screenshot images",
		}),
	),
	noindex: z.optional(
		z.boolean().register(z.globalRegistry, {
			description: "Whether the mini app should be indexed",
		}),
	),
	ogTitle: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Open Graph title",
		}),
	),
	ogDescription: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Open Graph description",
		}),
	),
	ogImageUrl: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Open Graph image URL",
		}),
	),
	requiredCapabilities: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "Required capabilities for the mini app",
		}),
	),
	requiredChains: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "Required blockchain chains",
		}),
	),
	viewerContext: z.optional(zMiniAppViewerContext),
});

export const zRankedMiniApp = z.object({
	rank: z.optional(
		z.int().register(z.globalRegistry, {
			description: "Current rank of the mini app",
		}),
	),
	miniApp: z.optional(zMiniApp),
	rank72hChange: z.optional(
		z.int().register(z.globalRegistry, {
			description: "Change in rank over the last 72 hours",
		}),
	),
});

export const zTopMiniAppsResponse = z.object({
	result: z.optional(
		z.object({
			miniApps: z.optional(z.array(zRankedMiniApp)),
			next: z.optional(zPaginationCursor),
		}),
	),
});

export const zVerifiedAddress = z.object({
	fid: z.optional(z.int()),
	address: z.optional(z.string()),
	timestamp: z.optional(z.int()),
	version: z.optional(z.string()),
	protocol: z.optional(z.string()),
	isPrimary: z.optional(z.boolean()),
	labels: z.optional(z.array(z.string())),
});

export const zMutedKeywordProperties = z.object({
	channels: z.optional(z.boolean()),
	frames: z.optional(z.boolean()),
	notifications: z.optional(z.boolean()),
});

export const zMutedKeyword = z.object({
	keyword: z.string(),
	properties: zMutedKeywordProperties,
});

export const zMutedKeywordsResponse = z.object({
	success: z.boolean(),
	result: z.object({
		keywords: z.array(z.string()),
		mutedKeywords: z.array(zMutedKeyword),
	}),
});

export const zCastHashResponse = z.object({
	result: z.object({
		castHash: z.optional(z.string()),
	}),
});

export const zAttachEmbedsResponse = z.object({
	result: z.record(z.string(), z.unknown()),
});

export const zCastRecastersResponse = z.object({
	result: z.object({
		users: z.optional(z.array(zUser)),
	}),
});

export const zCastQuote = z.object({
	hash: z.optional(z.string()),
	threadHash: z.optional(z.string()),
	parentSource: z.optional(
		z.object({
			type: z.optional(z.string()),
			url: z.optional(z.string()),
		}),
	),
	author: z.optional(zUser),
	text: z.optional(z.string()),
	timestamp: z.optional(z.int()),
});

export const zCastQuotesResponse = z.object({
	result: z.object({
		quotes: z.optional(z.array(zCastQuote)),
	}),
});

export const zUserResponseUserResponse = z.object({
	result: z.object({
		user: zUser,
	}),
});

export const zSearchChannelsResponse = z.object({
	result: z.optional(
		z.object({
			channels: z.optional(z.array(zChannel)),
		}),
	),
});

export const zDraftsResponse = z.object({
	result: z.optional(
		z.object({
			drafts: z.optional(z.array(z.unknown())),
		}),
	),
});

export const zDraftCast = z.object({
	text: z.optional(z.string()),
	embeds: z.optional(z.array(z.unknown())),
});

export const zDraft = z.object({
	draftId: z.optional(z.string()),
	casts: z.optional(z.array(zDraftCast)),
});

export const zDraftCreatedResponse = z.object({
	result: z.optional(
		z.object({
			draft: z.optional(zDraft),
		}),
	),
});

export const zCastCreatedResponse = z.object({
	result: z.optional(
		z.object({
			cast: z.optional(zCast),
		}),
	),
});

export const zRawChannel = z.object({
	id: z.optional(z.string()),
	url: z.optional(z.string()),
	name: z.optional(z.string()),
	description: z.optional(z.string()),
	descriptionMentions: z.optional(z.array(z.int())),
	descriptionMentionsPositions: z.optional(z.array(z.int())),
	imageUrl: z.optional(z.string()),
	headerImageUrl: z.optional(z.string()),
	leadFid: z.optional(z.int()),
	moderatorFids: z.optional(z.array(z.int())),
	createdAt: z.optional(z.int()),
	followerCount: z.optional(z.int()),
	memberCount: z.optional(z.int()),
	pinnedCastHash: z.optional(z.string()),
	publicCasting: z.optional(z.boolean()),
	externalLink: z.optional(
		z.object({
			title: z.optional(z.string()),
			url: z.optional(z.string()),
		}),
	),
});

export const zChannelListResponse = z.object({
	result: z.optional(
		z.object({
			channels: z.optional(z.array(zRawChannel)),
		}),
	),
});

export const zRawChannelResponse = z.object({
	result: z.optional(
		z.object({
			channel: z.optional(zRawChannel),
		}),
	),
});

export const zChannelFollower = z.object({
	fid: z.optional(z.int()),
	followedAt: z.optional(z.int()),
});

export const zChannelFollowersResponse = zPaginatedResponse.and(
	z.object({
		result: z.optional(
			z.object({
				users: z.optional(z.array(zChannelFollower)),
			}),
		),
	}),
);

export const zChannelFollowStatus = z.object({
	following: z.optional(z.boolean()),
	followedAt: z.optional(z.int()),
});

export const zChannelFollowStatusResponse = z.object({
	result: z.optional(zChannelFollowStatus),
});

export const zAction = z.object({
	name: z.optional(z.string()),
	icon: z.optional(z.string()),
	description: z.optional(z.string()),
	aboutUrl: z.optional(z.url()),
	imageUrl: z.optional(z.url()),
	actionUrl: z.optional(z.url()),
	action: z.optional(
		z.object({
			actionType: z.optional(z.enum(["post", "get", "put", "delete"])),
			postUrl: z.optional(z.url()),
		}),
	),
});

export const zWinner = z.object({
	fid: z.optional(
		z.int().register(z.globalRegistry, {
			description: "The fid of the winner",
		}),
	),
	domain: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The domain of the winner",
		}),
	),
	frameName: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The name of the frame (mini app)",
		}),
	),
	score: z.optional(
		z.int().register(z.globalRegistry, {
			description: "The score of the winner",
		}),
	),
	rank: z.optional(
		z.int().register(z.globalRegistry, {
			description: "The rank of the winner",
		}),
	),
	rewardCents: z.optional(
		z.int().register(z.globalRegistry, {
			description: "The reward amount in cents",
		}),
	),
	walletAddress: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The wallet address of the winner (optional)",
		}),
	),
});

export const zFrame = z.object({
	domain: z.optional(z.string()),
	name: z.optional(z.string()),
	iconUrl: z.optional(z.string()),
	homeUrl: z.optional(z.string()),
	splashImageUrl: z.optional(z.string()),
	splashBackgroundColor: z.optional(z.string()),
	buttonTitle: z.optional(z.union([z.string(), z.null()])),
	imageUrl: z.optional(z.union([z.string(), z.null()])),
	supportsNotifications: z.optional(z.boolean()),
	viewerContext: z.optional(z.record(z.string(), z.unknown())),
	author: z.optional(zUser),
});

export const zAppsByAuthorResponse = z.object({
	result: z.optional(
		z.object({
			frames: z.optional(z.array(zFrame)),
		}),
	),
});

export const zApiKey = z.object({
	id: z.uuid().register(z.globalRegistry, {
		description: "Unique identifier for the API key",
	}),
	createdAt: z.coerce.bigint().register(z.globalRegistry, {
		description:
			"Timestamp when the API key was created (in milliseconds since epoch)",
	}),
	expiresAt: z.coerce.bigint().register(z.globalRegistry, {
		description:
			"Timestamp when the API key expires (in milliseconds since epoch)",
	}),
	revokedAt: z.optional(z.union([z.string(), z.null()])),
	tag: z.string().register(z.globalRegistry, {
		description: "Short identifier tag for the API key",
	}),
	description: z.string().register(z.globalRegistry, {
		description: "User-provided description of the API key's purpose",
	}),
});

/**
 * Generic 400 Bad Request error for simple error messages
 */
export const zGenericBadRequestError = z
	.object({
		errors: z.array(
			z.object({
				message: z.string().register(z.globalRegistry, {
					description: "Error message describing the issue",
				}),
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Generic 400 Bad Request error for simple error messages",
	});

export const zDirectCastSendResponse = zSuccessResponse;

export const zDirectCastConversationCategorizationResponse = zSuccessResponse;

export const zDirectCastConversationNotificationsResponse = zSuccessResponse;

export const zDirectCastConversationMessageTtlResponse = zSuccessResponse;

export const zDirectCastMessageReactionResponse = zSuccessResponse;

/**
 * The user's FID (Farcaster ID)
 */
export const zFidParam = z.int().register(z.globalRegistry, {
	description: "The user's FID (Farcaster ID)",
});

/**
 * Maximum number of items to return
 */
export const zLimitParam = z
	.int()
	.gte(1)
	.lte(100)
	.register(z.globalRegistry, {
		description: "Maximum number of items to return",
	})
	.default(50);

/**
 * Base64 encoded cursor for pagination
 */
export const zCursorParam = z.string().register(z.globalRegistry, {
	description: "Base64 encoded cursor for pagination",
});

export const zGetUserOnboardingStateData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetUserByFidData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
	}),
});

export const zGetDirectCastInboxData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
			category: z.optional(
				z.enum(["default", "requests", "spam"]).register(z.globalRegistry, {
					description: "Category of conversations to retrieve",
				}),
			),
			filter: z.optional(
				z.enum(["unread", "group", "1-1"]).register(z.globalRegistry, {
					description: "Filter for conversations (e.g., unread, all)",
				}),
			),
			cursor: z.optional(
				z.string().register(z.globalRegistry, {
					description: "Base64 encoded cursor from previous response",
				}),
			),
		}),
	),
});

export const zGetUserAppContextData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetUserPreferencesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetHighlightedChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetFeedItemsData = z.object({
	body: z.object({
		feedKey: z.string().register(z.globalRegistry, {
			description: "Identifier for the specific feed",
		}),
		feedType: z.string().register(z.globalRegistry, {
			description: "Type of feed to retrieve",
		}),
		olderThan: z.optional(
			z.coerce.bigint().register(z.globalRegistry, {
				description: "Only return items older than this timestamp (ms)",
			}),
		),
		latestMainCastTimestamp: z.optional(
			z.coerce.bigint().register(z.globalRegistry, {
				description: "Latest main cast timestamp used for pagination (ms)",
			}),
		),
		excludeItemIdPrefixes: z.optional(
			z.array(z.string()).register(z.globalRegistry, {
				description: "List of item ID prefixes to exclude from the response",
			}),
		),
		castViewEvents: z.optional(
			z
				.array(
					z.object({
						ts: z.optional(
							z.coerce.bigint().register(z.globalRegistry, {
								description: "Event timestamp in ms",
							}),
						),
						hash: z.optional(
							z.string().register(z.globalRegistry, {
								description: "Cast hash",
							}),
						),
						on: z.optional(
							z.string().register(z.globalRegistry, {
								description: "Context of the view event",
							}),
						),
						channel: z.optional(
							z.string().register(z.globalRegistry, {
								description: "Channel key",
							}),
						),
						feed: z.optional(
							z.string().register(z.globalRegistry, {
								description: "Feed type where event occurred",
							}),
						),
					}),
				)
				.register(z.globalRegistry, {
					description: "View events for casts (can be empty array)",
				}),
		),
		updateState: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Whether to update the feed state",
			}),
		),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetUserData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
	}),
});

export const zGetUserFollowingChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			forComposer: z.optional(
				z.boolean().register(z.globalRegistry, {
					description:
						"Whether results are intended for the composer interface",
				}),
			),
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
		}),
	),
});

export const zGetSuggestedUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
			randomized: z.optional(z.boolean()),
		}),
	),
});

export const zGetUserFavoriteFramesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
		}),
	),
});

export const zGetUserByUsernameData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		username: z.string().register(z.globalRegistry, {
			description: "The username to look up",
		}),
	}),
});

export const zGetChannelStreaksForUserData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
	}),
});

export const zGetUnseenCountsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetUserThreadCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of items to return",
				}),
			)
			.default(50),
		castHashPrefix: z.string().register(z.globalRegistry, {
			description: "The hash prefix of the cast",
		}),
		username: z.string().register(z.globalRegistry, {
			description: "The username of the user",
		}),
	}),
});

export const zGetChannelFollowersYouKnowData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelKey: z.string(),
		limit: z.optional(z.int()),
	}),
});

export const zMarkAllNotificationsReadData = z.object({
	body: z.record(z.string(), z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetNotificationsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		tab: z
			.enum(["all", "follows", "reactions", "mentions", "replies"])
			.register(z.globalRegistry, {
				description: "Notification tab type",
			}),
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Number of notifications to return",
				}),
			)
			.default(15),
	}),
});

export const zSetLastCheckedTimestampData = z.object({
	body: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
		description: "Empty object for now",
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetDirectCastConversationData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		conversationId: z.string().register(z.globalRegistry, {
			description:
				'Conversation ID. Format depends on conversation type:\n- 1:1 conversations: "fid1-fid2" (e.g., "123-456")\n- Group conversations: Hash format (e.g., "a1b2c3d4e5f6...")\n',
		}),
	}),
});

export const zCategorizeDirectCastConversationData = z.object({
	body: zDirectCastConversationCategorizationRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetDirectCastConversationMessagesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		conversationId: z.string().register(z.globalRegistry, {
			description:
				'Conversation ID. Format depends on conversation type:\n- 1:1 conversations: "fid1-fid2" (e.g., "123-456")\n- Group conversations: Hash format (e.g., "c9e139dcbc9423cf")\n',
		}),
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of messages to return",
				}),
			)
			.default(50),
	}),
});

export const zSetDirectCastConversationMessageTtlData = z.object({
	body: zDirectCastConversationMessageTtlRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zUpdateDirectCastConversationNotificationsData = z.object({
	body: zDirectCastConversationNotificationsRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetDirectCastConversationRecentMessagesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		conversationId: z.string().register(z.globalRegistry, {
			description:
				'Conversation ID. Format depends on conversation type:\n- 1:1 conversations: "fid1-fid2" (e.g., "123-456")\n- Group conversations: Hash format (e.g., "c9e139dcbc9423cf")\n',
		}),
	}),
});

export const zSendDirectCastMessageData = z.object({
	body: zDirectCastSendRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zDirectCastManuallyMarkUnreadData = z.object({
	body: zDirectCastManuallyMarkUnreadRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zRemoveDirectCastMessageReactionData = z.object({
	body: zDirectCastMessageReactionRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zAddDirectCastMessageReactionData = z.object({
	body: zDirectCastMessageReactionRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zUnpinDirectCastConversationData = z.object({
	body: zDirectCastPinConversationRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zPinDirectCastConversationData = z.object({
	body: zDirectCastPinConversationRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zDiscoverChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of channels to retrieve",
					}),
				)
				.default(15),
		}),
	),
});

export const zGetAvailableInvitesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetSponsoredInvitesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetOrCreateReferralCodeData = z.object({
	body: z.record(z.string(), z.unknown()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetRewardsLeaderboardData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of items to return",
				}),
			)
			.default(50),
		rewardsType: z.enum(["invite"]),
		cursor: z.optional(z.string()),
	}),
});

export const zGetUserRewardsScoresData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
		rewardsType: z.enum(["invite"]),
	}),
});

export const zGetRewardsMetadataData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		rewardsType: z.enum(["invite"]),
	}),
});

export const zGetXpRewardsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(
				z.int().register(z.globalRegistry, {
					description: "Maximum number of rewards to return",
				}),
			),
		}),
	),
});

export const zGetXpClaimableSummaryData = z.object({
	body: z.record(z.string(), z.unknown()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetBookmarkedCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
		}),
	),
});

export const zGetUserStarterPacksData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()).default(15),
	}),
});

export const zGetSuggestedStarterPacksData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int()).default(15),
		}),
	),
});

export const zGetStarterPackData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		id: z.string(),
	}),
});

export const zUpdateStarterPackData = z.object({
	body: zStarterPackUpdateRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
	headers: z.optional(
		z.object({
			"idempotency-key": z.optional(
				z.string().register(z.globalRegistry, {
					description:
						"Idempotency key to safely retry the request without performing the operation multiple times.",
				}),
			),
		}),
	),
});

export const zGetStarterPackUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of items to return",
				}),
			)
			.default(50),
		id: z.string(),
	}),
});

export const zGetChannelData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		key: z.string(),
	}),
});

export const zGetChannelUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of items to return",
				}),
			)
			.default(50),
		channelKey: z.string(),
		filterToMembers: z.optional(z.boolean()),
		query: z.optional(z.string()),
	}),
});

export const zGetFollowingData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()),
	}),
});

export const zGetFollowersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()),
	}),
});

export const zGetMutualFollowersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()),
	}),
});

export const zGetTopFrameAppsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
			cursor: z.optional(z.string()),
		}),
	),
});

export const zGetTopMiniAppsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
			cursor: z.optional(
				z.string().register(z.globalRegistry, {
					description: "Base64 encoded cursor for pagination",
				}),
			),
		}),
	),
});

export const zGetVerificationsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of items to return",
				}),
			)
			.default(50),
	}),
});

export const zGetMutedKeywordsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zMuteKeywordData = z.object({
	body: z.object({
		keyword: z.optional(z.string()),
		properties: z.optional(zMutedKeywordProperties),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zUnmuteKeywordData = z.object({
	body: z.object({
		keyword: z.optional(z.string()),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zUnlikeCastData = z.object({
	body: z.object({
		castHash: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetCastLikesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		castHash: z.string(),
		limit: z.optional(z.int()).default(15),
	}),
});

export const zLikeCastData = z.object({
	body: z.object({
		castHash: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zUndoRecastData = z.object({
	body: z.object({
		castHash: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zRecastCastData = z.object({
	body: z.object({
		castHash: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zAttachEmbedsData = z.object({
	body: z.object({
		text: z.optional(z.string()),
		embeds: z.optional(z.array(z.url())),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetCastRecastersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of items to return",
				}),
			)
			.default(50),
		castHash: z.string(),
	}),
});

export const zGetCastQuotesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		castHash: z.string(),
		limit: z.optional(z.int()).default(15),
	}),
});

export const zGetCurrentUserData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zSearchChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().gte(1).lte(100).register(z.globalRegistry, {
						description: "Maximum number of items to return",
					}),
				)
				.default(50),
			q: z.optional(z.string()),
			prioritizeFollowed: z.optional(z.boolean()).default(true),
			forComposer: z.optional(z.boolean()).default(false),
		}),
	),
});

export const zGetDraftCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int()).default(15),
		}),
	),
});

export const zCreateDraftCastsData = z.object({
	body: z.object({
		caststorm: z.optional(
			z.object({
				casts: z.optional(z.array(zDraftCast)),
			}),
		),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
	headers: z.object({
		"idempotency-key": z.uuid(),
	}),
});

export const zDeleteDraftCastData = z.object({
	body: z.object({
		draftId: z.optional(z.string()),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zDeleteCastData = z.object({
	body: z.object({
		castHash: z.optional(z.string()),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetCastsByFidData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The FID (Farcaster ID) of the user whose casts to retrieve",
		}),
		limit: z
			.optional(
				z.int().register(z.globalRegistry, {
					description: "Maximum number of casts to return",
				}),
			)
			.default(15),
	}),
});

export const zCreateCastData = z.object({
	body: z.object({
		text: z.string(),
		embeds: z.optional(z.array(z.unknown())),
		channelKey: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Optional channel to post the cast to",
			}),
		),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetAllChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetChannelDetailsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
	}),
});

export const zGetChannelFollowersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
		cursor: z.optional(z.string()),
	}),
});

export const zGetUserFollowedChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
	}),
});

export const zCheckUserChannelFollowStatusData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
		channelId: z.string(),
	}),
});

export const zGetChannelMembersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
	}),
});

export const zRemoveChannelInviteData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description:
				"ID of the channel from which the user's invite is being removed",
		}),
		removeFid: z.int().register(z.globalRegistry, {
			description: "Farcaster ID of the user whose invite is being removed",
		}),
		role: z.enum(["member", "admin"]).register(z.globalRegistry, {
			description: "Role associated with the invite being removed",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetChannelInvitesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
	}),
});

export const zAcceptChannelInviteData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel for which the invite is being accepted",
		}),
		role: z.enum(["member", "admin"]).register(z.globalRegistry, {
			description: "Role that the user will have in the channel",
		}),
		accept: z.boolean().register(z.globalRegistry, {
			description: "Flag indicating whether to accept the invite",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zInviteUserToChannelData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel to invite the user to",
		}),
		inviteFid: z.int().register(z.globalRegistry, {
			description: "Farcaster ID of the user being invited",
		}),
		role: z.enum(["member", "admin"]).register(z.globalRegistry, {
			description: "Role of the invited user within the channel",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetChannelModeratedCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel to get moderation actions for",
		}),
	}),
});

export const zGetChannelRestrictedUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel to get restricted users for",
		}),
	}),
});

export const zUnbanUserFromChannelData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel from which to unban the user",
		}),
		banFid: z.int().register(z.globalRegistry, {
			description: "Farcaster ID of the user to unban",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetChannelBannedUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel to get banned users for",
		}),
	}),
});

export const zBanUserFromChannelData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel from which to ban the user",
		}),
		banFid: z.int().register(z.globalRegistry, {
			description: "Farcaster ID of the user to ban",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zUnfollowChannelData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel to unfollow",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zFollowChannelData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel to follow",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zModerateCastData = z.object({
	body: z.object({
		castHash: z.string().register(z.globalRegistry, {
			description: "Hash of the cast to moderate",
		}),
		action: z.enum(["hide"]).register(z.globalRegistry, {
			description: "Type of moderation action to apply",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zUnpinCastFromChannelData = z.object({
	body: z.object({
		channelId: z.string().register(z.globalRegistry, {
			description: "ID of the channel from which to unpin a cast",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zPinCastToChannelData = z.object({
	body: z.object({
		castHash: z.string().register(z.globalRegistry, {
			description: "Hash of the cast to pin",
		}),
		notifyChannelFollowers: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Whether to notify followers of the channel about the pin",
			}),
		),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetDiscoverableActionsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		list: z.string(),
		limit: z.optional(z.int()),
	}),
});

export const zGetDiscoverableComposerActionsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		list: z.string(),
		limit: z.optional(z.int()),
	}),
});

export const zUnblockUserData = z.object({
	body: z.object({
		unblockFid: z.int().register(z.globalRegistry, {
			description: "Farcaster ID of the user to unblock",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetBlockedUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zBlockUserData = z.object({
	body: z.object({
		blockFid: z.int().register(z.globalRegistry, {
			description: "Farcaster ID of the user to block",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetAccountVerificationsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
	}),
});

export const zGetCreatorRewardWinnersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			periodsAgo: z.optional(
				z.int().register(z.globalRegistry, {
					description:
						"How many periods ago to fetch the results for. 0 or undefined returns results for the most recent period.",
				}),
			),
		}),
	),
});

export const zGetUserPrimaryAddressData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
		protocol: z.enum(["ethereum", "solana"]).register(z.globalRegistry, {
			description: "The protocol of the address to fetch.",
		}),
	}),
});

export const zGetUserPrimaryAddressesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fids: z.string().register(z.globalRegistry, {
			description:
				"Comma-separated list of FIDs to fetch primary addresses for.",
		}),
		protocol: z.enum(["ethereum", "solana"]).register(z.globalRegistry, {
			description: "The protocol of the addresses to fetch.",
		}),
	}),
});

export const zGetStarterPackMembersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		id: z.string().register(z.globalRegistry, {
			description:
				"Starter pack ID, as found in the public Warpcast pack URL or in the non-authed public API of starter pack metadata.\n",
		}),
	}),
});

export const zSendDirectCastData = z.object({
	body: z.object({
		recipientFid: z.int().register(z.globalRegistry, {
			description: "The Farcaster ID of the recipient.",
		}),
		message: z.string().register(z.globalRegistry, {
			description: "The direct cast message.",
		}),
		idempotencyKey: z.uuid().register(z.globalRegistry, {
			description: "A unique key to ensure idempotency.",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetUserByVerificationAddressData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		address: z.string().register(z.globalRegistry, {
			description: "Ethereum address used for user verification",
		}),
	}),
});

export const zGetDeveloperRewardWinnersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			periodsAgo: z.optional(
				z.int().register(z.globalRegistry, {
					description:
						"How many periods ago to fetch the results for. 0 or undefined returns results for the most recent period.",
				}),
			),
		}),
	),
});

export const zGetAppsByAuthorData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "The user's FID (Farcaster ID)",
		}),
		limit: z
			.optional(
				z.int().gte(1).lte(100).register(z.globalRegistry, {
					description: "Maximum number of items to return",
				}),
			)
			.default(50),
	}),
});

export const zGetDomainManifestData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		domain: z.string().register(z.globalRegistry, {
			description: "The domain to retrieve manifest information for",
		}),
	}),
});

export const zGetTrendingTopicsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetMetaTagsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		url: z.url().register(z.globalRegistry, {
			description: "The URL to fetch metadata from",
		}),
	}),
});

export const zGetFarcasterJsonData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		domain: z.string().register(z.globalRegistry, {
			description: "The domain to fetch Farcaster JSON data from",
		}),
	}),
});

export const zGetOwnedDomainsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetManagedAppsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(
				z.int().register(z.globalRegistry, {
					description: "Maximum number of apps to return",
				}),
			),
		}),
	),
});

export const zGetApiKeysData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zCreateApiKeyData = z.object({
	body: z.object({
		description: z.string().register(z.globalRegistry, {
			description: "User-provided description of the API key's purpose",
		}),
		expiresAt: z.coerce.bigint().register(z.globalRegistry, {
			description:
				"Timestamp when the API key should expire (in milliseconds since epoch)",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
	headers: z.optional(
		z.object({
			"idempotency-key": z.optional(
				z.uuid().register(z.globalRegistry, {
					description: "A unique key to ensure idempotency of the request",
				}),
			),
		}),
	),
});

export const zRevokeApiKeyData = z.object({
	body: z.object({
		id: z.uuid().register(z.globalRegistry, {
			description: "ID of the API key to revoke",
		}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
	headers: z.optional(
		z.object({
			"idempotency-key": z.optional(
				z.uuid().register(z.globalRegistry, {
					description: "A unique key to ensure idempotency of the request",
				}),
			),
		}),
	),
});

export const zGetConnectedAccountsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z
				.optional(
					z.int().register(z.globalRegistry, {
						description: "Maximum number of connected accounts to return",
					}),
				)
				.default(15),
		}),
	),
});

export const zGetProfileCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description: "Farcaster ID of the user",
		}),
		limit: z
			.optional(
				z.int().register(z.globalRegistry, {
					description: "Maximum number of casts to return",
				}),
			)
			.default(15),
		cursor: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Cursor for pagination",
			}),
		),
	}),
});

export const zGetUserLikedCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int().register(z.globalRegistry, {
			description:
				"The user's fid (user id) whose liked casts are to be retrieved.",
		}),
		limit: z
			.optional(
				z.int().register(z.globalRegistry, {
					description: "Number of results to limit per request.",
				}),
			)
			.default(15),
	}),
});

export const zSubmitAnalyticsEventsData = z.object({
	body: z.object({
		events: z
			.array(
				z.object({
					type: z.string().register(z.globalRegistry, {
						description: "Type of the analytics event",
					}),
					data: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
						description: "Event-specific data",
					}),
					ts: z.coerce.bigint().register(z.globalRegistry, {
						description:
							"Unix timestamp in milliseconds when the event occurred",
					}),
				}),
			)
			.register(z.globalRegistry, {
				description: "Array of analytics events to submit",
			}),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zGetMiniAppAnalyticsRollupData = z.object({
	body: z.object({
		dateRange: z.object({
			startDate: z.string().register(z.globalRegistry, {
				description:
					"Start date in format 'YYYY-MM-DD' or relative like '28daysago'",
			}),
			endDate: z.string().register(z.globalRegistry, {
				description: "End date in format 'YYYY-MM-DD' or relative like 'today'",
			}),
		}),
		measures: z
			.array(
				z.enum([
					"miniapp_opens",
					"miniapp_transactions",
					"miniapp_users_w_transaction",
					"miniapp_users_w_open",
					"miniapp_users_w_notifications_enabled",
					"miniapp_users_w_notifications_disabled",
					"miniapp_users_w_app_favorited",
					"miniapp_users_w_app_unfavorited",
				]),
			)
			.register(z.globalRegistry, {
				description: "Analytics metrics to retrieve",
			}),
		restrictions: z
			.array(
				z.object({
					dimension: z.string().register(z.globalRegistry, {
						description: "Dimension to filter on",
					}),
					values: z.array(z.string()).register(z.globalRegistry, {
						description: "Values to filter the dimension by",
					}),
				}),
			)
			.register(z.globalRegistry, {
				description: "Filtering restrictions for the data",
			}),
		breakdownSettings: z.optional(
			z
				.object({
					dimensions: z.optional(
						z.array(z.string()).register(z.globalRegistry, {
							description: "Dimensions to break down the data by",
						}),
					),
					order: z.optional(
						z.enum(["asc", "desc"]).register(z.globalRegistry, {
							description: "Sort order for the breakdown results",
						}),
					),
				})
				.register(z.globalRegistry, {
					description: "Configuration for data breakdown",
				}),
		),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

export const zInspectMiniAppUrlData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		url: z.url().register(z.globalRegistry, {
			description: "The URL of the Mini App to inspect",
		}),
	}),
});

export const zInspectImageUrlData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		url: z.url().register(z.globalRegistry, {
			description: "The URL of the image to inspect",
		}),
	}),
});

export const zExportMiniAppUserDataData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		domain: z.string().register(z.globalRegistry, {
			description: "The domain name of the mini app to export user data for",
		}),
	}),
});
