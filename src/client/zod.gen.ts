// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

export const zProfilePicture = z.object({
	url: z.optional(z.url()),
	verified: z.optional(z.boolean()),
});

export const zBio = z.object({
	text: z.optional(z.string()),
	mentions: z.optional(z.array(z.unknown())),
	channelMentions: z.optional(z.array(z.unknown())),
});

export const zLocation = z.object({
	placeId: z.optional(z.string()),
	description: z.optional(z.string()),
});

export const zProfile = z.object({
	bio: z.optional(zBio),
	location: z.optional(zLocation),
});

export const zViewerContext = z.object({
	following: z.optional(z.boolean()),
	followedBy: z.optional(z.boolean()),
	enableNotifications: z.optional(z.boolean()),
	canSendDirectCasts: z.optional(z.boolean()),
	hasUploadedInboxKeys: z.optional(z.boolean()),
});

export const zUser = z.object({
	fid: z.optional(z.int()),
	username: z.optional(z.string()),
	displayName: z.optional(z.string()),
	pfp: z.optional(zProfilePicture),
	profile: z.optional(zProfile),
	followerCount: z.optional(z.int()),
	followingCount: z.optional(z.int()),
	viewerContext: z.optional(zViewerContext),
});

export const zOnboardingState = z.object({
	id: z.optional(z.uuid()),
	email: z.optional(z.email()),
	user: z.optional(zUser),
	hasOnboarding: z.optional(z.boolean()),
	hasConfirmedEmail: z.optional(z.boolean()),
	handledConnectAddress: z.optional(z.boolean()),
	canRegisterUsername: z.optional(z.boolean()),
	needsRegistrationPayment: z.optional(z.boolean()),
	hasFid: z.optional(z.boolean()),
	hasFname: z.optional(z.boolean()),
	hasDelegatedSigner: z.optional(z.boolean()),
	hasSetupProfile: z.optional(z.boolean()),
	hasCompletedRegistration: z.optional(z.boolean()),
	hasStorage: z.optional(z.boolean()),
	handledPushNotificationsNudge: z.optional(z.boolean()),
	handledContactsNudge: z.optional(z.boolean()),
	handledInterestsNudge: z.optional(z.boolean()),
	hasValidPaidInvite: z.optional(z.boolean()),
	hasWarpcastWalletAddress: z.optional(z.boolean()),
	hasPhone: z.optional(z.boolean()),
	needsPhone: z.optional(z.boolean()),
	sponsoredRegisterEligible: z.optional(z.boolean()),
	geoRestricted: z.optional(z.boolean()),
});

export const zOnboardingStateResponse = z.object({
	result: z.optional(
		z.object({
			state: z.optional(zOnboardingState),
		}),
	),
});

export const zErrorResponse = z.object({
	errors: z.optional(
		z.array(
			z.object({
				message: z.optional(z.string()),
			}),
		),
	),
});

export const zUserWithExtras = zUser.and(
	z.object({
		connectedAccounts: z.optional(z.array(z.unknown())),
	}),
);

export const zUserExtras = z.object({
	fid: z.optional(z.int()),
	custodyAddress: z.optional(z.string()),
	ethWallets: z.optional(z.array(z.string())),
	solanaWallets: z.optional(z.array(z.string())),
	walletLabels: z.optional(
		z.array(
			z.object({
				address: z.optional(z.string()),
				labels: z.optional(z.array(z.string())),
			}),
		),
	),
	v2: z.optional(z.boolean()),
	publicSpamLabel: z.optional(z.string()),
});

export const zUserByFidResponse = z.object({
	result: z.optional(
		z.object({
			user: z.optional(zUserWithExtras),
			collectionsOwned: z.optional(z.array(z.unknown())),
			extras: z.optional(zUserExtras),
		}),
	),
});

/**
 * Represents a single validation error
 */
export const zValidationError = z.object({
	instancePath: z.string(),
	schemaPath: z.string(),
	keyword: z.string(),
	params: z.optional(z.object({})),
	message: z.string(),
});

/**
 * Standard 400 Bad Request error response
 */
export const zBadRequestError = z.object({
	errors: z.array(zValidationError),
});

export const zDirectCastMessageReaction = z.object({
	reaction: z.string(),
	count: z.int().gte(1),
	emoji: z.optional(z.string()),
	userFids: z.optional(z.array(z.int())),
});

export const zDirectCastMessageViewerContext = z.object({
	isLastReadMessage: z.optional(z.boolean()),
	focused: z.optional(z.boolean()),
	reactions: z.optional(z.array(z.string())),
});

export const zDirectCastMessageMetadata = z.object({
	casts: z.optional(z.array(z.object({}))),
	urls: z.optional(z.array(z.object({}))),
	medias: z.optional(z.array(z.object({}))),
});

export const zDirectCastMessageMention = z.object({
	user: zUser,
	textIndex: z.int(),
	length: z.int(),
});

export const zDirectCastMessage = z.object({
	conversationId: z.string(),
	senderFid: z.int(),
	messageId: z.string(),
	serverTimestamp: z.coerce.bigint(),
	type: z.enum([
		"text",
		"image",
		"reaction",
		"link",
		"group_membership_addition",
		"pin_message",
		"message_ttl_change",
	]),
	message: z.string(),
	hasMention: z.boolean(),
	reactions: z.array(zDirectCastMessageReaction),
	isPinned: z.boolean(),
	isDeleted: z.boolean(),
	senderContext: zUser,
	viewerContext: z.optional(zDirectCastMessageViewerContext),
	get inReplyTo(): z.ZodOptional {
		return z.optional(
			z.lazy((): any => {
				return zDirectCastMessage;
			}),
		);
	},
	metadata: z.optional(zDirectCastMessageMetadata),
	actionTargetUserContext: z.optional(zUser),
	isProgrammatic: z.optional(z.boolean()),
	mentions: z.optional(z.array(zDirectCastMessageMention)),
});

export const zDirectCastConversationViewerContext = z.object({
	access: z.optional(z.enum(["read-write", "read-only"])),
	category: z.optional(z.string()),
	archived: z.optional(z.boolean()),
	lastReadAt: z.optional(z.coerce.bigint()),
	muted: z.optional(z.boolean()),
	manuallyMarkedUnread: z.optional(z.boolean()),
	pinned: z.optional(z.boolean()),
	unreadCount: z.optional(z.int().gte(0)),
	unreadMentionsCount: z.optional(z.int().gte(0)),
	counterParty: z.optional(zUser),
	tag: z.optional(z.string()),
});

export const zDirectCastConversation = z.object({
	conversationId: z.string(),
	name: z.optional(z.string()),
	description: z.optional(z.string()),
	photoUrl: z.optional(z.url()),
	adminFids: z.array(z.int()),
	removedFids: z.optional(z.array(z.int())),
	participants: z.optional(z.array(zUser)),
	lastReadTime: z.coerce.bigint(),
	selfLastReadTime: z.optional(z.coerce.bigint()),
	pinnedMessages: z.optional(z.array(zDirectCastMessage)),
	hasPinnedMessages: z.optional(z.boolean()),
	isGroup: z.boolean(),
	isCollectionTokenGated: z.optional(z.boolean()),
	activeParticipantsCount: z.optional(z.int().gte(0)),
	messageTTLDays: z.optional(z.union([z.int().gte(0), z.enum(["Infinity"])])),
	createdAt: z.coerce.bigint(),
	unreadCount: z.optional(z.int().gte(0)),
	muted: z.optional(z.boolean()),
	hasMention: z.optional(z.boolean()),
	lastMessage: z.optional(zDirectCastMessage),
	viewerContext: zDirectCastConversationViewerContext,
});

export const zDirectCastInboxResult = z.object({
	hasArchived: z.boolean(),
	hasUnreadRequests: z.boolean(),
	requestsCount: z.int().gte(0),
	conversations: z.array(zDirectCastConversation),
});

export const zPaginationCursor = z.object({
	cursor: z.optional(z.string()),
});

export const zDirectCastInboxResponse = z.object({
	result: zDirectCastInboxResult,
	next: z.optional(zPaginationCursor),
});

export const zCastAction = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	octicon: z.optional(z.string()),
	actionUrl: z.optional(z.string()),
	action: z.optional(
		z.object({
			actionType: z.optional(z.string()),
			postUrl: z.optional(z.string()),
		}),
	),
});

export const zUserAppContextResponse = z.object({
	result: z.optional(
		z.object({
			context: z.optional(
				z.object({
					canAddLinks: z.optional(z.boolean()),
					showConnectedApps: z.optional(z.boolean()),
					signerRequestsEnabled: z.optional(z.boolean()),
					prompts: z.optional(z.array(z.unknown())),
					adminForChannelKeys: z.optional(z.array(z.string())),
					modOfChannelKeys: z.optional(z.array(z.string())),
					memberOfChannelKeys: z.optional(z.array(z.string())),
					canEditAllChannels: z.optional(z.boolean()),
					canUploadVideo: z.optional(z.boolean()),
					statsigEnabled: z.optional(z.boolean()),
					shouldPromptForPushNotifications: z.optional(z.boolean()),
					shouldPromptForUserFollowsSyncContacts: z.optional(z.boolean()),
					castActions: z.optional(z.array(zCastAction)),
					canAddCastAction: z.optional(z.boolean()),
					enabledCastAction: z.optional(zCastAction),
					notificationTabsV2: z.optional(
						z.array(
							z.object({
								id: z.optional(z.string()),
								name: z.optional(z.string()),
							}),
						),
					),
					enabledVideoAutoplay: z.optional(z.boolean()),
					regularCastByteLimit: z.optional(z.int()),
					longCastByteLimit: z.optional(z.int()),
					newUserStatus: z.optional(z.object({})),
					country: z.optional(z.string()),
					higherClientEventSamplingRateEnabled: z.optional(z.boolean()),
				}),
			),
		}),
	),
});

export const zUserPreferencesResponse = z.object({
	result: z.optional(
		z.object({
			preferences: z.optional(z.object({})),
		}),
	),
});

export const zChannel = z.object({
	type: z.optional(z.string()),
	key: z.optional(z.string()),
	name: z.optional(z.string()),
	imageUrl: z.optional(z.string()),
	fastImageUrl: z.optional(z.string()),
	feeds: z.optional(
		z.array(
			z.object({
				name: z.optional(z.string()),
				type: z.optional(z.string()),
			}),
		),
	),
	description: z.optional(z.string()),
	followerCount: z.optional(z.int()),
	memberCount: z.optional(z.int()),
	showCastSourceLabels: z.optional(z.boolean()),
	showCastTags: z.optional(z.boolean()),
	sectionRank: z.optional(z.int()),
	subscribable: z.optional(z.boolean()),
	publicCasting: z.optional(z.boolean()),
	inviteCode: z.optional(z.string()),
	headerImageUrl: z.optional(z.string()),
	headerAction: z.optional(
		z.object({
			title: z.optional(z.string()),
			target: z.optional(z.string()),
		}),
	),
	headerActionMetadata: z.optional(z.object({})),
	viewerContext: z.optional(
		z.object({
			following: z.optional(z.boolean()),
			isMember: z.optional(z.boolean()),
			hasUnseenItems: z.optional(z.boolean()),
			favoritePosition: z.optional(z.int()),
			activityRank: z.optional(z.int()),
			canCast: z.optional(z.boolean()),
		}),
	),
});

export const zHighlightedChannelsResponse = z.object({
	result: z.optional(
		z.object({
			channels: z.optional(z.array(zChannel)),
			viewerContext: z.optional(
				z.object({
					defaultFeed: z.optional(z.string()),
				}),
			),
		}),
	),
});

export const zImageEmbed = z.object({
	type: z.optional(z.enum(["image"])),
	url: z.optional(z.string()),
	sourceUrl: z.optional(z.string()),
	media: z.optional(
		z.object({
			version: z.optional(z.string()),
			width: z.optional(z.int()),
			height: z.optional(z.int()),
			staticRaster: z.optional(z.string()),
			mimeType: z.optional(z.string()),
		}),
	),
	alt: z.optional(z.string()),
});

export const zUrlEmbed = z.object({
	type: z.optional(z.enum(["url"])),
	openGraph: z.optional(
		z.object({
			url: z.optional(z.string()),
			sourceUrl: z.optional(z.string()),
			title: z.optional(z.string()),
			description: z.optional(z.string()),
			domain: z.optional(z.string()),
			image: z.optional(z.string()),
			useLargeImage: z.optional(z.boolean()),
		}),
	),
});

export const zVideoEmbed = z.object({
	type: z.optional(z.enum(["video"])),
});

export const zRecaster = z.object({
	fid: z.optional(z.int()),
	username: z.optional(z.string()),
	displayName: z.optional(z.string()),
	recastHash: z.optional(z.string()),
});

export const zCast = z.object({
	hash: z.optional(z.string()),
	threadHash: z.optional(z.string()),
	parentHash: z.optional(z.string()),
	parentSource: z.optional(
		z.object({
			type: z.optional(z.enum(["url"])),
			url: z.optional(z.string()),
		}),
	),
	author: z.optional(zUser),
	text: z.optional(z.string()),
	timestamp: z.optional(z.coerce.bigint()),
	mentions: z.optional(z.array(zUser)),
	embeds: z.optional(
		z.object({
			images: z.optional(z.array(zImageEmbed)),
			urls: z.optional(z.array(zUrlEmbed)),
			videos: z.optional(z.array(zVideoEmbed)),
			unknowns: z.optional(z.array(z.object({}))),
			processedCastText: z.optional(z.string()),
			groupInvites: z.optional(z.array(z.object({}))),
		}),
	),
	replies: z.optional(
		z.object({
			count: z.optional(z.int()),
		}),
	),
	reactions: z.optional(
		z.object({
			count: z.optional(z.int()),
		}),
	),
	recasts: z.optional(
		z.object({
			count: z.optional(z.int()),
			recasters: z.optional(z.array(zRecaster)),
		}),
	),
	watches: z.optional(
		z.object({
			count: z.optional(z.int()),
		}),
	),
	recast: z.optional(z.boolean()),
	tags: z.optional(
		z.array(
			z.object({
				type: z.optional(z.string()),
				id: z.optional(z.string()),
				name: z.optional(z.string()),
				imageUrl: z.optional(z.string()),
			}),
		),
	),
	quoteCount: z.optional(z.int()),
	combinedRecastCount: z.optional(z.int()),
	channel: z.optional(
		z.object({
			key: z.optional(z.string()),
			name: z.optional(z.string()),
			imageUrl: z.optional(z.string()),
			authorContext: z.optional(
				z.object({
					role: z.optional(z.string()),
					restricted: z.optional(z.boolean()),
					banned: z.optional(z.boolean()),
				}),
			),
			authorRole: z.optional(z.string()),
		}),
	),
	viewerContext: z.optional(
		z.object({
			reacted: z.optional(z.boolean()),
			recast: z.optional(z.boolean()),
			bookmarked: z.optional(z.boolean()),
		}),
	),
});

export const zFeedItemsResponse = z.object({
	result: z.object({
		items: z.array(
			z.object({
				id: z.string(),
				timestamp: z.int(),
				cast: zCast,
				otherParticipants: z.optional(z.array(zUser)),
			}),
		),
		latestMainCastTimestamp: z.optional(z.int()),
		feedTopSeenAtTimestamp: z.optional(z.int()),
		replaceFeed: z.boolean(),
	}),
});

export const zGenericResponse = z.object({
	result: z.object({}),
});

export const zUserResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				user: z.optional(zUserWithExtras),
				collectionsOwned: z.optional(z.array(z.object({}))),
				extras: z.optional(zUserExtras),
			}),
		),
	}),
);

export const zPaginatedResponse = z.object({
	result: z.object({}),
	next: z.optional(zPaginationCursor),
});

export const zSuggestedUsersResponse = zPaginatedResponse.and(
	z.object({
		result: z.optional(
			z.object({
				users: z.optional(z.array(z.object({}))),
			}),
		),
	}),
);

export const zFavoriteFramesResponse = z.object({
	result: z.object({
		frames: z.array(z.object({})),
	}),
});

export const zChannelStreaksResponse = z.object({
	result: z.object({}),
});

export const zUnseenCountsResponse = z.object({
	result: z.object({
		notificationsCount: z.optional(z.int()),
		notificationTabs: z.optional(
			z.array(
				z.object({
					tab: z.string(),
					unseenCount: z.int(),
				}),
			),
		),
		inboxCount: z.optional(z.int()),
		channelFeeds: z.optional(
			z.array(
				z.object({
					channelKey: z.string(),
					feedType: z.string(),
					hasNewItems: z.boolean(),
				}),
			),
		),
		warpTransactionCount: z.optional(z.int()),
	}),
});

export const zUserThreadCastsResponse = z.object({
	result: z.object({
		casts: z.array(z.object({})),
	}),
});

export const zChannelFollowersYouKnowResponse = z.object({
	result: z.object({
		users: z.array(z.object({})),
		totalCount: z.int(),
	}),
});

export const zSuccessResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				success: z.boolean(),
			}),
		),
	}),
);

export const zNotificationsResponse = z.object({
	result: z.object({
		notifications: z.optional(z.array(z.object({}))),
	}),
});

export const zDirectCastConversationResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				conversation: zDirectCastConversation,
			}),
		),
	}),
);

export const zDirectCastConversationCategorizationRequest = z.object({
	conversationId: z.string(),
	category: z.string(),
});

export const zDirectCastConversationMessagesResponse = zPaginatedResponse.and(
	z.object({
		result: z.optional(
			z.object({
				messages: z.array(zDirectCastMessage),
			}),
		),
	}),
);

export const zDirectCastConversationMessageTtlRequest = z.object({
	conversationId: z.string(),
	ttl: z.int(),
});

export const zDirectCastConversationNotificationsRequest = z.object({
	conversationId: z.string(),
	muted: z.boolean(),
});

export const zDirectCastSendRequest = z.object({
	conversationId: z.string(),
	recipientFids: z.array(z.int()),
	messageId: z.string(),
	type: z.enum(["text", "image", "reaction", "link"]),
	message: z.string(),
	inReplyToId: z.optional(z.string()),
});

export const zDirectCastManuallyMarkUnreadRequest = z.object({
	conversationId: z.string(),
});

export const zDirectCastMessageReactionRequest = z.object({
	conversationId: z.string(),
	messageId: z.string(),
	reaction: z.string(),
});

export const zDirectCastPinConversationRequest = z.object({
	conversationId: z.string(),
});

export const zDiscoverChannelsResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				channels: z.optional(z.array(z.object({}))),
			}),
		),
	}),
);

export const zInvitesAvailableResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				allocatedInvitesCount: z.int(),
				availableInvitesCount: z.int(),
			}),
		),
	}),
);

export const zSponsoredInvitesResponse = zGenericResponse.and(
	z.object({
		result: z.optional(
			z.object({
				invites: z.optional(z.array(z.object({}))),
			}),
		),
	}),
);

export const zRewardsLeaderboardResponse = z.object({
	result: z.object({
		leaderboard: z.object({
			type: z.string(),
			users: z.array(
				z.object({
					user: z.optional(z.object({})),
					score: z.optional(z.int()),
					rank: z.optional(z.int()),
				}),
			),
		}),
	}),
});

export const zRewardsScoresResponse = z.object({
	result: z.object({
		scores: z.array(
			z.object({
				type: z.optional(z.string()),
				user: z.optional(z.object({})),
				allTimeScore: z.optional(z.int()),
				currentPeriodScore: z.optional(z.int()),
				previousPeriodScore: z.optional(z.int()),
			}),
		),
	}),
});

export const zRewardsMetadataResponse = z.object({
	result: z.object({
		metadata: z.optional(
			z.object({
				type: z.optional(z.string()),
				lastUpdateTimestamp: z.optional(z.int()),
				currentPeriodStartTimestamp: z.optional(z.int()),
				currentPeriodEndTimestamp: z.optional(z.int()),
				tiers: z.optional(z.array(z.object({}))),
				proportionalPayout: z.optional(
					z.object({
						numWinners: z.optional(z.int()),
						totalRewardCents: z.optional(z.int()),
					}),
				),
			}),
		),
	}),
});

export const zBookmarkedCast = z.object({});

export const zBookmarkedCastsResponse = z.object({
	result: z.object({
		bookmarks: z.optional(z.array(zBookmarkedCast)),
	}),
});

export const zStarterPack = z.object({
	id: z.string(),
	creator: z.optional(zUser),
	name: z.optional(z.string()),
	description: z.optional(z.string()),
	openGraphImageUrl: z.optional(z.url()),
	itemCount: z.optional(z.int()),
	items: z.optional(z.array(z.object({}))),
	labels: z.optional(z.array(z.string())),
});

export const zStarterPacksResponse = z.object({
	result: z.object({
		starterPacks: z.array(zStarterPack),
	}),
});

export const zStarterPackResponse = z.object({
	result: z.object({
		starterPack: zStarterPack,
	}),
});

export const zStarterPackUpdateRequest = z.object({
	id: z.string(),
	name: z.string(),
	description: z.string(),
	fids: z.array(z.int()),
	labels: z.array(z.string()),
});

export const zStarterPackUsersResponse = z.object({
	result: z.object({
		users: z.array(zUser),
	}),
});

export const zChannelResponse = z.object({
	result: z.object({
		channel: z.optional(zChannel),
	}),
});

export const zChannelUsersResponse = z.object({
	result: z.object({
		users: z.optional(z.array(zUser)),
	}),
});

export const zUsersResponse = z.object({
	result: z.object({
		users: z.array(zUser),
	}),
});

export const zUsersWithCountResponse = z.object({
	result: z.object({
		users: z.array(zUser),
		totalCount: z.int(),
	}),
});

export const zFrameApp = z.object({});

export const zFrameAppsResponse = z.object({
	result: z.optional(
		z.object({
			frames: z.optional(z.array(zFrameApp)),
		}),
	),
});

/**
 * Context information for the viewer
 */
export const zMiniAppViewerContext = z.object({});

export const zMiniApp = z.object({
	domain: z.optional(z.string()),
	name: z.optional(z.string()),
	iconUrl: z.optional(z.string()),
	homeUrl: z.optional(z.string()),
	author: z.optional(zUser),
	supportsNotifications: z.optional(z.boolean()),
	id: z.optional(z.string()),
	shortId: z.optional(z.string()),
	imageUrl: z.optional(z.string()),
	buttonTitle: z.optional(z.string()),
	splashImageUrl: z.optional(z.string()),
	splashBackgroundColor: z.optional(z.string()),
	castShareUrl: z.optional(z.string()),
	subtitle: z.optional(z.string()),
	description: z.optional(z.string()),
	tagline: z.optional(z.string()),
	heroImageUrl: z.optional(z.string()),
	primaryCategory: z.optional(z.string()),
	tags: z.optional(z.array(z.string())),
	screenshotUrls: z.optional(z.array(z.string())),
	noindex: z.optional(z.boolean()),
	ogTitle: z.optional(z.string()),
	ogDescription: z.optional(z.string()),
	ogImageUrl: z.optional(z.string()),
	requiredCapabilities: z.optional(z.array(z.string())),
	requiredChains: z.optional(z.array(z.string())),
	viewerContext: z.optional(zMiniAppViewerContext),
});

export const zRankedMiniApp = z.object({
	rank: z.optional(z.int()),
	miniApp: z.optional(zMiniApp),
	rank72hChange: z.optional(z.int()),
});

export const zTopMiniAppsResponse = z.object({
	result: z.optional(
		z.object({
			miniApps: z.optional(z.array(zRankedMiniApp)),
			next: z.optional(zPaginationCursor),
		}),
	),
});

export const zVerifiedAddress = z.object({
	fid: z.optional(z.int()),
	address: z.optional(z.string()),
	timestamp: z.optional(z.int()),
	version: z.optional(z.string()),
	protocol: z.optional(z.string()),
	isPrimary: z.optional(z.boolean()),
	labels: z.optional(z.array(z.string())),
});

export const zMutedKeywordProperties = z.object({
	channels: z.optional(z.boolean()),
	frames: z.optional(z.boolean()),
	notifications: z.optional(z.boolean()),
});

export const zMutedKeyword = z.object({
	keyword: z.string(),
	properties: zMutedKeywordProperties,
});

export const zMutedKeywordsResponse = z.object({
	success: z.boolean(),
	result: z.object({
		keywords: z.array(z.string()),
		mutedKeywords: z.array(zMutedKeyword),
	}),
});

export const zCastHashResponse = z.object({
	result: z.object({
		castHash: z.optional(z.string()),
	}),
});

export const zAttachEmbedsResponse = z.object({
	result: z.object({}),
});

export const zCastRecastersResponse = z.object({
	result: z.object({
		users: z.optional(z.array(zUser)),
	}),
});

export const zCastQuote = z.object({
	hash: z.optional(z.string()),
	threadHash: z.optional(z.string()),
	parentSource: z.optional(
		z.object({
			type: z.optional(z.string()),
			url: z.optional(z.string()),
		}),
	),
	author: z.optional(zUser),
	text: z.optional(z.string()),
	timestamp: z.optional(z.int()),
});

export const zCastQuotesResponse = z.object({
	result: z.object({
		quotes: z.optional(z.array(zCastQuote)),
	}),
});

export const zUserResponseUserResponse = z.object({
	result: z.optional(
		z.object({
			user: z.optional(zUser),
		}),
	),
});

export const zSearchChannelsResponse = z.object({
	result: z.optional(
		z.object({
			channels: z.optional(z.array(zChannel)),
		}),
	),
});

export const zDraftsResponse = z.object({
	result: z.optional(
		z.object({
			drafts: z.optional(z.array(z.unknown())),
		}),
	),
});

export const zDraftCast = z.object({
	text: z.optional(z.string()),
	embeds: z.optional(z.array(z.unknown())),
});

export const zDraft = z.object({
	draftId: z.optional(z.string()),
	casts: z.optional(z.array(zDraftCast)),
});

export const zDraftCreatedResponse = z.object({
	result: z.optional(
		z.object({
			draft: z.optional(zDraft),
		}),
	),
});

export const zCastCreatedResponse = z.object({
	result: z.optional(
		z.object({
			cast: z.optional(zCast),
		}),
	),
});

export const zRawChannel = z.object({
	id: z.optional(z.string()),
	url: z.optional(z.string()),
	name: z.optional(z.string()),
	description: z.optional(z.string()),
	descriptionMentions: z.optional(z.array(z.int())),
	descriptionMentionsPositions: z.optional(z.array(z.int())),
	imageUrl: z.optional(z.string()),
	headerImageUrl: z.optional(z.string()),
	leadFid: z.optional(z.int()),
	moderatorFids: z.optional(z.array(z.int())),
	createdAt: z.optional(z.int()),
	followerCount: z.optional(z.int()),
	memberCount: z.optional(z.int()),
	pinnedCastHash: z.optional(z.string()),
	publicCasting: z.optional(z.boolean()),
	externalLink: z.optional(
		z.object({
			title: z.optional(z.string()),
			url: z.optional(z.string()),
		}),
	),
});

export const zChannelListResponse = z.object({
	result: z.optional(
		z.object({
			channels: z.optional(z.array(zRawChannel)),
		}),
	),
});

export const zRawChannelResponse = z.object({
	result: z.optional(
		z.object({
			channel: z.optional(zRawChannel),
		}),
	),
});

export const zChannelFollower = z.object({
	fid: z.optional(z.int()),
	followedAt: z.optional(z.int()),
});

export const zChannelFollowersResponse = zPaginatedResponse.and(
	z.object({
		result: z.optional(
			z.object({
				users: z.optional(z.array(zChannelFollower)),
			}),
		),
	}),
);

export const zChannelFollowStatus = z.object({
	following: z.optional(z.boolean()),
	followedAt: z.optional(z.int()),
});

export const zChannelFollowStatusResponse = z.object({
	result: z.optional(zChannelFollowStatus),
});

export const zAction = z.object({
	name: z.optional(z.string()),
	icon: z.optional(z.string()),
	description: z.optional(z.string()),
	aboutUrl: z.optional(z.url()),
	imageUrl: z.optional(z.url()),
	actionUrl: z.optional(z.url()),
	action: z.optional(
		z.object({
			actionType: z.optional(z.enum(["post", "get", "put", "delete"])),
			postUrl: z.optional(z.url()),
		}),
	),
});

export const zWinner = z.object({
	fid: z.optional(z.int()),
	domain: z.optional(z.string()),
	frameName: z.optional(z.string()),
	score: z.optional(z.int()),
	rank: z.optional(z.int()),
	rewardCents: z.optional(z.int()),
	walletAddress: z.optional(z.string()),
});

export const zFrame = z.object({
	domain: z.optional(z.string()),
	name: z.optional(z.string()),
	iconUrl: z.optional(z.string()),
	homeUrl: z.optional(z.string()),
	splashImageUrl: z.optional(z.string()),
	splashBackgroundColor: z.optional(z.string()),
	buttonTitle: z.optional(z.union([z.string(), z.null()])),
	imageUrl: z.optional(z.union([z.string(), z.null()])),
	supportsNotifications: z.optional(z.boolean()),
	viewerContext: z.optional(z.object({})),
	author: z.optional(zUser),
});

export const zAppsByAuthorResponse = z.object({
	result: z.optional(
		z.object({
			frames: z.optional(z.array(zFrame)),
		}),
	),
});

export const zApiKey = z.object({
	id: z.uuid(),
	createdAt: z.coerce.bigint(),
	expiresAt: z.coerce.bigint(),
	revokedAt: z.optional(z.union([z.string(), z.null()])),
	tag: z.string(),
	description: z.string(),
});

/**
 * Generic 400 Bad Request error for simple error messages
 */
export const zGenericBadRequestError = z.object({
	errors: z.array(
		z.object({
			message: z.string(),
		}),
	),
});

export const zDirectCastSendResponse = zSuccessResponse;

export const zDirectCastConversationCategorizationResponse = zSuccessResponse;

export const zDirectCastConversationNotificationsResponse = zSuccessResponse;

export const zDirectCastConversationMessageTtlResponse = zSuccessResponse;

export const zDirectCastMessageReactionResponse = zSuccessResponse;

/**
 * The user's FID (Farcaster ID)
 */
export const zFidParam = z.int();

/**
 * Maximum number of items to return
 */
export const zLimitParam = z.int().gte(1).lte(100).default(50);

/**
 * Base64 encoded cursor for pagination
 */
export const zCursorParam = z.string();

export const zGetUserOnboardingStateData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful retrieval of onboarding state
 */
export const zGetUserOnboardingStateResponse = zOnboardingStateResponse;

export const zGetUserByFidData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
	}),
});

/**
 * Successful retrieval of user by fid
 */
export const zGetUserByFidResponse = zUserByFidResponse;

export const zGetDirectCastInboxData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int().gte(1).lte(100)).default(50),
			category: z.optional(z.enum(["default", "requests", "spam"])),
			filter: z.optional(z.enum(["unread", "group", "1-1"])),
			cursor: z.optional(z.string()),
		}),
	),
});

/**
 * Successful retrieval of direct cast inbox
 */
export const zGetDirectCastInboxResponse = zDirectCastInboxResponse;

export const zGetUserAppContextData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful retrieval of user app context
 */
export const zGetUserAppContextResponse = zUserAppContextResponse;

export const zGetUserPreferencesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful retrieval of user preferences
 */
export const zGetUserPreferencesResponse = zUserPreferencesResponse;

export const zGetHighlightedChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful retrieval of highlighted channels
 */
export const zGetHighlightedChannelsResponse = zHighlightedChannelsResponse;

export const zGetFeedItemsData = z.object({
	body: z.object({
		feedKey: z.string(),
		feedType: z.string(),
		olderThan: z.optional(z.coerce.bigint()),
		latestMainCastTimestamp: z.optional(z.coerce.bigint()),
		excludeItemIdPrefixes: z.optional(z.array(z.string())),
		castViewEvents: z.optional(
			z.array(
				z.object({
					ts: z.coerce.bigint(),
					hash: z.string(),
					on: z.string(),
					channel: z.string(),
					feed: z.string(),
				}),
			),
		),
		updateState: z.optional(z.boolean()),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful retrieval of feed items
 */
export const zGetFeedItemsResponse = zFeedItemsResponse;

export const zGetUserData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
	}),
});

/**
 * Successful retrieval of user information
 */
export const zGetUserResponse = zUserResponse;

export const zGetUserFollowingChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			forComposer: z.optional(z.boolean()),
			limit: z.optional(z.int().gte(1).lte(100)).default(50),
		}),
	),
});

/**
 * Successful retrieval of followed channels
 */
export const zGetUserFollowingChannelsResponse = zHighlightedChannelsResponse;

export const zGetSuggestedUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int().gte(1).lte(100)).default(50),
			randomized: z.optional(z.boolean()),
		}),
	),
});

/**
 * Successful retrieval of suggested users
 */
export const zGetSuggestedUsersResponse = zSuggestedUsersResponse;

export const zGetUserFavoriteFramesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int().gte(1).lte(100)).default(50),
		}),
	),
});

/**
 * Successful retrieval of favorite frames
 */
export const zGetUserFavoriteFramesResponse = zFavoriteFramesResponse;

export const zGetUserByUsernameData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		username: z.string(),
	}),
});

/**
 * Successful retrieval of user by username
 */
export const zGetUserByUsernameResponse = zUserByFidResponse;

export const zGetChannelStreaksForUserData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
	}),
});

/**
 * Successful retrieval of channel streaks
 */
export const zGetChannelStreaksForUserResponse = zChannelStreaksResponse;

export const zGetUnseenCountsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful retrieval of unseen feed and notification data
 */
export const zGetUnseenCountsResponse = zUnseenCountsResponse;

export const zGetUserThreadCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z.optional(z.int().gte(1).lte(100)).default(50),
		castHashPrefix: z.string(),
		username: z.string(),
	}),
});

/**
 * Successful retrieval of user thread casts
 */
export const zGetUserThreadCastsResponse = zUserThreadCastsResponse;

export const zGetChannelFollowersYouKnowData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelKey: z.string(),
		limit: z.optional(z.int()),
	}),
});

/**
 * Successful retrieval of known channel followers
 */
export const zGetChannelFollowersYouKnowResponse =
	zChannelFollowersYouKnowResponse;

export const zMarkAllNotificationsReadData = z.object({
	body: z.object({}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful mark-all-read operation
 */
export const zMarkAllNotificationsReadResponse = zSuccessResponse;

export const zGetNotificationsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		tab: z.enum(["all", "follows", "reactions", "mentions", "replies"]),
		limit: z.optional(z.int().gte(1).lte(100)).default(15),
	}),
});

/**
 * A list of notifications
 */
export const zGetNotificationsResponse = zNotificationsResponse;

export const zSetLastCheckedTimestampData = z.object({
	body: z.object({}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Success
 */
export const zSetLastCheckedTimestampResponse = zSuccessResponse;

export const zGetDirectCastConversationData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		conversationId: z.string(),
	}),
});

/**
 * A direct cast conversation object
 */
export const zGetDirectCastConversationResponse =
	zDirectCastConversationResponse;

export const zCategorizeDirectCastConversationData = z.object({
	body: zDirectCastConversationCategorizationRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Conversation categorized successfully
 */
export const zCategorizeDirectCastConversationResponse = zSuccessResponse;

export const zGetDirectCastConversationMessagesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		conversationId: z.string(),
		limit: z.optional(z.int().gte(1).lte(100)).default(50),
	}),
});

/**
 * A list of direct cast conversation messages with pagination
 */
export const zGetDirectCastConversationMessagesResponse =
	zDirectCastConversationMessagesResponse;

export const zSetDirectCastConversationMessageTtlData = z.object({
	body: zDirectCastConversationMessageTtlRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Message TTL set successfully
 */
export const zSetDirectCastConversationMessageTtlResponse = zSuccessResponse;

export const zUpdateDirectCastConversationNotificationsData = z.object({
	body: zDirectCastConversationNotificationsRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Notification settings updated successfully
 */
export const zUpdateDirectCastConversationNotificationsResponse =
	zSuccessResponse;

export const zGetDirectCastConversationRecentMessagesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		conversationId: z.string(),
	}),
});

/**
 * A list of recent direct cast conversation messages
 */
export const zGetDirectCastConversationRecentMessagesResponse =
	zDirectCastConversationMessagesResponse;

export const zSendDirectCastMessageData = z.object({
	body: zDirectCastSendRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Direct cast message sent successfully
 */
export const zSendDirectCastMessageResponse = zSuccessResponse;

export const zDirectCastManuallyMarkUnreadData = z.object({
	body: zDirectCastManuallyMarkUnreadRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Direct cast conversation marked as unread successfully
 */
export const zDirectCastManuallyMarkUnreadResponse = zSuccessResponse;

export const zRemoveDirectCastMessageReactionData = z.object({
	body: zDirectCastMessageReactionRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Reaction removed successfully
 */
export const zRemoveDirectCastMessageReactionResponse = zSuccessResponse;

export const zAddDirectCastMessageReactionData = z.object({
	body: zDirectCastMessageReactionRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Reaction added successfully
 */
export const zAddDirectCastMessageReactionResponse = zSuccessResponse;

export const zUnpinDirectCastConversationData = z.object({
	body: zDirectCastPinConversationRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Direct cast conversation unpinned successfully
 */
export const zUnpinDirectCastConversationResponse = zSuccessResponse;

export const zPinDirectCastConversationData = z.object({
	body: zDirectCastPinConversationRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Direct cast conversation pinned successfully
 */
export const zPinDirectCastConversationResponse = zSuccessResponse;

export const zDiscoverChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int().gte(1).lte(100)).default(15),
		}),
	),
});

/**
 * A list of channels
 */
export const zDiscoverChannelsResponse2 = zDiscoverChannelsResponse;

export const zGetAvailableInvitesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Invite count information
 */
export const zGetAvailableInvitesResponse = zInvitesAvailableResponse;

export const zGetSponsoredInvitesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * List of sponsored invites
 */
export const zGetSponsoredInvitesResponse = zSponsoredInvitesResponse;

export const zGetRewardsLeaderboardData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z.optional(z.int().gte(1).lte(100)).default(50),
		rewardsType: z.enum(["invite"]),
		cursor: z.optional(z.string()),
	}),
});

/**
 * Rewards leaderboard
 */
export const zGetRewardsLeaderboardResponse = zRewardsLeaderboardResponse;

export const zGetUserRewardsScoresData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		rewardsType: z.enum(["invite"]),
	}),
});

/**
 * User rewards scores
 */
export const zGetUserRewardsScoresResponse = zRewardsScoresResponse;

export const zGetRewardsMetadataData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		rewardsType: z.enum(["invite"]),
	}),
});

/**
 * Invite rewards metadata
 */
export const zGetRewardsMetadataResponse = zRewardsMetadataResponse;

export const zGetBookmarkedCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int().gte(1).lte(100)).default(50),
		}),
	),
});

/**
 * A list of bookmarked casts
 */
export const zGetBookmarkedCastsResponse = zBookmarkedCastsResponse;

export const zGetUserStarterPacksData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()).default(15),
	}),
});

/**
 * A list of starter packs
 */
export const zGetUserStarterPacksResponse = zStarterPacksResponse;

export const zGetSuggestedStarterPacksData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int()).default(15),
		}),
	),
});

/**
 * A list of suggested starter packs
 */
export const zGetSuggestedStarterPacksResponse = zStarterPacksResponse;

export const zGetStarterPackData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		id: z.string(),
	}),
});

/**
 * A starter pack object
 */
export const zGetStarterPackResponse = zStarterPackResponse;

export const zUpdateStarterPackData = z.object({
	body: zStarterPackUpdateRequest,
	path: z.optional(z.never()),
	query: z.optional(z.never()),
	headers: z.optional(
		z.object({
			"idempotency-key": z.optional(z.string()),
		}),
	),
});

/**
 * Update status
 */
export const zUpdateStarterPackResponse = zSuccessResponse;

export const zGetStarterPackUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z.optional(z.int().gte(1).lte(100)).default(50),
		id: z.string(),
	}),
});

/**
 * List of users in the starter pack
 */
export const zGetStarterPackUsersResponse = zStarterPackUsersResponse;

export const zGetChannelData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		key: z.string(),
	}),
});

/**
 * Channel metadata
 */
export const zGetChannelResponse = zChannelResponse;

export const zGetChannelUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z.optional(z.int().gte(1).lte(100)).default(50),
		channelKey: z.string(),
		filterToMembers: z.optional(z.boolean()),
		query: z.optional(z.string()),
	}),
});

/**
 * A list of users in the specified channel
 */
export const zGetChannelUsersResponse = zChannelUsersResponse;

export const zGetFollowingData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()),
	}),
});

/**
 * A list of followed users
 */
export const zGetFollowingResponse = zUsersResponse;

export const zGetFollowersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()),
	}),
});

/**
 * A list of followers
 */
export const zGetFollowersResponse = zUsersResponse;

export const zGetMutualFollowersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()),
	}),
});

/**
 * A list of mutual followers
 */
export const zGetMutualFollowersResponse = zUsersWithCountResponse;

export const zGetTopFrameAppsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int().gte(1).lte(100)).default(50),
			cursor: z.optional(z.string()),
		}),
	),
});

/**
 * A list of FrameApps
 */
export const zGetTopFrameAppsResponse = zFrameAppsResponse;

export const zGetTopMiniAppsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int().gte(1).lte(100)).default(50),
			cursor: z.optional(z.string()),
		}),
	),
});

/**
 * A list of top mini apps
 */
export const zGetTopMiniAppsResponse = zTopMiniAppsResponse;

export const zGetVerificationsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int().gte(1).lte(100)).default(50),
	}),
});

/**
 * A list of verifications
 */
export const zGetVerificationsResponse = z.object({
	result: z.optional(
		z.object({
			verifications: z.optional(z.array(zVerifiedAddress)),
		}),
	),
});

export const zGetMutedKeywordsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * A list of muted keywords
 */
export const zGetMutedKeywordsResponse = zMutedKeywordsResponse;

export const zMuteKeywordData = z.object({
	body: z.object({
		keyword: z.optional(z.string()),
		properties: z.optional(zMutedKeywordProperties),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * The muted keyword and its settings
 */
export const zMuteKeywordResponse = zMutedKeywordsResponse;

export const zUnmuteKeywordData = z.object({
	body: z.object({
		keyword: z.optional(z.string()),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Keyword unmuted
 */
export const zUnmuteKeywordResponse = zMutedKeywordsResponse;

export const zUnlikeCastData = z.object({
	body: z.object({
		castHash: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Unlike response
 */
export const zUnlikeCastResponse = z.object({
	result: z.optional(
		z.object({
			success: z.optional(z.boolean()),
		}),
	),
});

export const zGetCastLikesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		castHash: z.string(),
		limit: z.optional(z.int()).default(15),
	}),
});

/**
 * A list of cast likes
 */
export const zGetCastLikesResponse = z.object({
	result: z.optional(
		z.object({
			likes: z.optional(
				z.array(
					z.object({
						type: z.optional(z.string()),
						hash: z.optional(z.string()),
						castHash: z.optional(z.string()),
						timestamp: z.optional(z.int()),
						reactor: z.optional(zUser),
					}),
				),
			),
		}),
	),
});

export const zLikeCastData = z.object({
	body: z.object({
		castHash: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Like response
 */
export const zLikeCastResponse = z.object({
	result: z.optional(
		z.object({
			like: z.optional(
				z.object({
					type: z.optional(z.string()),
					hash: z.optional(z.string()),
					castHash: z.optional(z.string()),
					timestamp: z.optional(z.int()),
					reactor: z.optional(zUser),
				}),
			),
		}),
	),
});

export const zUndoRecastData = z.object({
	body: z.object({
		castHash: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Undo recast response
 */
export const zUndoRecastResponse = zSuccessResponse;

export const zRecastCastData = z.object({
	body: z.object({
		castHash: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Recast response
 */
export const zRecastCastResponse = zCastHashResponse;

export const zAttachEmbedsData = z.object({
	body: z.object({
		text: z.optional(z.string()),
		embeds: z.optional(z.array(z.url())),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Attachment response
 */
export const zAttachEmbedsResponse2 = zAttachEmbedsResponse;

export const zGetCastRecastersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		limit: z.optional(z.int().gte(1).lte(100)).default(50),
		castHash: z.string(),
	}),
});

/**
 * A list of users who recasted the cast
 */
export const zGetCastRecastersResponse = zCastRecastersResponse;

export const zGetCastQuotesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		castHash: z.string(),
		limit: z.optional(z.int()).default(15),
	}),
});

/**
 * A list of quote casts referencing the given cast
 */
export const zGetCastQuotesResponse = zCastQuotesResponse;

export const zGetCurrentUserData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful retrieval of current user
 */
export const zGetCurrentUserResponse = zUserResponseUserResponse;

export const zSearchChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int().gte(1).lte(100)).default(50),
			q: z.optional(z.string()),
			prioritizeFollowed: z.optional(z.boolean()).default(true),
			forComposer: z.optional(z.boolean()).default(false),
		}),
	),
});

/**
 * A list of matched channels
 */
export const zSearchChannelsResponse2 = zSearchChannelsResponse;

export const zGetDraftCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int()).default(15),
		}),
	),
});

/**
 * A list of draft cast storms
 */
export const zGetDraftCastsResponse = zDraftsResponse;

export const zCreateDraftCastsData = z.object({
	body: z.object({
		caststorm: z.optional(
			z.object({
				casts: z.optional(z.array(zDraftCast)),
			}),
		),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
	headers: z.object({
		"idempotency-key": z.uuid(),
	}),
});

/**
 * Created draft caststorm
 */
export const zCreateDraftCastsResponse = zDraftCreatedResponse;

export const zDeleteDraftCastData = z.object({
	body: z.object({
		draftId: z.optional(z.string()),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Draft cast deleted
 */
export const zDeleteDraftCastResponse = zSuccessResponse;

export const zDeleteCastData = z.object({
	body: z.object({
		castHash: z.optional(z.string()),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Cast deleted successfully
 */
export const zDeleteCastResponse = zSuccessResponse;

export const zGetCastsByFidData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()).default(15),
	}),
});

/**
 * Successfully retrieved casts
 */
export const zGetCastsByFidResponse = z.object({
	result: z.optional(
		z.object({
			casts: z.optional(z.array(zCast)),
		}),
	),
});

export const zCreateCastData = z.object({
	body: z.object({
		text: z.string(),
		embeds: z.optional(z.array(z.unknown())),
		channelKey: z.optional(z.string()),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Cast created successfully
 */
export const zCreateCastResponse = zCastCreatedResponse;

export const zGetAllChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful response
 */
export const zGetAllChannelsResponse = zChannelListResponse;

export const zGetChannelDetailsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
	}),
});

/**
 * Channel details
 */
export const zGetChannelDetailsResponse = zRawChannelResponse;

export const zGetChannelFollowersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
		cursor: z.optional(z.string()),
	}),
});

/**
 * A list of channel followers
 */
export const zGetChannelFollowersResponse = zChannelFollowersResponse;

export const zGetUserFollowedChannelsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
	}),
});

/**
 * Successful response with list of followed channels
 */
export const zGetUserFollowedChannelsResponse = zChannelListResponse;

export const zCheckUserChannelFollowStatusData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		channelId: z.string(),
	}),
});

/**
 * Successful response with follow status
 */
export const zCheckUserChannelFollowStatusResponse =
	zChannelFollowStatusResponse;

export const zGetChannelMembersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
	}),
});

/**
 * Successful response with list of members
 */
export const zGetChannelMembersResponse = z.object({
	result: z.object({
		members: z.array(
			z.object({
				fid: z.int(),
				memberAt: z.int(),
			}),
		),
	}),
	next: z.optional(
		z.object({
			cursor: z.optional(z.string()),
		}),
	),
});

export const zRemoveChannelInviteData = z.object({
	body: z.object({
		channelId: z.string(),
		removeFid: z.int(),
		role: z.enum(["member", "admin"]),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful removal of invite
 */
export const zRemoveChannelInviteResponse = zSuccessResponse;

export const zGetChannelInvitesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
	}),
});

/**
 * Successful response with list of channel invites
 */
export const zGetChannelInvitesResponse = z.object({
	result: z.optional(
		z.object({
			invites: z.optional(
				z.array(
					z.object({
						channelId: z.string(),
						invitedFid: z.int(),
						invitedAt: z.int(),
						inviterFid: z.int(),
						role: z.enum(["member", "admin"]),
					}),
				),
			),
		}),
	),
	next: z.optional(
		z.object({
			cursor: z.optional(z.string()),
		}),
	),
});

export const zAcceptChannelInviteData = z.object({
	body: z.object({
		channelId: z.string(),
		role: z.enum(["member", "admin"]),
		accept: z.boolean(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful acceptance of invite
 */
export const zAcceptChannelInviteResponse = zSuccessResponse;

export const zInviteUserToChannelData = z.object({
	body: z.object({
		channelId: z.string(),
		inviteFid: z.int(),
		role: z.enum(["member", "admin"]),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful invite operation
 */
export const zInviteUserToChannelResponse = zSuccessResponse;

export const zGetChannelModeratedCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
	}),
});

/**
 * Successful response with list of moderation actions
 */
export const zGetChannelModeratedCastsResponse = z.object({
	result: z.object({
		moderationActions: z.array(
			z.object({
				castHash: z.string(),
				channelId: z.string(),
				action: z.enum(["hide"]),
				moderatedAt: z.int(),
			}),
		),
	}),
	next: z.optional(
		z.object({
			cursor: z.optional(z.string()),
		}),
	),
});

export const zGetChannelRestrictedUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
	}),
});

/**
 * Successful response with list of restricted users
 */
export const zGetChannelRestrictedUsersResponse = z.object({
	result: z.object({
		restrictedUsers: z.array(
			z.object({
				fid: z.int(),
				channelId: z.string(),
				restrictedAt: z.int(),
			}),
		),
	}),
	next: z.optional(
		z.object({
			cursor: z.optional(z.string()),
		}),
	),
});

export const zUnbanUserFromChannelData = z.object({
	body: z.object({
		channelId: z.string(),
		banFid: z.int(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful unban operation
 */
export const zUnbanUserFromChannelResponse = zSuccessResponse;

export const zGetChannelBannedUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		channelId: z.string(),
	}),
});

/**
 * Successful response with list of banned users
 */
export const zGetChannelBannedUsersResponse = z.object({
	result: z.object({
		bannedUsers: z.array(
			z.object({
				fid: z.int(),
				channelId: z.string(),
				bannedAt: z.int(),
			}),
		),
	}),
	next: z.optional(
		z.object({
			cursor: z.optional(z.string()),
		}),
	),
});

export const zBanUserFromChannelData = z.object({
	body: z.object({
		channelId: z.string(),
		banFid: z.int(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful ban operation
 */
export const zBanUserFromChannelResponse = zSuccessResponse;

export const zUnfollowChannelData = z.object({
	body: z.object({
		channelId: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful unfollow operation
 */
export const zUnfollowChannelResponse = zSuccessResponse;

export const zFollowChannelData = z.object({
	body: z.object({
		channelId: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful follow operation
 */
export const zFollowChannelResponse = zSuccessResponse;

export const zModerateCastData = z.object({
	body: z.object({
		castHash: z.string(),
		action: z.enum(["hide"]),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful moderation action
 */
export const zModerateCastResponse = zSuccessResponse;

export const zUnpinCastFromChannelData = z.object({
	body: z.object({
		channelId: z.string(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful unpin operation
 */
export const zUnpinCastFromChannelResponse = zSuccessResponse;

export const zPinCastToChannelData = z.object({
	body: z.object({
		castHash: z.string(),
		notifyChannelFollowers: z.optional(z.boolean()),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful pin operation
 */
export const zPinCastToChannelResponse = zSuccessResponse;

export const zGetDiscoverableActionsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		list: z.string(),
		limit: z.optional(z.int()),
	}),
});

/**
 * Successful response with list of discoverable actions
 */
export const zGetDiscoverableActionsResponse = z.object({
	result: z.optional(
		z.object({
			actions: z.optional(z.array(zAction)),
			next: z.optional(
				z.object({
					cursor: z.optional(z.string()),
				}),
			),
		}),
	),
});

export const zGetDiscoverableComposerActionsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		list: z.string(),
		limit: z.optional(z.int()),
	}),
});

/**
 * Successful response with list of discoverable composer actions
 */
export const zGetDiscoverableComposerActionsResponse = z.object({
	result: z.optional(
		z.object({
			actions: z.optional(z.array(zAction)),
			next: z.optional(
				z.object({
					cursor: z.optional(z.string()),
				}),
			),
		}),
	),
});

export const zUnblockUserData = z.object({
	body: z.object({
		unblockFid: z.int(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful unblock operation
 */
export const zUnblockUserResponse = z.object({
	result: z.object({
		success: z.boolean(),
	}),
});

export const zGetBlockedUsersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful response with list of blocked users
 */
export const zGetBlockedUsersResponse = z.object({
	result: z.object({
		blockedUsers: z.array(
			z.object({
				blockerFid: z.int(),
				blockedFid: z.int(),
				createdAt: z.int(),
			}),
		),
		next: z.optional(zPaginationCursor),
	}),
});

export const zBlockUserData = z.object({
	body: z.object({
		blockFid: z.int(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful block operation
 */
export const zBlockUserResponse = zSuccessResponse;

export const zGetAccountVerificationsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
	}),
});

/**
 * Successful response with list of account verifications
 */
export const zGetAccountVerificationsResponse = z.object({
	result: z.optional(
		z.object({
			verifications: z.optional(
				z.array(
					z.object({
						fid: z.optional(z.int()),
						platform: z.optional(z.string()),
						platformId: z.optional(z.string()),
						platformUsername: z.optional(z.string()),
						verifiedAt: z.optional(z.int()),
					}),
				),
			),
		}),
	),
	next: z.optional(zPaginationCursor),
});

export const zGetCreatorRewardWinnersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			periodsAgo: z.optional(z.int()),
		}),
	),
});

/**
 * Successful response with creator reward winners history
 */
export const zGetCreatorRewardWinnersResponse = z.object({
	result: z.optional(
		z.object({
			periodStartTimestamp: z.optional(z.coerce.bigint()),
			periodEndTimestamp: z.optional(z.coerce.bigint()),
			winners: z.optional(
				z.array(
					z.object({
						fid: z.optional(z.int()),
						score: z.optional(z.int()),
						rank: z.optional(z.int()),
						rewardCents: z.optional(z.int()),
						walletAddress: z.optional(z.string()),
					}),
				),
			),
		}),
	),
	next: z.optional(
		z.object({
			cursor: z.optional(z.string()),
		}),
	),
});

export const zGetUserPrimaryAddressData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		protocol: z.enum(["ethereum", "solana"]),
	}),
});

/**
 * Successful response with the user's primary address.
 */
export const zGetUserPrimaryAddressResponse = z.object({
	result: z.optional(
		z.object({
			address: z.optional(zVerifiedAddress),
		}),
	),
});

export const zGetUserPrimaryAddressesData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fids: z.string(),
		protocol: z.enum(["ethereum", "solana"]),
	}),
});

/**
 * Successful response with list of primary addresses.
 */
export const zGetUserPrimaryAddressesResponse = z.object({
	result: z.optional(
		z.object({
			addresses: z.optional(
				z.array(
					z.object({
						fid: z.int(),
						success: z.boolean(),
						address: z.optional(zVerifiedAddress),
					}),
				),
			),
		}),
	),
});

export const zGetStarterPackMembersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		id: z.string(),
	}),
});

/**
 * Successful response with list of starter pack members.
 */
export const zGetStarterPackMembersResponse = z.object({
	result: z.optional(
		z.object({
			members: z.optional(
				z.array(
					z.object({
						fid: z.int(),
						memberAt: z.coerce.bigint(),
					}),
				),
			),
		}),
	),
	next: z.optional(
		z.object({
			cursor: z.optional(z.string()),
		}),
	),
});

export const zSendDirectCastData = z.object({
	body: z.object({
		recipientFid: z.int(),
		message: z.string(),
		idempotencyKey: z.uuid(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Direct cast sent successfully
 */
export const zSendDirectCastResponse = z.object({
	result: z.object({
		success: z.boolean(),
	}),
});

export const zGetUserByVerificationAddressData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		address: z.string(),
	}),
});

/**
 * User data successfully retrieved
 */
export const zGetUserByVerificationAddressResponse = zUserResponse;

export const zGetDeveloperRewardWinnersData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			periodsAgo: z.optional(z.int()),
		}),
	),
});

/**
 * A paginated list of developer reward winners
 */
export const zGetDeveloperRewardWinnersResponse = z.object({
	result: z.optional(
		z.object({
			periodStartTimestamp: z.optional(z.int()),
			periodEndTimestamp: z.optional(z.int()),
			winners: z.optional(z.array(zWinner)),
		}),
	),
	next: z.optional(
		z.object({
			cursor: z.optional(z.string()),
		}),
	),
});

export const zGetAppsByAuthorData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int().gte(1).lte(100)).default(50),
	}),
});

/**
 * A list of frames by the author
 */
export const zGetAppsByAuthorResponse = zAppsByAuthorResponse;

export const zGetDomainManifestData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		domain: z.string(),
	}),
});

/**
 * Successfully retrieved domain manifest
 */
export const zGetDomainManifestResponse = z.object({
	result: z.optional(
		z.object({
			state: z.optional(
				z.object({
					verified: z.optional(z.boolean()),
					manifest: z.optional(z.string()),
					decodedManifest: z.optional(
						z.object({
							accountAssociation: z.optional(
								z.object({
									fid: z.optional(z.int()),
									key: z.optional(z.string()),
									domain: z.optional(z.string()),
									signature: z.optional(z.string()),
								}),
							),
						}),
					),
					frameConfig: z.optional(
						z.object({
							name: z.optional(z.string()),
							version: z.optional(z.string()),
							iconUrl: z.optional(z.string()),
							homeUrl: z.optional(z.string()),
							imageUrl: z.optional(z.string()),
							buttonTitle: z.optional(z.string()),
							splashImageUrl: z.optional(z.string()),
							splashBackgroundColor: z.optional(z.string()),
							webhookUrl: z.optional(z.string()),
						}),
					),
					updatedAt: z.optional(z.int()),
				}),
			),
		}),
	),
});

export const zGetMetaTagsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		url: z.url(),
	}),
});

/**
 * Successfully retrieved metadata
 */
export const zGetMetaTagsResponse = z.object({
	viewport: z.optional(z.string()),
	"theme-color": z.optional(z.array(z.string())),
	"color-scheme": z.optional(z.string()),
	description: z.optional(z.string()),
	"apple-mobile-web-app-capable": z.optional(z.string()),
	"apple-mobile-web-app-title": z.optional(z.string()),
	"apple-mobile-web-app-status-bar-style": z.optional(z.string()),
	"og:title": z.optional(z.string()),
	"og:description": z.optional(z.string()),
	"og:url": z.optional(z.string()),
	"og:site_name": z.optional(z.string()),
	"og:image:alt": z.optional(z.string()),
	"og:image:type": z.optional(z.string()),
	"og:image:width": z.optional(z.string()),
	"og:image:height": z.optional(z.string()),
	"og:image": z.optional(z.string()),
	"og:type": z.optional(z.string()),
	"twitter:card": z.optional(z.string()),
	"twitter:title": z.optional(z.string()),
	"twitter:description": z.optional(z.string()),
	"twitter:image:alt": z.optional(z.string()),
	"twitter:image:type": z.optional(z.string()),
	"twitter:image:width": z.optional(z.string()),
	"twitter:image:height": z.optional(z.string()),
	"twitter:image": z.optional(z.string()),
});

export const zGetFarcasterJsonData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		domain: z.string(),
	}),
});

/**
 * Successfully retrieved Farcaster JSON data
 */
export const zGetFarcasterJsonResponse = z.object({
	accountAssociation: z.optional(
		z.object({
			header: z.optional(z.string()),
			payload: z.optional(z.string()),
			signature: z.optional(z.string()),
		}),
	),
	frame: z.optional(
		z.object({
			homeUrl: z.optional(z.url()),
			iconUrl: z.optional(z.url()),
			name: z.optional(z.string()),
			splashBackgroundColor: z.optional(z.string()),
			splashImageUrl: z.optional(z.url()),
			version: z.optional(z.string()),
			webhookUrl: z.optional(z.url()),
		}),
	),
});

export const zGetOwnedDomainsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successfully retrieved owned domains
 */
export const zGetOwnedDomainsResponse = z.object({
	result: z.object({
		domains: z.optional(z.array(z.string())),
	}),
});

export const zGetApiKeysData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successfully retrieved API keys
 */
export const zGetApiKeysResponse = z.object({
	result: z.object({
		apiKeys: z.array(zApiKey),
	}),
});

export const zCreateApiKeyData = z.object({
	body: z.object({
		description: z.string(),
		expiresAt: z.coerce.bigint(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
	headers: z.optional(
		z.object({
			"idempotency-key": z.optional(z.uuid()),
		}),
	),
});

/**
 * Successfully created API key
 */
export const zCreateApiKeyResponse = z.object({
	result: z.object({
		id: z.uuid(),
		secretKey: z.string(),
	}),
});

export const zRevokeApiKeyData = z.object({
	body: z.object({
		id: z.uuid(),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
	headers: z.optional(
		z.object({
			"idempotency-key": z.optional(z.uuid()),
		}),
	),
});

/**
 * Successfully revoked the API key
 */
export const zRevokeApiKeyResponse = z.object({
	result: z.object({
		success: z.boolean(),
	}),
});

export const zGetConnectedAccountsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.optional(
		z.object({
			limit: z.optional(z.int()).default(15),
		}),
	),
});

/**
 * List of connected accounts
 */
export const zGetConnectedAccountsResponse = z.object({
	result: z.object({
		accounts: z.optional(
			z.array(
				z.object({
					connectedAccountId: z.optional(z.string()),
					platform: z.optional(z.enum(["x", "github", "lens", "ethereum"])),
					username: z.optional(z.string()),
					expired: z.optional(z.boolean()),
				}),
			),
		),
	}),
});

export const zGetProfileCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()).default(15),
		cursor: z.optional(z.string()),
	}),
});

/**
 * Successfully retrieved user's casts
 */
export const zGetProfileCastsResponse = z.object({
	result: z.object({
		casts: z.array(zCast),
	}),
	next: z.optional(
		z.object({
			cursor: z.optional(z.string()),
		}),
	),
});

export const zGetUserLikedCastsData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		fid: z.int(),
		limit: z.optional(z.int()).default(15),
	}),
});

/**
 * Successfully retrieved liked casts.
 */
export const zGetUserLikedCastsResponse = z.object({
	result: z.object({
		casts: z.optional(z.array(zCast)),
		next: z.optional(
			z.object({
				cursor: z.optional(z.string()),
			}),
		),
	}),
});

export const zGetMiniAppAnalyticsRollupData = z.object({
	body: z.object({
		dateRange: z.object({
			startDate: z.string(),
			endDate: z.string(),
		}),
		measures: z.array(
			z.enum([
				"miniapp_opens",
				"miniapp_transactions",
				"miniapp_users_w_transaction",
				"miniapp_users_w_open",
				"miniapp_users_w_notifications_enabled",
				"miniapp_users_w_notifications_disabled",
				"miniapp_users_w_app_favorited",
				"miniapp_users_w_app_unfavorited",
			]),
		),
		restrictions: z.array(
			z.object({
				dimension: z.string(),
				values: z.array(z.string()),
			}),
		),
		breakdownSettings: z.optional(
			z.object({
				dimensions: z.optional(z.array(z.string())),
				order: z.optional(z.enum(["asc", "desc"])),
			}),
		),
	}),
	path: z.optional(z.never()),
	query: z.optional(z.never()),
});

/**
 * Successful analytics rollup retrieval
 */
export const zGetMiniAppAnalyticsRollupResponse = z.object({
	result: z.optional(
		z.object({
			rollup: z.optional(
				z.object({
					dateRange: z.optional(
						z.object({
							startDate: z.optional(z.iso.date()),
							endDate: z.optional(z.iso.date()),
						}),
					),
					restrictions: z.optional(
						z.array(
							z.object({
								dimension: z.optional(z.string()),
								values: z.optional(z.array(z.string())),
							}),
						),
					),
					totals: z.optional(
						z.array(
							z.object({
								name: z.optional(z.string()),
								value: z.optional(z.int()),
							}),
						),
					),
					breakdown: z.optional(
						z.array(
							z.object({
								slices: z.optional(
									z.array(
										z.object({
											dimension: z.optional(z.string()),
											values: z.optional(z.array(z.string())),
										}),
									),
								),
								measures: z.optional(
									z.array(
										z.object({
											name: z.optional(z.string()),
											value: z.optional(z.int()),
										}),
									),
								),
							}),
						),
					),
				}),
			),
		}),
	),
});

export const zInspectMiniAppUrlData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		url: z.url(),
	}),
});

/**
 * Successful inspection of the Mini App URL
 */
export const zInspectMiniAppUrlResponse = z.object({
	result: z.optional(
		z.object({
			facts: z.optional(
				z.object({
					url: z.optional(z.url()),
					statusCode: z.optional(z.int()),
					miniAppEmbedPresent: z.optional(z.boolean()),
					miniAppManifestPresent: z.optional(z.boolean()),
					miniAppEmbedValid: z.optional(z.boolean()),
					miniAppManifestValid: z.optional(z.boolean()),
				}),
			),
		}),
	),
});

export const zInspectImageUrlData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		url: z.url(),
	}),
});

/**
 * Image inspection successful
 */
export const zInspectImageUrlResponse = z.object({
	result: z.object({
		facts: z.optional(
			z.object({
				url: z.optional(z.string()),
				statusCode: z.optional(z.int()),
				cacheHeader: z.optional(z.string()),
				cacheAge: z.optional(z.int()),
				imageSizeBytes: z.optional(z.int()),
				imageLoadTimeMs: z.optional(z.int()),
			}),
		),
	}),
});

export const zExportMiniAppUserDataData = z.object({
	body: z.optional(z.never()),
	path: z.optional(z.never()),
	query: z.object({
		domain: z.string(),
	}),
});

/**
 * Successfully retrieved mini app user data
 */
export const zExportMiniAppUserDataResponse = z.object({
	result: z.object({
		users: z.optional(
			z.array(
				z.object({
					fid: z.int(),
					notificationToken: z.optional(z.union([z.string(), z.null()])),
					added: z.boolean(),
				}),
			),
		),
	}),
});
