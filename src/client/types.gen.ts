// This file is auto-generated by @hey-api/openapi-ts

export type ProfilePicture = {
	url?: string;
	verified?: boolean;
};

export type Bio = {
	text?: string;
	mentions?: Array<unknown>;
	channelMentions?: Array<unknown>;
};

export type Location = {
	placeId?: string;
	description?: string;
};

export type Profile = {
	bio?: Bio;
	location?: Location;
};

export type ViewerContext = {
	following?: boolean;
	followedBy?: boolean;
	enableNotifications?: boolean;
	canSendDirectCasts?: boolean;
	hasUploadedInboxKeys?: boolean;
};

export type User = {
	fid?: number;
	username?: string;
	displayName?: string;
	pfp?: ProfilePicture;
	profile?: Profile;
	followerCount?: number;
	followingCount?: number;
	viewerContext?: ViewerContext;
};

export type OnboardingState = {
	id?: string;
	email?: string;
	user?: User;
	hasOnboarding?: boolean;
	hasConfirmedEmail?: boolean;
	handledConnectAddress?: boolean;
	canRegisterUsername?: boolean;
	needsRegistrationPayment?: boolean;
	hasFid?: boolean;
	hasFname?: boolean;
	hasDelegatedSigner?: boolean;
	hasSetupProfile?: boolean;
	hasCompletedRegistration?: boolean;
	hasStorage?: boolean;
	handledPushNotificationsNudge?: boolean;
	handledContactsNudge?: boolean;
	handledInterestsNudge?: boolean;
	hasValidPaidInvite?: boolean;
	hasWarpcastWalletAddress?: boolean;
	hasPhone?: boolean;
	needsPhone?: boolean;
	sponsoredRegisterEligible?: boolean;
	geoRestricted?: boolean;
};

export type OnboardingStateResponse = {
	result?: {
		state?: OnboardingState;
	};
};

export type ErrorResponse = {
	errors?: Array<{
		/**
		 * Error message describing the issue
		 */
		message?: string;
	}>;
};

export type UserWithExtras = User & {
	connectedAccounts?: Array<unknown>;
};

export type UserExtras = {
	fid?: number;
	custodyAddress?: string;
	ethWallets?: Array<string>;
	solanaWallets?: Array<string>;
	walletLabels?: Array<{
		address?: string;
		labels?: Array<string>;
	}>;
	v2?: boolean;
	publicSpamLabel?: string;
};

export type UserByFidResponse = {
	result?: {
		user?: UserWithExtras;
		collectionsOwned?: Array<unknown>;
		extras?: UserExtras;
	};
};

export type DirectCastMessageReaction = {
	/**
	 * Emoji used for the reaction
	 */
	reaction: string;
	/**
	 * Number of users who reacted with this emoji
	 */
	count: number;
	/**
	 * Emoji used for the reaction (legacy field)
	 */
	emoji?: string;
	/**
	 * List of Farcaster IDs who reacted
	 */
	userFids?: Array<number>;
};

export type DirectCastMessageViewerContext = {
	/**
	 * Whether this is the last read message
	 */
	isLastReadMessage?: boolean;
	/**
	 * Whether the message is focused
	 */
	focused?: boolean;
	/**
	 * User's reactions to this message
	 */
	reactions?: Array<string>;
};

export type DirectCastMessage = {
	/**
	 * ID of the conversation this message belongs to
	 */
	conversationId: string;
	/**
	 * Farcaster ID of the message sender
	 */
	senderFid: number;
	/**
	 * Unique identifier for the message
	 */
	messageId: string;
	/**
	 * Server timestamp when message was sent (Unix milliseconds)
	 */
	serverTimestamp: bigint;
	/**
	 * Type of the message
	 */
	type:
		| "text"
		| "image"
		| "reaction"
		| "link"
		| "group_membership_addition"
		| "pin_message"
		| "message_ttl_change";
	/**
	 * Content of the message
	 */
	message: string;
	/**
	 * Whether the message contains mentions
	 */
	hasMention: boolean;
	/**
	 * List of reactions to the message
	 */
	reactions: Array<DirectCastMessageReaction>;
	/**
	 * Whether the message is pinned
	 */
	isPinned: boolean;
	/**
	 * Whether the message is deleted
	 */
	isDeleted: boolean;
	senderContext: User;
	viewerContext?: DirectCastMessageViewerContext;
	inReplyTo?: DirectCastMessage;
	metadata?: DirectCastMessageMetadata;
	actionTargetUserContext?: User;
	/**
	 * Whether the message was sent programmatically
	 */
	isProgrammatic?: boolean;
	/**
	 * List of mentions in the message
	 */
	mentions?: Array<DirectCastMessageMention>;
};

export type DirectCastMessageMetadata = {
	/**
	 * Cast metadata if message contains cast references
	 */
	casts?: Array<{
		[key: string]: unknown;
	}>;
	/**
	 * URL metadata if message contains links
	 */
	urls?: Array<{
		[key: string]: unknown;
	}>;
	/**
	 * Media metadata if message contains media
	 */
	medias?: Array<{
		[key: string]: unknown;
	}>;
};

export type DirectCastMessageMention = {
	user: User;
	/**
	 * Starting index of the mention in the message text
	 */
	textIndex: number;
	/**
	 * Length of the mention text
	 */
	length: number;
};

export type DirectCastConversationViewerContext = {
	/**
	 * Access level for the conversation
	 */
	access?: "read-write" | "read-only";
	/**
	 * Category of the conversation
	 */
	category?: string;
	/**
	 * Whether the conversation is archived
	 */
	archived?: boolean;
	/**
	 * Timestamp of last read (Unix milliseconds)
	 */
	lastReadAt?: bigint;
	/**
	 * Whether the conversation is muted
	 */
	muted?: boolean;
	/**
	 * Whether the conversation is manually marked as unread
	 */
	manuallyMarkedUnread?: boolean;
	/**
	 * Whether the conversation is pinned
	 */
	pinned?: boolean;
	/**
	 * Number of unread messages
	 */
	unreadCount?: number;
	/**
	 * Number of unread mentions
	 */
	unreadMentionsCount?: number;
	/**
	 * The other participant in a 1:1 conversation
	 */
	counterParty?: User;
	/**
	 * Tag associated with the conversation
	 */
	tag?: string;
};

export type DirectCastConversation = {
	/**
	 * Unique identifier for the conversation
	 */
	conversationId: string;
	/**
	 * Name of the conversation (for group conversations)
	 */
	name?: string;
	/**
	 * Description of the conversation
	 */
	description?: string;
	/**
	 * URL of the conversation photo
	 */
	photoUrl?: string;
	/**
	 * List of admin Farcaster IDs
	 */
	adminFids: Array<number>;
	/**
	 * List of removed Farcaster IDs
	 */
	removedFids?: Array<number>;
	/**
	 * List of conversation participants
	 */
	participants?: Array<User>;
	/**
	 * Timestamp of last read time (Unix milliseconds)
	 */
	lastReadTime: bigint;
	/**
	 * Timestamp of viewer's last read time (Unix milliseconds)
	 */
	selfLastReadTime?: bigint;
	/**
	 * List of pinned messages in the conversation
	 */
	pinnedMessages?: Array<DirectCastMessage>;
	/**
	 * Whether the conversation has pinned messages
	 */
	hasPinnedMessages?: boolean;
	/**
	 * Whether this is a group conversation
	 */
	isGroup: boolean;
	/**
	 * Whether the conversation is collection token gated
	 */
	isCollectionTokenGated?: boolean;
	/**
	 * Number of active participants in the conversation
	 */
	activeParticipantsCount?: number;
	/**
	 * Message time-to-live in days, or "Infinity" for no expiration
	 */
	messageTTLDays?: number | "Infinity";
	/**
	 * Timestamp when conversation was created (Unix milliseconds)
	 */
	createdAt: bigint;
	/**
	 * Number of unread messages
	 */
	unreadCount?: number;
	/**
	 * Whether the conversation is muted
	 */
	muted?: boolean;
	/**
	 * Whether the conversation has mentions
	 */
	hasMention?: boolean;
	lastMessage?: DirectCastMessage;
	viewerContext: DirectCastConversationViewerContext;
};

export type DirectCastInboxResult = {
	/**
	 * Whether user has archived conversations
	 */
	hasArchived: boolean;
	/**
	 * Whether user has unread conversation requests
	 */
	hasUnreadRequests: boolean;
	/**
	 * Total number of conversation requests
	 */
	requestsCount: number;
	conversations: Array<DirectCastConversation>;
};

export type DirectCastInboxResponse = {
	result: DirectCastInboxResult;
	next?: {
		/**
		 * Base64 encoded cursor for pagination
		 */
		cursor: string;
	};
};

export type CastAction = {
	id?: string;
	name?: string;
	octicon?: string;
	actionUrl?: string;
	action?: {
		actionType?: string;
		postUrl?: string;
	};
};

export type UserAppContextResponse = {
	result?: {
		context?: {
			canAddLinks?: boolean;
			showConnectedApps?: boolean;
			signerRequestsEnabled?: boolean;
			prompts?: Array<unknown>;
			adminForChannelKeys?: Array<string>;
			modOfChannelKeys?: Array<string>;
			memberOfChannelKeys?: Array<string>;
			canEditAllChannels?: boolean;
			canUploadVideo?: boolean;
			statsigEnabled?: boolean;
			shouldPromptForPushNotifications?: boolean;
			shouldPromptForUserFollowsSyncContacts?: boolean;
			castActions?: Array<CastAction>;
			canAddCastAction?: boolean;
			enabledCastAction?: CastAction;
			notificationTabsV2?: Array<{
				id?: string;
				name?: string;
			}>;
			enabledVideoAutoplay?: boolean;
			regularCastByteLimit?: number;
			longCastByteLimit?: number;
			newUserStatus?: {
				[key: string]: unknown;
			};
			country?: string;
			higherClientEventSamplingRateEnabled?: boolean;
		};
	};
};

export type UserPreferencesResponse = {
	result?: {
		preferences?: {
			[key: string]: unknown;
		};
	};
};

export type Channel = {
	type?: string;
	key?: string;
	name?: string;
	imageUrl?: string;
	fastImageUrl?: string;
	feeds?: Array<{
		name?: string;
		type?: string;
	}>;
	description?: string;
	followerCount?: number;
	memberCount?: number;
	showCastSourceLabels?: boolean;
	showCastTags?: boolean;
	sectionRank?: number;
	subscribable?: boolean;
	publicCasting?: boolean;
	inviteCode?: string;
	headerImageUrl?: string;
	headerAction?: {
		title?: string;
		target?: string;
	};
	headerActionMetadata?: {
		[key: string]: unknown;
	};
	viewerContext?: {
		following?: boolean;
		isMember?: boolean;
		hasUnseenItems?: boolean;
		favoritePosition?: number;
		activityRank?: number;
		canCast?: boolean;
	};
};

export type HighlightedChannelsResponse = {
	result?: {
		channels?: Array<Channel>;
		viewerContext?: {
			defaultFeed?: string;
		};
	};
};

export type FeedItemsResponse = {
	result?: {
		items?: Array<{
			[key: string]: unknown;
		}>;
		latestMainCastTimestamp?: number;
		feedTopSeenAtTimestamp?: number;
		replaceFeed?: boolean;
	};
};

export type GenericResponse = {
	result: {
		[key: string]: unknown;
	};
};

export type UserResponse = GenericResponse & {
	result?: {
		user?: UserWithExtras;
		collectionsOwned?: Array<{
			[key: string]: unknown;
		}>;
		extras?: UserExtras;
	};
};

export type PaginationCursor = {
	/**
	 * Base64 encoded cursor for pagination
	 */
	cursor?: string;
	[key: string]: unknown | string | undefined;
};

export type PaginatedResponse = {
	result: {
		[key: string]: unknown;
	};
	next?: PaginationCursor;
};

export type SuggestedUsersResponse = PaginatedResponse & {
	result?: {
		users?: Array<{
			[key: string]: unknown;
		}>;
	};
};

export type FavoriteFramesResponse = {
	result: {
		frames: Array<{
			[key: string]: unknown;
		}>;
	};
};

export type ChannelStreaksResponse = {
	result: {
		[key: string]: unknown;
	};
};

export type UnseenCountsResponse = {
	result: {
		notificationsCount?: number;
		notificationTabs?: Array<{
			tab: string;
			unseenCount: number;
		}>;
		inboxCount?: number;
		channelFeeds?: Array<{
			channelKey: string;
			feedType: string;
			hasNewItems: boolean;
		}>;
		warpTransactionCount?: number;
	};
};

export type UserThreadCastsResponse = {
	result: {
		casts: Array<{
			[key: string]: unknown;
		}>;
	};
};

export type ChannelFollowersYouKnowResponse = {
	result: {
		users: Array<{
			[key: string]: unknown;
		}>;
		totalCount: number;
	};
};

export type SuccessResponse = {
	result: {
		/**
		 * Indicates whether the operation was successful
		 */
		success: boolean;
	};
};

export type NotificationsResponse = {
	result: {
		notifications?: Array<{
			[key: string]: unknown;
		}>;
	};
};

export type DirectCastConversationResponse = GenericResponse & {
	result?: {
		conversation: DirectCastConversation;
	};
};

export type DirectCastConversationCategorizationRequest = {
	/**
	 * ID of the conversation to categorize
	 */
	conversationId: string;
	/**
	 * Category to assign to the conversation
	 */
	category: string;
};

export type CommonSuccessResponse = GenericResponse & {
	result?: {
		/**
		 * Whether the operation was successful
		 */
		success: boolean;
	};
};

export type DirectCastConversationMessagesResponse = PaginatedResponse & {
	result?: {
		messages: Array<DirectCastMessage>;
	};
};

export type DirectCastConversationMessageTtlRequest = {
	/**
	 * ID of the conversation to set message TTL for
	 */
	conversationId: string;
	/**
	 * Time to live for messages in days
	 */
	ttl: number;
};

export type DirectCastConversationNotificationsRequest = {
	/**
	 * ID of the conversation to update notification settings for
	 */
	conversationId: string;
	/**
	 * Whether to mute notifications for this conversation
	 */
	muted: boolean;
};

export type DirectCastSendRequest = {
	/**
	 * ID of the conversation to send the message to
	 */
	conversationId: string;
	/**
	 * Array of Farcaster IDs of message recipients
	 */
	recipientFids: Array<number>;
	/**
	 * Unique identifier for the message
	 */
	messageId: string;
	/**
	 * Type of the message
	 */
	type: "text" | "image" | "reaction" | "link";
	/**
	 * Content of the message
	 */
	message: string;
	/**
	 * ID of the message this is replying to (optional)
	 */
	inReplyToId?: string;
};

export type DirectCastManuallyMarkUnreadRequest = {
	/**
	 * ID of the conversation to mark as unread
	 */
	conversationId: string;
};

export type DirectCastMessageReactionRequest = {
	/**
	 * ID of the conversation containing the message
	 */
	conversationId: string;
	/**
	 * ID of the message to react to
	 */
	messageId: string;
	/**
	 * Emoji reaction to add or remove
	 */
	reaction: string;
};

export type DirectCastPinConversationRequest = {
	/**
	 * ID of the conversation to pin
	 */
	conversationId: string;
};

export type DiscoverChannelsResponse = GenericResponse & {
	result?: {
		channels?: Array<{
			[key: string]: unknown;
		}>;
	};
};

export type InvitesAvailableResponse = GenericResponse & {
	result?: {
		/**
		 * Total number of invites allocated to the user
		 */
		allocatedInvitesCount: number;
		/**
		 * Number of invites currently available to send
		 */
		availableInvitesCount: number;
	};
};

export type SponsoredInvitesResponse = GenericResponse & {
	result?: {
		invites?: Array<{
			[key: string]: unknown;
		}>;
	};
	[key: string]:
		| unknown
		| {
				invites?: Array<{
					[key: string]: unknown;
				}>;
		  }
		| undefined;
};

export type RewardsLeaderboardResponse = {
	result: {
		leaderboard: {
			type: string;
			users: Array<{
				user?: {
					[key: string]: unknown;
				};
				score?: number;
				rank?: number;
			}>;
		};
	};
};

export type RewardsScoresResponse = {
	result: {
		scores: Array<{
			type?: string;
			user?: {
				[key: string]: unknown;
			};
			allTimeScore?: number;
			currentPeriodScore?: number;
			previousPeriodScore?: number;
		}>;
	};
};

export type RewardsMetadataResponse = {
	result: {
		metadata?: {
			type?: string;
			lastUpdateTimestamp?: number;
			currentPeriodStartTimestamp?: number;
			currentPeriodEndTimestamp?: number;
			tiers?: Array<{
				[key: string]: unknown;
			}>;
			proportionalPayout?: {
				numWinners?: number;
				totalRewardCents?: number;
			};
		};
	};
};

export type BookmarkedCast = {
	[key: string]: unknown;
};

export type BookmarkedCastsResponse = {
	result: {
		bookmarks?: Array<BookmarkedCast>;
	};
};

export type StarterPack = {
	[key: string]: unknown;
};

export type StarterPacksResponse = {
	result: {
		starterPacks?: Array<StarterPack>;
	};
};

export type StarterPackResponse = {
	result: {
		starterPack?: StarterPack;
	};
};

export type StarterPackUsersResponse = {
	result: {
		users?: Array<User>;
	};
};

export type ChannelResponse = {
	result: {
		channel?: Channel;
	};
};

export type ChannelUsersResponse = {
	result: {
		users?: Array<User>;
	};
};

export type UsersResponse = {
	result: {
		users: Array<User>;
	};
};

export type UsersWithCountResponse = {
	result: {
		users: Array<User>;
		totalCount: number;
	};
};

export type FrameApp = {
	[key: string]: unknown;
};

export type FrameAppsResponse = {
	result?: {
		frames?: Array<FrameApp>;
	};
};

/**
 * Context information for the viewer
 */
export type MiniAppViewerContext = {
	[key: string]: unknown;
};

export type MiniApp = {
	/**
	 * The domain of the mini app
	 */
	domain?: string;
	/**
	 * The name of the mini app
	 */
	name?: string;
	/**
	 * URL to the mini app's icon
	 */
	iconUrl?: string;
	/**
	 * The home URL of the mini app
	 */
	homeUrl?: string;
	author?: User;
	/**
	 * Whether the mini app supports notifications
	 */
	supportsNotifications?: boolean;
	/**
	 * Unique identifier for the mini app
	 */
	id?: string;
	/**
	 * Short identifier for the mini app
	 */
	shortId?: string;
	/**
	 * URL to the mini app's main image
	 */
	imageUrl?: string;
	/**
	 * Title for the action button
	 */
	buttonTitle?: string;
	/**
	 * URL to the splash screen image
	 */
	splashImageUrl?: string;
	/**
	 * Background color for the splash screen
	 */
	splashBackgroundColor?: string;
	/**
	 * URL for sharing casts
	 */
	castShareUrl?: string;
	/**
	 * Subtitle of the mini app
	 */
	subtitle?: string;
	/**
	 * Description of the mini app
	 */
	description?: string;
	/**
	 * Tagline of the mini app
	 */
	tagline?: string;
	/**
	 * URL to the hero image
	 */
	heroImageUrl?: string;
	/**
	 * Primary category of the mini app
	 */
	primaryCategory?: string;
	/**
	 * Tags associated with the mini app
	 */
	tags?: Array<string>;
	/**
	 * URLs to screenshot images
	 */
	screenshotUrls?: Array<string>;
	/**
	 * Whether the mini app should be indexed
	 */
	noindex?: boolean;
	/**
	 * Open Graph title
	 */
	ogTitle?: string;
	/**
	 * Open Graph description
	 */
	ogDescription?: string;
	/**
	 * Open Graph image URL
	 */
	ogImageUrl?: string;
	/**
	 * Required capabilities for the mini app
	 */
	requiredCapabilities?: Array<string>;
	/**
	 * Required blockchain chains
	 */
	requiredChains?: Array<string>;
	viewerContext?: MiniAppViewerContext;
};

export type RankedMiniApp = {
	/**
	 * Current rank of the mini app
	 */
	rank?: number;
	miniApp?: MiniApp;
	/**
	 * Change in rank over the last 72 hours
	 */
	rank72hChange?: number;
};

export type TopMiniAppsResponsePaginationCursor = {
	/**
	 * Base64 encoded cursor for pagination
	 */
	cursor?: string;
};

export type TopMiniAppsResponse = {
	result?: {
		miniApps?: Array<RankedMiniApp>;
		next?: TopMiniAppsResponsePaginationCursor;
	};
};

export type VerifiedAddress = {
	fid?: number;
	address?: string;
	timestamp?: number;
	version?: string;
	protocol?: string;
	isPrimary?: boolean;
	labels?: Array<string>;
};

export type MutedKeywordProperties = {
	channels?: boolean;
	frames?: boolean;
	notifications?: boolean;
};

export type MutedKeyword = {
	keyword: string;
	properties: MutedKeywordProperties;
};

export type MutedKeywordsResponse = {
	success: boolean;
	result: {
		keywords: Array<string>;
		mutedKeywords: Array<MutedKeyword>;
	};
};

export type CastHashResponse = {
	result: {
		castHash?: string;
	};
};

export type AttachEmbedsResponse = {
	result: {
		[key: string]: unknown;
	};
};

export type CastRecastersResponse = {
	result: {
		users?: Array<User>;
	};
};

export type CastQuote = {
	hash?: string;
	threadHash?: string;
	parentSource?: {
		type?: string;
		url?: string;
	};
	author?: User;
	text?: string;
	timestamp?: number;
};

export type CastQuotesResponse = {
	result: {
		quotes?: Array<CastQuote>;
	};
};

export type UserResponseUserResponse = {
	result?: {
		user?: User;
	};
};

export type SearchChannelsResponse = {
	result?: {
		channels?: Array<Channel>;
	};
};

export type DraftsResponse = {
	result?: {
		drafts?: Array<unknown>;
	};
};

export type DraftCast = {
	text?: string;
	embeds?: Array<unknown>;
};

export type Draft = {
	draftId?: string;
	casts?: Array<DraftCast>;
};

export type DraftCreatedResponse = {
	result?: {
		draft?: Draft;
	};
};

export type ImageEmbed = {
	type?: "image";
	url?: string;
	sourceUrl?: string;
	media?: {
		version?: string;
		width?: number;
		height?: number;
		staticRaster?: string;
		mimeType?: string;
	};
	alt?: string;
};

export type UrlEmbed = {
	type?: "url";
	openGraph?: {
		url?: string;
		sourceUrl?: string;
		title?: string;
		description?: string;
		domain?: string;
		image?: string;
		useLargeImage?: boolean;
	};
};

export type VideoEmbed = {
	type?: "video";
};

export type Recaster = {
	fid?: number;
	username?: string;
	displayName?: string;
	recastHash?: string;
};

export type Cast = {
	/**
	 * Unique hash identifier for the cast
	 */
	hash?: string;
	/**
	 * Hash identifier for the thread this cast belongs to
	 */
	threadHash?: string;
	/**
	 * Hash identifier of the parent cast (if this is a reply)
	 */
	parentHash?: string;
	parentSource?: {
		type?: "url";
		url?: string;
	};
	author?: User;
	/**
	 * The text content of the cast
	 */
	text?: string;
	/**
	 * Unix timestamp in milliseconds
	 */
	timestamp?: bigint;
	mentions?: Array<User>;
	embeds?: {
		images?: Array<ImageEmbed>;
		urls?: Array<UrlEmbed>;
		videos?: Array<VideoEmbed>;
		unknowns?: Array<{
			[key: string]: unknown;
		}>;
		processedCastText?: string;
		groupInvites?: Array<{
			[key: string]: unknown;
		}>;
	};
	replies?: {
		count?: number;
	};
	reactions?: {
		count?: number;
	};
	recasts?: {
		count?: number;
		recasters?: Array<Recaster>;
	};
	watches?: {
		count?: number;
	};
	recast?: boolean;
	tags?: Array<{
		type?: string;
		id?: string;
		name?: string;
		imageUrl?: string;
	}>;
	quoteCount?: number;
	combinedRecastCount?: number;
	channel?: {
		key?: string;
		name?: string;
		imageUrl?: string;
		authorContext?: {
			role?: string;
			restricted?: boolean;
			banned?: boolean;
		};
		authorRole?: string;
	};
	viewerContext?: {
		reacted?: boolean;
		recast?: boolean;
		bookmarked?: boolean;
	};
};

export type CastCreatedResponse = {
	result?: {
		cast?: Cast;
	};
};

export type RawChannel = {
	id?: string;
	url?: string;
	name?: string;
	description?: string;
	descriptionMentions?: Array<number>;
	descriptionMentionsPositions?: Array<number>;
	imageUrl?: string;
	headerImageUrl?: string;
	leadFid?: number;
	moderatorFids?: Array<number>;
	createdAt?: number;
	followerCount?: number;
	memberCount?: number;
	pinnedCastHash?: string;
	publicCasting?: boolean;
	externalLink?: {
		title?: string;
		url?: string;
	};
};

export type ChannelListResponse = {
	result?: {
		channels?: Array<RawChannel>;
	};
};

export type RawChannelResponse = {
	result?: {
		channel?: RawChannel;
	};
};

export type ChannelFollower = {
	fid?: number;
	followedAt?: number;
};

export type ChannelFollowersResponse = PaginatedResponse & {
	result?: {
		users?: Array<ChannelFollower>;
	};
};

export type ChannelFollowStatus = {
	following?: boolean;
	followedAt?: number;
};

export type ChannelFollowStatusResponse = {
	result?: ChannelFollowStatus;
};

export type Action = {
	name?: string;
	icon?: string;
	description?: string;
	aboutUrl?: string;
	imageUrl?: string;
	actionUrl?: string;
	action?: {
		actionType?: "post" | "get" | "put" | "delete";
		postUrl?: string;
	};
};

export type Winner = {
	/**
	 * The fid of the winner
	 */
	fid?: number;
	/**
	 * The domain of the winner
	 */
	domain?: string;
	/**
	 * The name of the frame (mini app)
	 */
	frameName?: string;
	/**
	 * The score of the winner
	 */
	score?: number;
	/**
	 * The rank of the winner
	 */
	rank?: number;
	/**
	 * The reward amount in cents
	 */
	rewardCents?: number;
	/**
	 * The wallet address of the winner (optional)
	 */
	walletAddress?: string;
};

export type Frame = {
	domain?: string;
	name?: string;
	iconUrl?: string;
	homeUrl?: string;
	splashImageUrl?: string;
	splashBackgroundColor?: string;
	buttonTitle?: string | null;
	imageUrl?: string | null;
	supportsNotifications?: boolean;
	viewerContext?: {
		[key: string]: unknown;
	};
	author?: User;
};

export type AppsByAuthorResponse = {
	result?: {
		frames?: Array<Frame>;
	};
};

export type ApiKey = {
	/**
	 * Unique identifier for the API key
	 */
	id: string;
	/**
	 * Timestamp when the API key was created (in milliseconds since epoch)
	 */
	createdAt: bigint;
	/**
	 * Timestamp when the API key expires (in milliseconds since epoch)
	 */
	expiresAt: bigint;
	/**
	 * Timestamp when the API key was revoked, if applicable (in milliseconds since epoch)
	 */
	revokedAt?: string | null;
	/**
	 * Short identifier tag for the API key
	 */
	tag: string;
	/**
	 * User-provided description of the API key's purpose
	 */
	description: string;
};

export type DirectCastSendResponse = CommonSuccessResponse;

export type DirectCastConversationCategorizationResponse =
	CommonSuccessResponse;

export type DirectCastConversationNotificationsResponse = CommonSuccessResponse;

export type DirectCastConversationMessageTtlResponse = CommonSuccessResponse;

export type DirectCastMessageReactionResponse = CommonSuccessResponse;

/**
 * The user's FID (Farcaster ID)
 */
export type FidParam = number;

/**
 * Maximum number of items to return
 */
export type LimitParam = number;

/**
 * Base64 encoded cursor for pagination
 */
export type CursorParam = string;

export type GetUserOnboardingStateData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v2/onboarding-state";
};

export type GetUserOnboardingStateErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetUserOnboardingStateError =
	GetUserOnboardingStateErrors[keyof GetUserOnboardingStateErrors];

export type GetUserOnboardingStateResponses = {
	/**
	 * Successful retrieval of onboarding state
	 */
	200: OnboardingStateResponse;
};

export type GetUserOnboardingStateResponse =
	GetUserOnboardingStateResponses[keyof GetUserOnboardingStateResponses];

export type GetUserByFidData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The user's FID (Farcaster ID)
		 */
		fid: number;
	};
	url: "/v2/user-by-fid";
};

export type GetUserByFidErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * The specified resource was not found
	 */
	404: ErrorResponse;
};

export type GetUserByFidError = GetUserByFidErrors[keyof GetUserByFidErrors];

export type GetUserByFidResponses = {
	/**
	 * Successful retrieval of user by fid
	 */
	200: UserByFidResponse;
};

export type GetUserByFidResponse =
	GetUserByFidResponses[keyof GetUserByFidResponses];

export type GetDirectCastInboxData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
		/**
		 * Category of conversations to retrieve
		 */
		category?: "default" | "requests" | "spam";
		/**
		 * Filter for conversations (e.g., unread, all)
		 */
		filter?: "unread" | "group" | "1-1";
		/**
		 * Base64 encoded cursor from previous response
		 */
		cursor?: string;
	};
	url: "/v2/direct-cast-inbox";
};

export type GetDirectCastInboxErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetDirectCastInboxError =
	GetDirectCastInboxErrors[keyof GetDirectCastInboxErrors];

export type GetDirectCastInboxResponses = {
	/**
	 * Successful retrieval of direct cast inbox
	 */
	200: DirectCastInboxResponse;
};

export type GetDirectCastInboxResponse =
	GetDirectCastInboxResponses[keyof GetDirectCastInboxResponses];

export type GetUserAppContextData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v2/user-app-context";
};

export type GetUserAppContextErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetUserAppContextError =
	GetUserAppContextErrors[keyof GetUserAppContextErrors];

export type GetUserAppContextResponses = {
	/**
	 * Successful retrieval of user app context
	 */
	200: UserAppContextResponse;
};

export type GetUserAppContextResponse =
	GetUserAppContextResponses[keyof GetUserAppContextResponses];

export type GetUserPreferencesData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v2/user-preferences";
};

export type GetUserPreferencesErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetUserPreferencesError =
	GetUserPreferencesErrors[keyof GetUserPreferencesErrors];

export type GetUserPreferencesResponses = {
	/**
	 * Successful retrieval of user preferences
	 */
	200: UserPreferencesResponse;
};

export type GetUserPreferencesResponse =
	GetUserPreferencesResponses[keyof GetUserPreferencesResponses];

export type GetHighlightedChannelsData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v2/highlighted-channels";
};

export type GetHighlightedChannelsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetHighlightedChannelsError =
	GetHighlightedChannelsErrors[keyof GetHighlightedChannelsErrors];

export type GetHighlightedChannelsResponses = {
	/**
	 * Successful retrieval of highlighted channels
	 */
	200: HighlightedChannelsResponse;
};

export type GetHighlightedChannelsResponse =
	GetHighlightedChannelsResponses[keyof GetHighlightedChannelsResponses];

export type GetFeedItemsData = {
	body: {
		/**
		 * Identifier for the specific feed
		 */
		feedKey: string;
		/**
		 * Type of feed to retrieve
		 */
		feedType: string;
		/**
		 * View events for casts
		 */
		castViewEvents?: Array<{
			[key: string]: unknown;
		}>;
		/**
		 * Whether to update the feed state
		 */
		updateState?: boolean;
	};
	path?: never;
	query?: never;
	url: "/v2/feed-items";
};

export type GetFeedItemsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetFeedItemsError = GetFeedItemsErrors[keyof GetFeedItemsErrors];

export type GetFeedItemsResponses = {
	/**
	 * Successful retrieval of feed items
	 */
	200: FeedItemsResponse;
};

export type GetFeedItemsResponse =
	GetFeedItemsResponses[keyof GetFeedItemsResponses];

export type GetUserData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The user's FID (Farcaster ID)
		 */
		fid: number;
	};
	url: "/v2/user";
};

export type GetUserErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * The specified resource was not found
	 */
	404: ErrorResponse;
};

export type GetUserError = GetUserErrors[keyof GetUserErrors];

export type GetUserResponses = {
	/**
	 * Successful retrieval of user information
	 */
	200: UserResponse;
};

export type GetUserResponse = GetUserResponses[keyof GetUserResponses];

export type GetUserFollowingChannelsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Whether results are intended for the composer interface
		 */
		forComposer?: boolean;
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
	};
	url: "/v2/user-following-channels";
};

export type GetUserFollowingChannelsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetUserFollowingChannelsError =
	GetUserFollowingChannelsErrors[keyof GetUserFollowingChannelsErrors];

export type GetUserFollowingChannelsResponses = {
	/**
	 * Successful retrieval of followed channels
	 */
	200: HighlightedChannelsResponse;
};

export type GetUserFollowingChannelsResponse =
	GetUserFollowingChannelsResponses[keyof GetUserFollowingChannelsResponses];

export type GetSuggestedUsersData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
		randomized?: boolean;
	};
	url: "/v2/suggested-users";
};

export type GetSuggestedUsersErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetSuggestedUsersError =
	GetSuggestedUsersErrors[keyof GetSuggestedUsersErrors];

export type GetSuggestedUsersResponses = {
	/**
	 * Successful retrieval of suggested users
	 */
	200: SuggestedUsersResponse;
};

export type GetSuggestedUsersResponse =
	GetSuggestedUsersResponses[keyof GetSuggestedUsersResponses];

export type GetUserFavoriteFramesData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
	};
	url: "/v1/favorite-frames";
};

export type GetUserFavoriteFramesErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetUserFavoriteFramesError =
	GetUserFavoriteFramesErrors[keyof GetUserFavoriteFramesErrors];

export type GetUserFavoriteFramesResponses = {
	/**
	 * Successful retrieval of favorite frames
	 */
	200: FavoriteFramesResponse;
};

export type GetUserFavoriteFramesResponse =
	GetUserFavoriteFramesResponses[keyof GetUserFavoriteFramesResponses];

export type GetUserByUsernameData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The username to look up
		 */
		username: string;
	};
	url: "/v2/user-by-username";
};

export type GetUserByUsernameErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * The specified resource was not found
	 */
	404: ErrorResponse;
};

export type GetUserByUsernameError =
	GetUserByUsernameErrors[keyof GetUserByUsernameErrors];

export type GetUserByUsernameResponses = {
	/**
	 * Successful retrieval of user by username
	 */
	200: UserByFidResponse;
};

export type GetUserByUsernameResponse =
	GetUserByUsernameResponses[keyof GetUserByUsernameResponses];

export type GetChannelStreaksForUserData = {
	body?: never;
	path?: never;
	query: {
		fid: number;
	};
	url: "/v2/channel-streaks";
};

export type GetChannelStreaksForUserErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetChannelStreaksForUserError =
	GetChannelStreaksForUserErrors[keyof GetChannelStreaksForUserErrors];

export type GetChannelStreaksForUserResponses = {
	/**
	 * Successful retrieval of channel streaks
	 */
	200: ChannelStreaksResponse;
};

export type GetChannelStreaksForUserResponse =
	GetChannelStreaksForUserResponses[keyof GetChannelStreaksForUserResponses];

export type GetUnseenCountsData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v2/unseen";
};

export type GetUnseenCountsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetUnseenCountsError =
	GetUnseenCountsErrors[keyof GetUnseenCountsErrors];

export type GetUnseenCountsResponses = {
	/**
	 * Successful retrieval of unseen feed and notification data
	 */
	200: UnseenCountsResponse;
};

export type GetUnseenCountsResponse =
	GetUnseenCountsResponses[keyof GetUnseenCountsResponses];

export type GetUserThreadCastsData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
		/**
		 * The hash prefix of the cast
		 */
		castHashPrefix: string;
		/**
		 * The username of the user
		 */
		username: string;
	};
	url: "/v2/user-thread-casts";
};

export type GetUserThreadCastsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetUserThreadCastsError =
	GetUserThreadCastsErrors[keyof GetUserThreadCastsErrors];

export type GetUserThreadCastsResponses = {
	/**
	 * Successful retrieval of user thread casts
	 */
	200: UserThreadCastsResponse;
};

export type GetUserThreadCastsResponse =
	GetUserThreadCastsResponses[keyof GetUserThreadCastsResponses];

export type GetChannelFollowersYouKnowData = {
	body?: never;
	path?: never;
	query: {
		channelKey: string;
		limit?: number;
	};
	url: "/v2/channel-followers-you-know";
};

export type GetChannelFollowersYouKnowErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetChannelFollowersYouKnowError =
	GetChannelFollowersYouKnowErrors[keyof GetChannelFollowersYouKnowErrors];

export type GetChannelFollowersYouKnowResponses = {
	/**
	 * Successful retrieval of known channel followers
	 */
	200: ChannelFollowersYouKnowResponse;
};

export type GetChannelFollowersYouKnowResponse =
	GetChannelFollowersYouKnowResponses[keyof GetChannelFollowersYouKnowResponses];

export type MarkAllNotificationsReadData = {
	body: {
		[key: string]: never;
	};
	path?: never;
	query?: never;
	url: "/v2/mark-all-notifications-read";
};

export type MarkAllNotificationsReadErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type MarkAllNotificationsReadError =
	MarkAllNotificationsReadErrors[keyof MarkAllNotificationsReadErrors];

export type MarkAllNotificationsReadResponses = {
	/**
	 * Successful mark-all-read operation
	 */
	200: SuccessResponse;
};

export type MarkAllNotificationsReadResponse =
	MarkAllNotificationsReadResponses[keyof MarkAllNotificationsReadResponses];

export type GetNotificationsData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * Notification tab type
		 */
		tab: "all" | "follows" | "reactions" | "mentions" | "replies";
		/**
		 * Number of notifications to return
		 */
		limit?: number;
	};
	url: "/v1/notifications-for-tab";
};

export type GetNotificationsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type GetNotificationsError =
	GetNotificationsErrors[keyof GetNotificationsErrors];

export type GetNotificationsResponses = {
	/**
	 * A list of notifications
	 */
	200: NotificationsResponse;
};

export type GetNotificationsResponse =
	GetNotificationsResponses[keyof GetNotificationsResponses];

export type SetLastCheckedTimestampData = {
	/**
	 * Empty object for now
	 */
	body: {
		[key: string]: unknown;
	};
	path?: never;
	query?: never;
	url: "/v2/set-last-checked-timestamp";
};

export type SetLastCheckedTimestampErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type SetLastCheckedTimestampError =
	SetLastCheckedTimestampErrors[keyof SetLastCheckedTimestampErrors];

export type SetLastCheckedTimestampResponses = {
	/**
	 * Success
	 */
	200: SuccessResponse;
};

export type SetLastCheckedTimestampResponse =
	SetLastCheckedTimestampResponses[keyof SetLastCheckedTimestampResponses];

export type GetDirectCastConversationData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * Conversation ID. Format depends on conversation type:
		 * - 1:1 conversations: "fid1-fid2" (e.g., "123-456")
		 * - Group conversations: Hash format (e.g., "a1b2c3d4e5f6...")
		 *
		 */
		conversationId: string;
	};
	url: "/v2/direct-cast-conversation";
};

export type GetDirectCastConversationErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type GetDirectCastConversationError =
	GetDirectCastConversationErrors[keyof GetDirectCastConversationErrors];

export type GetDirectCastConversationResponses = {
	/**
	 * A direct cast conversation object
	 */
	200: DirectCastConversationResponse;
};

export type GetDirectCastConversationResponse =
	GetDirectCastConversationResponses[keyof GetDirectCastConversationResponses];

export type CategorizeDirectCastConversationData = {
	body: DirectCastConversationCategorizationRequest;
	path?: never;
	query?: never;
	url: "/v2/direct-cast-conversation-categorization";
};

export type CategorizeDirectCastConversationErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type CategorizeDirectCastConversationError =
	CategorizeDirectCastConversationErrors[keyof CategorizeDirectCastConversationErrors];

export type CategorizeDirectCastConversationResponses = {
	/**
	 * Conversation categorized successfully
	 */
	200: CommonSuccessResponse;
};

export type CategorizeDirectCastConversationResponse =
	CategorizeDirectCastConversationResponses[keyof CategorizeDirectCastConversationResponses];

export type GetDirectCastConversationMessagesData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * Conversation ID. Format depends on conversation type:
		 * - 1:1 conversations: "fid1-fid2" (e.g., "123-456")
		 * - Group conversations: Hash format (e.g., "c9e139dcbc9423cf")
		 *
		 */
		conversationId: string;
		/**
		 * Maximum number of messages to return
		 */
		limit?: number;
	};
	url: "/v2/direct-cast-conversation-messages";
};

export type GetDirectCastConversationMessagesErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type GetDirectCastConversationMessagesError =
	GetDirectCastConversationMessagesErrors[keyof GetDirectCastConversationMessagesErrors];

export type GetDirectCastConversationMessagesResponses = {
	/**
	 * A list of direct cast conversation messages with pagination
	 */
	200: DirectCastConversationMessagesResponse;
};

export type GetDirectCastConversationMessagesResponse =
	GetDirectCastConversationMessagesResponses[keyof GetDirectCastConversationMessagesResponses];

export type SetDirectCastConversationMessageTtlData = {
	body: DirectCastConversationMessageTtlRequest;
	path?: never;
	query?: never;
	url: "/v2/direct-cast-conversation-message-ttl";
};

export type SetDirectCastConversationMessageTtlErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type SetDirectCastConversationMessageTtlError =
	SetDirectCastConversationMessageTtlErrors[keyof SetDirectCastConversationMessageTtlErrors];

export type SetDirectCastConversationMessageTtlResponses = {
	/**
	 * Message TTL set successfully
	 */
	200: CommonSuccessResponse;
};

export type SetDirectCastConversationMessageTtlResponse =
	SetDirectCastConversationMessageTtlResponses[keyof SetDirectCastConversationMessageTtlResponses];

export type UpdateDirectCastConversationNotificationsData = {
	body: DirectCastConversationNotificationsRequest;
	path?: never;
	query?: never;
	url: "/v2/direct-cast-conversation-notifications";
};

export type UpdateDirectCastConversationNotificationsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type UpdateDirectCastConversationNotificationsError =
	UpdateDirectCastConversationNotificationsErrors[keyof UpdateDirectCastConversationNotificationsErrors];

export type UpdateDirectCastConversationNotificationsResponses = {
	/**
	 * Notification settings updated successfully
	 */
	200: CommonSuccessResponse;
};

export type UpdateDirectCastConversationNotificationsResponse =
	UpdateDirectCastConversationNotificationsResponses[keyof UpdateDirectCastConversationNotificationsResponses];

export type GetDirectCastConversationRecentMessagesData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * Conversation ID. Format depends on conversation type:
		 * - 1:1 conversations: "fid1-fid2" (e.g., "123-456")
		 * - Group conversations: Hash format (e.g., "c9e139dcbc9423cf")
		 *
		 */
		conversationId: string;
	};
	url: "/v2/direct-cast-conversation-recent-messages";
};

export type GetDirectCastConversationRecentMessagesErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type GetDirectCastConversationRecentMessagesError =
	GetDirectCastConversationRecentMessagesErrors[keyof GetDirectCastConversationRecentMessagesErrors];

export type GetDirectCastConversationRecentMessagesResponses = {
	/**
	 * A list of recent direct cast conversation messages
	 */
	200: DirectCastConversationMessagesResponse;
};

export type GetDirectCastConversationRecentMessagesResponse =
	GetDirectCastConversationRecentMessagesResponses[keyof GetDirectCastConversationRecentMessagesResponses];

export type SendDirectCastMessageData = {
	body: DirectCastSendRequest;
	path?: never;
	query?: never;
	url: "/v2/direct-cast-send";
};

export type SendDirectCastMessageErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type SendDirectCastMessageError =
	SendDirectCastMessageErrors[keyof SendDirectCastMessageErrors];

export type SendDirectCastMessageResponses = {
	/**
	 * Direct cast message sent successfully
	 */
	200: CommonSuccessResponse;
};

export type SendDirectCastMessageResponse =
	SendDirectCastMessageResponses[keyof SendDirectCastMessageResponses];

export type DirectCastManuallyMarkUnreadData = {
	body: DirectCastManuallyMarkUnreadRequest;
	path?: never;
	query?: never;
	url: "/v2/direct-cast-manually-mark-unread";
};

export type DirectCastManuallyMarkUnreadErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type DirectCastManuallyMarkUnreadError =
	DirectCastManuallyMarkUnreadErrors[keyof DirectCastManuallyMarkUnreadErrors];

export type DirectCastManuallyMarkUnreadResponses = {
	/**
	 * Direct cast conversation marked as unread successfully
	 */
	200: CommonSuccessResponse;
};

export type DirectCastManuallyMarkUnreadResponse =
	DirectCastManuallyMarkUnreadResponses[keyof DirectCastManuallyMarkUnreadResponses];

export type RemoveDirectCastMessageReactionData = {
	body: DirectCastMessageReactionRequest;
	path?: never;
	query?: never;
	url: "/v2/direct-cast-message-reaction";
};

export type RemoveDirectCastMessageReactionErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type RemoveDirectCastMessageReactionError =
	RemoveDirectCastMessageReactionErrors[keyof RemoveDirectCastMessageReactionErrors];

export type RemoveDirectCastMessageReactionResponses = {
	/**
	 * Reaction removed successfully
	 */
	200: CommonSuccessResponse;
};

export type RemoveDirectCastMessageReactionResponse =
	RemoveDirectCastMessageReactionResponses[keyof RemoveDirectCastMessageReactionResponses];

export type AddDirectCastMessageReactionData = {
	body: DirectCastMessageReactionRequest;
	path?: never;
	query?: never;
	url: "/v2/direct-cast-message-reaction";
};

export type AddDirectCastMessageReactionErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type AddDirectCastMessageReactionError =
	AddDirectCastMessageReactionErrors[keyof AddDirectCastMessageReactionErrors];

export type AddDirectCastMessageReactionResponses = {
	/**
	 * Reaction added successfully
	 */
	200: CommonSuccessResponse;
};

export type AddDirectCastMessageReactionResponse =
	AddDirectCastMessageReactionResponses[keyof AddDirectCastMessageReactionResponses];

export type UnpinDirectCastConversationData = {
	body: DirectCastPinConversationRequest;
	path?: never;
	query?: never;
	url: "/v2/direct-cast-pin-conversation";
};

export type UnpinDirectCastConversationErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type UnpinDirectCastConversationError =
	UnpinDirectCastConversationErrors[keyof UnpinDirectCastConversationErrors];

export type UnpinDirectCastConversationResponses = {
	/**
	 * Direct cast conversation unpinned successfully
	 */
	200: CommonSuccessResponse;
};

export type UnpinDirectCastConversationResponse =
	UnpinDirectCastConversationResponses[keyof UnpinDirectCastConversationResponses];

export type PinDirectCastConversationData = {
	body: DirectCastPinConversationRequest;
	path?: never;
	query?: never;
	url: "/v2/direct-cast-pin-conversation";
};

export type PinDirectCastConversationErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type PinDirectCastConversationError =
	PinDirectCastConversationErrors[keyof PinDirectCastConversationErrors];

export type PinDirectCastConversationResponses = {
	/**
	 * Direct cast conversation pinned successfully
	 */
	200: CommonSuccessResponse;
};

export type PinDirectCastConversationResponse =
	PinDirectCastConversationResponses[keyof PinDirectCastConversationResponses];

export type DiscoverChannelsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Maximum number of channels to retrieve
		 */
		limit?: number;
	};
	url: "/v2/discover-channels";
};

export type DiscoverChannelsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type DiscoverChannelsError =
	DiscoverChannelsErrors[keyof DiscoverChannelsErrors];

export type DiscoverChannelsResponses = {
	/**
	 * A list of channels
	 */
	200: DiscoverChannelsResponse;
};

export type DiscoverChannelsResponse2 =
	DiscoverChannelsResponses[keyof DiscoverChannelsResponses];

export type GetAvailableInvitesData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v2/invites-available";
};

export type GetAvailableInvitesErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type GetAvailableInvitesError =
	GetAvailableInvitesErrors[keyof GetAvailableInvitesErrors];

export type GetAvailableInvitesResponses = {
	/**
	 * Invite count information
	 */
	200: InvitesAvailableResponse;
};

export type GetAvailableInvitesResponse =
	GetAvailableInvitesResponses[keyof GetAvailableInvitesResponses];

export type GetSponsoredInvitesData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v2/warpcast-sponsored-invites";
};

export type GetSponsoredInvitesErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type GetSponsoredInvitesError =
	GetSponsoredInvitesErrors[keyof GetSponsoredInvitesErrors];

export type GetSponsoredInvitesResponses = {
	/**
	 * List of sponsored invites
	 */
	200: SponsoredInvitesResponse;
};

export type GetSponsoredInvitesResponse =
	GetSponsoredInvitesResponses[keyof GetSponsoredInvitesResponses];

export type GetRewardsLeaderboardData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
		rewardsType: "invite";
		cursor?: string;
	};
	url: "/v2/rewards-leaderboard";
};

export type GetRewardsLeaderboardErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type GetRewardsLeaderboardError =
	GetRewardsLeaderboardErrors[keyof GetRewardsLeaderboardErrors];

export type GetRewardsLeaderboardResponses = {
	/**
	 * Rewards leaderboard
	 */
	200: RewardsLeaderboardResponse;
};

export type GetRewardsLeaderboardResponse =
	GetRewardsLeaderboardResponses[keyof GetRewardsLeaderboardResponses];

export type GetUserRewardsScoresData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The user's FID (Farcaster ID)
		 */
		fid: number;
		rewardsType: "invite";
	};
	url: "/v2/rewards-scores-for-user";
};

export type GetUserRewardsScoresErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type GetUserRewardsScoresError =
	GetUserRewardsScoresErrors[keyof GetUserRewardsScoresErrors];

export type GetUserRewardsScoresResponses = {
	/**
	 * User rewards scores
	 */
	200: RewardsScoresResponse;
};

export type GetUserRewardsScoresResponse =
	GetUserRewardsScoresResponses[keyof GetUserRewardsScoresResponses];

export type GetRewardsMetadataData = {
	body?: never;
	path?: never;
	query: {
		rewardsType: "invite";
	};
	url: "/v2/rewards-metadata";
};

export type GetRewardsMetadataErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Too many requests
	 */
	429: unknown;
};

export type GetRewardsMetadataError =
	GetRewardsMetadataErrors[keyof GetRewardsMetadataErrors];

export type GetRewardsMetadataResponses = {
	/**
	 * Invite rewards metadata
	 */
	200: RewardsMetadataResponse;
};

export type GetRewardsMetadataResponse =
	GetRewardsMetadataResponses[keyof GetRewardsMetadataResponses];

export type GetBookmarkedCastsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
	};
	url: "/v2/bookmarked-casts";
};

export type GetBookmarkedCastsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetBookmarkedCastsError =
	GetBookmarkedCastsErrors[keyof GetBookmarkedCastsErrors];

export type GetBookmarkedCastsResponses = {
	/**
	 * A list of bookmarked casts
	 */
	200: BookmarkedCastsResponse;
};

export type GetBookmarkedCastsResponse =
	GetBookmarkedCastsResponses[keyof GetBookmarkedCastsResponses];

export type GetUserStarterPacksData = {
	body?: never;
	path?: never;
	query: {
		fid: number;
		limit?: number;
	};
	url: "/v2/starter-packs";
};

export type GetUserStarterPacksErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetUserStarterPacksError =
	GetUserStarterPacksErrors[keyof GetUserStarterPacksErrors];

export type GetUserStarterPacksResponses = {
	/**
	 * A list of starter packs
	 */
	200: StarterPacksResponse;
};

export type GetUserStarterPacksResponse =
	GetUserStarterPacksResponses[keyof GetUserStarterPacksResponses];

export type GetSuggestedStarterPacksData = {
	body?: never;
	path?: never;
	query?: {
		limit?: number;
	};
	url: "/v2/starter-packs/suggested";
};

export type GetSuggestedStarterPacksErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetSuggestedStarterPacksError =
	GetSuggestedStarterPacksErrors[keyof GetSuggestedStarterPacksErrors];

export type GetSuggestedStarterPacksResponses = {
	/**
	 * A list of suggested starter packs
	 */
	200: StarterPacksResponse;
};

export type GetSuggestedStarterPacksResponse =
	GetSuggestedStarterPacksResponses[keyof GetSuggestedStarterPacksResponses];

export type GetStarterPackData = {
	body?: never;
	path?: never;
	query: {
		id: string;
	};
	url: "/v2/starter-pack";
};

export type GetStarterPackErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetStarterPackError =
	GetStarterPackErrors[keyof GetStarterPackErrors];

export type GetStarterPackResponses = {
	/**
	 * A starter pack object
	 */
	200: StarterPackResponse;
};

export type GetStarterPackResponse =
	GetStarterPackResponses[keyof GetStarterPackResponses];

export type GetStarterPackUsersData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
		id: string;
	};
	url: "/v2/starter-pack-users";
};

export type GetStarterPackUsersErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetStarterPackUsersError =
	GetStarterPackUsersErrors[keyof GetStarterPackUsersErrors];

export type GetStarterPackUsersResponses = {
	/**
	 * List of users in the starter pack
	 */
	200: StarterPackUsersResponse;
};

export type GetStarterPackUsersResponse =
	GetStarterPackUsersResponses[keyof GetStarterPackUsersResponses];

export type GetChannelData = {
	body?: never;
	path?: never;
	query: {
		key: string;
	};
	url: "/v2/channel";
};

export type GetChannelErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetChannelError = GetChannelErrors[keyof GetChannelErrors];

export type GetChannelResponses = {
	/**
	 * Channel metadata
	 */
	200: ChannelResponse;
};

export type GetChannelResponse = GetChannelResponses[keyof GetChannelResponses];

export type GetChannelUsersData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
		channelKey: string;
		filterToMembers?: boolean;
		query?: string;
	};
	url: "/v1/channel-users";
};

export type GetChannelUsersErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetChannelUsersError =
	GetChannelUsersErrors[keyof GetChannelUsersErrors];

export type GetChannelUsersResponses = {
	/**
	 * A list of users in the specified channel
	 */
	200: ChannelUsersResponse;
};

export type GetChannelUsersResponse =
	GetChannelUsersResponses[keyof GetChannelUsersResponses];

export type GetFollowingData = {
	body?: never;
	path?: never;
	query: {
		fid: number;
		limit?: number;
	};
	url: "/v2/following";
};

export type GetFollowingErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetFollowingError = GetFollowingErrors[keyof GetFollowingErrors];

export type GetFollowingResponses = {
	/**
	 * A list of followed users
	 */
	200: UsersResponse;
};

export type GetFollowingResponse =
	GetFollowingResponses[keyof GetFollowingResponses];

export type GetFollowersData = {
	body?: never;
	path?: never;
	query: {
		fid: number;
		limit?: number;
	};
	url: "/v2/followers";
};

export type GetFollowersErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetFollowersError = GetFollowersErrors[keyof GetFollowersErrors];

export type GetFollowersResponses = {
	/**
	 * A list of followers
	 */
	200: UsersResponse;
};

export type GetFollowersResponse =
	GetFollowersResponses[keyof GetFollowersResponses];

export type GetMutualFollowersData = {
	body?: never;
	path?: never;
	query: {
		fid: number;
		limit?: number;
	};
	url: "/v2/followers-you-know";
};

export type GetMutualFollowersErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetMutualFollowersError =
	GetMutualFollowersErrors[keyof GetMutualFollowersErrors];

export type GetMutualFollowersResponses = {
	/**
	 * A list of mutual followers
	 */
	200: UsersWithCountResponse;
};

export type GetMutualFollowersResponse =
	GetMutualFollowersResponses[keyof GetMutualFollowersResponses];

export type GetTopFrameAppsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
		cursor?: string;
	};
	url: "/v1/top-frameapps";
};

export type GetTopFrameAppsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetTopFrameAppsError =
	GetTopFrameAppsErrors[keyof GetTopFrameAppsErrors];

export type GetTopFrameAppsResponses = {
	/**
	 * A list of FrameApps
	 */
	200: FrameAppsResponse;
};

export type GetTopFrameAppsResponse =
	GetTopFrameAppsResponses[keyof GetTopFrameAppsResponses];

export type GetTopMiniAppsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
		/**
		 * Base64 encoded cursor for pagination
		 */
		cursor?: string;
	};
	url: "/v1/top-mini-apps";
};

export type GetTopMiniAppsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetTopMiniAppsError =
	GetTopMiniAppsErrors[keyof GetTopMiniAppsErrors];

export type GetTopMiniAppsResponses = {
	/**
	 * A list of top mini apps
	 */
	200: TopMiniAppsResponse;
};

export type GetTopMiniAppsResponse =
	GetTopMiniAppsResponses[keyof GetTopMiniAppsResponses];

export type GetVerificationsData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The user's FID (Farcaster ID)
		 */
		fid: number;
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
	};
	url: "/v2/verifications";
};

export type GetVerificationsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetVerificationsError =
	GetVerificationsErrors[keyof GetVerificationsErrors];

export type GetVerificationsResponses = {
	/**
	 * A list of verifications
	 */
	200: {
		result?: {
			verifications?: Array<VerifiedAddress>;
		};
	};
};

export type GetVerificationsResponse =
	GetVerificationsResponses[keyof GetVerificationsResponses];

export type GetMutedKeywordsData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v2/get-muted-keywords";
};

export type GetMutedKeywordsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetMutedKeywordsError =
	GetMutedKeywordsErrors[keyof GetMutedKeywordsErrors];

export type GetMutedKeywordsResponses = {
	/**
	 * A list of muted keywords
	 */
	200: MutedKeywordsResponse;
};

export type GetMutedKeywordsResponse =
	GetMutedKeywordsResponses[keyof GetMutedKeywordsResponses];

export type MuteKeywordData = {
	body: {
		keyword?: string;
		properties?: MutedKeywordProperties;
	};
	path?: never;
	query?: never;
	url: "/v2/mute-keyword";
};

export type MuteKeywordErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type MuteKeywordError = MuteKeywordErrors[keyof MuteKeywordErrors];

export type MuteKeywordResponses = {
	/**
	 * The muted keyword and its settings
	 */
	200: MutedKeywordsResponse;
};

export type MuteKeywordResponse =
	MuteKeywordResponses[keyof MuteKeywordResponses];

export type UnmuteKeywordData = {
	body: {
		keyword?: string;
	};
	path?: never;
	query?: never;
	url: "/v2/unmute-keyword";
};

export type UnmuteKeywordErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type UnmuteKeywordError = UnmuteKeywordErrors[keyof UnmuteKeywordErrors];

export type UnmuteKeywordResponses = {
	/**
	 * Keyword unmuted
	 */
	200: MutedKeywordsResponse;
};

export type UnmuteKeywordResponse =
	UnmuteKeywordResponses[keyof UnmuteKeywordResponses];

export type UnlikeCastData = {
	body: {
		castHash: string;
	};
	path?: never;
	query?: never;
	url: "/v2/cast-likes";
};

export type UnlikeCastErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type UnlikeCastError = UnlikeCastErrors[keyof UnlikeCastErrors];

export type UnlikeCastResponses = {
	/**
	 * Unlike response
	 */
	200: {
		result?: {
			success?: boolean;
		};
	};
};

export type UnlikeCastResponse = UnlikeCastResponses[keyof UnlikeCastResponses];

export type GetCastLikesData = {
	body?: never;
	path?: never;
	query: {
		castHash: string;
		limit?: number;
	};
	url: "/v2/cast-likes";
};

export type GetCastLikesErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetCastLikesError = GetCastLikesErrors[keyof GetCastLikesErrors];

export type GetCastLikesResponses = {
	/**
	 * A list of cast likes
	 */
	200: {
		result?: {
			likes?: Array<{
				type?: string;
				hash?: string;
				castHash?: string;
				timestamp?: number;
				reactor?: User;
			}>;
		};
	};
};

export type GetCastLikesResponse =
	GetCastLikesResponses[keyof GetCastLikesResponses];

export type LikeCastData = {
	body: {
		castHash: string;
	};
	path?: never;
	query?: never;
	url: "/v2/cast-likes";
};

export type LikeCastErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type LikeCastError = LikeCastErrors[keyof LikeCastErrors];

export type LikeCastResponses = {
	/**
	 * Like response
	 */
	200: {
		result?: {
			like?: {
				type?: string;
				hash?: string;
				castHash?: string;
				timestamp?: number;
				reactor?: User;
			};
		};
	};
};

export type LikeCastResponse = LikeCastResponses[keyof LikeCastResponses];

export type UndoRecastData = {
	body: {
		castHash: string;
	};
	path?: never;
	query?: never;
	url: "/v2/recasts";
};

export type UndoRecastErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type UndoRecastError = UndoRecastErrors[keyof UndoRecastErrors];

export type UndoRecastResponses = {
	/**
	 * Undo recast response
	 */
	200: SuccessResponse;
};

export type UndoRecastResponse = UndoRecastResponses[keyof UndoRecastResponses];

export type RecastCastData = {
	body: {
		castHash: string;
	};
	path?: never;
	query?: never;
	url: "/v2/recasts";
};

export type RecastCastErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type RecastCastError = RecastCastErrors[keyof RecastCastErrors];

export type RecastCastResponses = {
	/**
	 * Recast response
	 */
	200: CastHashResponse;
};

export type RecastCastResponse = RecastCastResponses[keyof RecastCastResponses];

export type AttachEmbedsData = {
	body: {
		text?: string;
		embeds?: Array<string>;
	};
	path?: never;
	query?: never;
	url: "/v2/cast-attachments";
};

export type AttachEmbedsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type AttachEmbedsError = AttachEmbedsErrors[keyof AttachEmbedsErrors];

export type AttachEmbedsResponses = {
	/**
	 * Attachment response
	 */
	200: AttachEmbedsResponse;
};

export type AttachEmbedsResponse2 =
	AttachEmbedsResponses[keyof AttachEmbedsResponses];

export type GetCastRecastersData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
		castHash: string;
	};
	url: "/v2/cast-recasters";
};

export type GetCastRecastersErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetCastRecastersError =
	GetCastRecastersErrors[keyof GetCastRecastersErrors];

export type GetCastRecastersResponses = {
	/**
	 * A list of users who recasted the cast
	 */
	200: CastRecastersResponse;
};

export type GetCastRecastersResponse =
	GetCastRecastersResponses[keyof GetCastRecastersResponses];

export type GetCastQuotesData = {
	body?: never;
	path?: never;
	query: {
		castHash: string;
		limit?: number;
	};
	url: "/v2/cast-quotes";
};

export type GetCastQuotesErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetCastQuotesError = GetCastQuotesErrors[keyof GetCastQuotesErrors];

export type GetCastQuotesResponses = {
	/**
	 * A list of quote casts referencing the given cast
	 */
	200: CastQuotesResponse;
};

export type GetCastQuotesResponse =
	GetCastQuotesResponses[keyof GetCastQuotesResponses];

export type GetCurrentUserData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v2/me";
};

export type GetCurrentUserErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetCurrentUserError =
	GetCurrentUserErrors[keyof GetCurrentUserErrors];

export type GetCurrentUserResponses = {
	/**
	 * Successful retrieval of current user
	 */
	200: UserResponseUserResponse;
};

export type GetCurrentUserResponse =
	GetCurrentUserResponses[keyof GetCurrentUserResponses];

export type SearchChannelsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
		q?: string;
		prioritizeFollowed?: boolean;
		forComposer?: boolean;
	};
	url: "/v2/search-channels";
};

export type SearchChannelsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type SearchChannelsError =
	SearchChannelsErrors[keyof SearchChannelsErrors];

export type SearchChannelsResponses = {
	/**
	 * A list of matched channels
	 */
	200: SearchChannelsResponse;
};

export type SearchChannelsResponse2 =
	SearchChannelsResponses[keyof SearchChannelsResponses];

export type GetDraftCastsData = {
	body?: never;
	path?: never;
	query?: {
		limit?: number;
	};
	url: "/v2/draft-caststorms";
};

export type GetDraftCastsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetDraftCastsError = GetDraftCastsErrors[keyof GetDraftCastsErrors];

export type GetDraftCastsResponses = {
	/**
	 * A list of draft cast storms
	 */
	200: DraftsResponse;
};

export type GetDraftCastsResponse =
	GetDraftCastsResponses[keyof GetDraftCastsResponses];

export type CreateDraftCastsData = {
	body: {
		caststorm?: {
			casts?: Array<DraftCast>;
		};
	};
	headers: {
		"idempotency-key": string;
	};
	path?: never;
	query?: never;
	url: "/v2/draft-caststorms";
};

export type CreateDraftCastsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type CreateDraftCastsError =
	CreateDraftCastsErrors[keyof CreateDraftCastsErrors];

export type CreateDraftCastsResponses = {
	/**
	 * Created draft caststorm
	 */
	200: DraftCreatedResponse;
};

export type CreateDraftCastsResponse =
	CreateDraftCastsResponses[keyof CreateDraftCastsResponses];

export type DeleteDraftCastData = {
	body: {
		draftId?: string;
	};
	path?: never;
	query?: never;
	url: "/v2/draft-casts";
};

export type DeleteDraftCastErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type DeleteDraftCastError =
	DeleteDraftCastErrors[keyof DeleteDraftCastErrors];

export type DeleteDraftCastResponses = {
	/**
	 * Draft cast deleted
	 */
	200: SuccessResponse;
};

export type DeleteDraftCastResponse =
	DeleteDraftCastResponses[keyof DeleteDraftCastResponses];

export type DeleteCastData = {
	body: {
		castHash?: string;
	};
	path?: never;
	query?: never;
	url: "/v2/casts";
};

export type DeleteCastErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type DeleteCastError = DeleteCastErrors[keyof DeleteCastErrors];

export type DeleteCastResponses = {
	/**
	 * Cast deleted successfully
	 */
	200: SuccessResponse;
};

export type DeleteCastResponse = DeleteCastResponses[keyof DeleteCastResponses];

export type GetCastsByFidData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The FID (Farcaster ID) of the user whose casts to retrieve
		 */
		fid: number;
		/**
		 * Maximum number of casts to return
		 */
		limit?: number;
	};
	url: "/v2/casts";
};

export type GetCastsByFidErrors = {
	/**
	 * Bad request
	 */
	400: ErrorResponse;
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetCastsByFidError = GetCastsByFidErrors[keyof GetCastsByFidErrors];

export type GetCastsByFidResponses = {
	/**
	 * Successfully retrieved casts
	 */
	200: {
		result?: {
			casts?: Array<Cast>;
		};
	};
};

export type GetCastsByFidResponse =
	GetCastsByFidResponses[keyof GetCastsByFidResponses];

export type CreateCastData = {
	body: {
		text: string;
		embeds?: Array<unknown>;
		/**
		 * Optional channel to post the cast to
		 */
		channelKey?: string;
	};
	path?: never;
	query?: never;
	url: "/v2/casts";
};

export type CreateCastErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type CreateCastError = CreateCastErrors[keyof CreateCastErrors];

export type CreateCastResponses = {
	/**
	 * Cast created successfully
	 */
	200: CastCreatedResponse;
};

export type CreateCastResponse = CreateCastResponses[keyof CreateCastResponses];

export type GetAllChannelsData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v2/all-channels";
};

export type GetAllChannelsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetAllChannelsError =
	GetAllChannelsErrors[keyof GetAllChannelsErrors];

export type GetAllChannelsResponses = {
	/**
	 * Successful response
	 */
	200: ChannelListResponse;
};

export type GetAllChannelsResponse =
	GetAllChannelsResponses[keyof GetAllChannelsResponses];

export type GetChannelDetailsData = {
	body?: never;
	path?: never;
	query: {
		channelId: string;
	};
	url: "/v1/channel";
};

export type GetChannelDetailsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetChannelDetailsError =
	GetChannelDetailsErrors[keyof GetChannelDetailsErrors];

export type GetChannelDetailsResponses = {
	/**
	 * Channel details
	 */
	200: RawChannelResponse;
};

export type GetChannelDetailsResponse =
	GetChannelDetailsResponses[keyof GetChannelDetailsResponses];

export type GetChannelFollowersData = {
	body?: never;
	path?: never;
	query: {
		channelId: string;
		cursor?: string;
	};
	url: "/v1/channel-followers";
};

export type GetChannelFollowersErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetChannelFollowersError =
	GetChannelFollowersErrors[keyof GetChannelFollowersErrors];

export type GetChannelFollowersResponses = {
	/**
	 * A list of channel followers
	 */
	200: ChannelFollowersResponse;
};

export type GetChannelFollowersResponse =
	GetChannelFollowersResponses[keyof GetChannelFollowersResponses];

export type GetUserFollowedChannelsData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The user's FID (Farcaster ID)
		 */
		fid: number;
	};
	url: "/v1/user-following-channels";
};

export type GetUserFollowedChannelsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetUserFollowedChannelsError =
	GetUserFollowedChannelsErrors[keyof GetUserFollowedChannelsErrors];

export type GetUserFollowedChannelsResponses = {
	/**
	 * Successful response with list of followed channels
	 */
	200: ChannelListResponse;
};

export type GetUserFollowedChannelsResponse =
	GetUserFollowedChannelsResponses[keyof GetUserFollowedChannelsResponses];

export type CheckUserChannelFollowStatusData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The user's FID (Farcaster ID)
		 */
		fid: number;
		channelId: string;
	};
	url: "/v1/user-channel";
};

export type CheckUserChannelFollowStatusErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type CheckUserChannelFollowStatusError =
	CheckUserChannelFollowStatusErrors[keyof CheckUserChannelFollowStatusErrors];

export type CheckUserChannelFollowStatusResponses = {
	/**
	 * Successful response with follow status
	 */
	200: ChannelFollowStatusResponse;
};

export type CheckUserChannelFollowStatusResponse =
	CheckUserChannelFollowStatusResponses[keyof CheckUserChannelFollowStatusResponses];

export type GetChannelMembersData = {
	body?: never;
	path?: never;
	query: {
		channelId: string;
	};
	url: "/fc/channel-members";
};

export type GetChannelMembersErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetChannelMembersError =
	GetChannelMembersErrors[keyof GetChannelMembersErrors];

export type GetChannelMembersResponses = {
	/**
	 * Successful response with list of members
	 */
	200: {
		result: {
			members: Array<{
				/**
				 * Farcaster ID of the member
				 */
				fid: number;
				/**
				 * Timestamp when the user became a member
				 */
				memberAt: number;
			}>;
		};
		next?: {
			/**
			 * Cursor for pagination
			 */
			cursor?: string;
		};
	};
};

export type GetChannelMembersResponse =
	GetChannelMembersResponses[keyof GetChannelMembersResponses];

export type RemoveChannelInviteData = {
	body: {
		/**
		 * ID of the channel from which the user's invite is being removed
		 */
		channelId: string;
		/**
		 * Farcaster ID of the user whose invite is being removed
		 */
		removeFid: number;
		/**
		 * Role associated with the invite being removed
		 */
		role: "member" | "admin";
	};
	path?: never;
	query?: never;
	url: "/fc/channel-invites";
};

export type RemoveChannelInviteErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type RemoveChannelInviteError =
	RemoveChannelInviteErrors[keyof RemoveChannelInviteErrors];

export type RemoveChannelInviteResponses = {
	/**
	 * Successful removal of invite
	 */
	200: SuccessResponse;
};

export type RemoveChannelInviteResponse =
	RemoveChannelInviteResponses[keyof RemoveChannelInviteResponses];

export type GetChannelInvitesData = {
	body?: never;
	path?: never;
	query: {
		channelId: string;
	};
	url: "/fc/channel-invites";
};

export type GetChannelInvitesErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetChannelInvitesError =
	GetChannelInvitesErrors[keyof GetChannelInvitesErrors];

export type GetChannelInvitesResponses = {
	/**
	 * Successful response with list of channel invites
	 */
	200: {
		result?: {
			invites?: Array<{
				channelId: string;
				invitedFid: number;
				invitedAt: number;
				inviterFid: number;
				role: "member" | "admin";
			}>;
		};
		next?: {
			cursor?: string;
		};
	};
};

export type GetChannelInvitesResponse =
	GetChannelInvitesResponses[keyof GetChannelInvitesResponses];

export type AcceptChannelInviteData = {
	body: {
		/**
		 * ID of the channel for which the invite is being accepted
		 */
		channelId: string;
		/**
		 * Role that the user will have in the channel
		 */
		role: "member" | "admin";
		/**
		 * Flag indicating whether to accept the invite
		 */
		accept: boolean;
	};
	path?: never;
	query?: never;
	url: "/fc/channel-invites";
};

export type AcceptChannelInviteErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type AcceptChannelInviteError =
	AcceptChannelInviteErrors[keyof AcceptChannelInviteErrors];

export type AcceptChannelInviteResponses = {
	/**
	 * Successful acceptance of invite
	 */
	200: SuccessResponse;
};

export type AcceptChannelInviteResponse =
	AcceptChannelInviteResponses[keyof AcceptChannelInviteResponses];

export type InviteUserToChannelData = {
	body: {
		/**
		 * ID of the channel to invite the user to
		 */
		channelId: string;
		/**
		 * Farcaster ID of the user being invited
		 */
		inviteFid: number;
		/**
		 * Role of the invited user within the channel
		 */
		role: "member" | "admin";
	};
	path?: never;
	query?: never;
	url: "/fc/channel-invites";
};

export type InviteUserToChannelErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type InviteUserToChannelError =
	InviteUserToChannelErrors[keyof InviteUserToChannelErrors];

export type InviteUserToChannelResponses = {
	/**
	 * Successful invite operation
	 */
	200: SuccessResponse;
};

export type InviteUserToChannelResponse =
	InviteUserToChannelResponses[keyof InviteUserToChannelResponses];

export type GetChannelModeratedCastsData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * ID of the channel to get moderation actions for
		 */
		channelId: string;
	};
	url: "/fc/moderated-casts";
};

export type GetChannelModeratedCastsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetChannelModeratedCastsError =
	GetChannelModeratedCastsErrors[keyof GetChannelModeratedCastsErrors];

export type GetChannelModeratedCastsResponses = {
	/**
	 * Successful response with list of moderation actions
	 */
	200: {
		result: {
			moderationActions: Array<{
				/**
				 * Hash of the moderated cast
				 */
				castHash: string;
				/**
				 * ID of the channel where the cast was moderated
				 */
				channelId: string;
				/**
				 * Type of moderation action applied
				 */
				action: "hide";
				/**
				 * Unix timestamp of when the moderation action was taken
				 */
				moderatedAt: number;
			}>;
		};
		next?: {
			/**
			 * Pagination cursor for fetching the next set of results
			 */
			cursor?: string;
		};
	};
};

export type GetChannelModeratedCastsResponse =
	GetChannelModeratedCastsResponses[keyof GetChannelModeratedCastsResponses];

export type GetChannelRestrictedUsersData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * ID of the channel to get restricted users for
		 */
		channelId: string;
	};
	url: "/fc/channel-restricted-users";
};

export type GetChannelRestrictedUsersErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetChannelRestrictedUsersError =
	GetChannelRestrictedUsersErrors[keyof GetChannelRestrictedUsersErrors];

export type GetChannelRestrictedUsersResponses = {
	/**
	 * Successful response with list of restricted users
	 */
	200: {
		result: {
			restrictedUsers: Array<{
				/**
				 * Farcaster ID of the restricted user
				 */
				fid: number;
				/**
				 * ID of the channel where the user is restricted
				 */
				channelId: string;
				/**
				 * Unix timestamp of when the user was restricted
				 */
				restrictedAt: number;
			}>;
		};
		next?: {
			/**
			 * Pagination cursor for fetching the next set of results
			 */
			cursor?: string;
		};
	};
};

export type GetChannelRestrictedUsersResponse =
	GetChannelRestrictedUsersResponses[keyof GetChannelRestrictedUsersResponses];

export type UnbanUserFromChannelData = {
	body: {
		/**
		 * ID of the channel from which to unban the user
		 */
		channelId: string;
		/**
		 * Farcaster ID of the user to unban
		 */
		banFid: number;
	};
	path?: never;
	query?: never;
	url: "/fc/channel-bans";
};

export type UnbanUserFromChannelErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type UnbanUserFromChannelError =
	UnbanUserFromChannelErrors[keyof UnbanUserFromChannelErrors];

export type UnbanUserFromChannelResponses = {
	/**
	 * Successful unban operation
	 */
	200: SuccessResponse;
};

export type UnbanUserFromChannelResponse =
	UnbanUserFromChannelResponses[keyof UnbanUserFromChannelResponses];

export type GetChannelBannedUsersData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * ID of the channel to get banned users for
		 */
		channelId: string;
	};
	url: "/fc/channel-bans";
};

export type GetChannelBannedUsersErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetChannelBannedUsersError =
	GetChannelBannedUsersErrors[keyof GetChannelBannedUsersErrors];

export type GetChannelBannedUsersResponses = {
	/**
	 * Successful response with list of banned users
	 */
	200: {
		result: {
			bannedUsers: Array<{
				/**
				 * Farcaster ID of the banned user
				 */
				fid: number;
				/**
				 * ID of the channel where the user is banned
				 */
				channelId: string;
				/**
				 * Unix timestamp of when the user was banned
				 */
				bannedAt: number;
			}>;
		};
		next?: {
			/**
			 * Pagination cursor for fetching the next set of banned users
			 */
			cursor?: string;
		};
	};
};

export type GetChannelBannedUsersResponse =
	GetChannelBannedUsersResponses[keyof GetChannelBannedUsersResponses];

export type BanUserFromChannelData = {
	body: {
		/**
		 * ID of the channel from which to ban the user
		 */
		channelId: string;
		/**
		 * Farcaster ID of the user to ban
		 */
		banFid: number;
	};
	path?: never;
	query?: never;
	url: "/fc/channel-bans";
};

export type BanUserFromChannelErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type BanUserFromChannelError =
	BanUserFromChannelErrors[keyof BanUserFromChannelErrors];

export type BanUserFromChannelResponses = {
	/**
	 * Successful ban operation
	 */
	200: SuccessResponse;
};

export type BanUserFromChannelResponse =
	BanUserFromChannelResponses[keyof BanUserFromChannelResponses];

export type UnfollowChannelData = {
	body: {
		/**
		 * ID of the channel to unfollow
		 */
		channelId: string;
	};
	path?: never;
	query?: never;
	url: "/fc/channel-follows";
};

export type UnfollowChannelErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type UnfollowChannelError =
	UnfollowChannelErrors[keyof UnfollowChannelErrors];

export type UnfollowChannelResponses = {
	/**
	 * Successful unfollow operation
	 */
	200: SuccessResponse;
};

export type UnfollowChannelResponse =
	UnfollowChannelResponses[keyof UnfollowChannelResponses];

export type FollowChannelData = {
	body: {
		/**
		 * ID of the channel to follow
		 */
		channelId: string;
	};
	path?: never;
	query?: never;
	url: "/fc/channel-follows";
};

export type FollowChannelErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type FollowChannelError = FollowChannelErrors[keyof FollowChannelErrors];

export type FollowChannelResponses = {
	/**
	 * Successful follow operation
	 */
	200: SuccessResponse;
};

export type FollowChannelResponse =
	FollowChannelResponses[keyof FollowChannelResponses];

export type ModerateCastData = {
	body: {
		/**
		 * Hash of the cast to moderate
		 */
		castHash: string;
		/**
		 * Type of moderation action to apply
		 */
		action: "hide";
	};
	path?: never;
	query?: never;
	url: "/fc/moderate-cast";
};

export type ModerateCastErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type ModerateCastError = ModerateCastErrors[keyof ModerateCastErrors];

export type ModerateCastResponses = {
	/**
	 * Successful moderation action
	 */
	200: SuccessResponse;
};

export type ModerateCastResponse =
	ModerateCastResponses[keyof ModerateCastResponses];

export type UnpinCastFromChannelData = {
	body: {
		/**
		 * ID of the channel from which to unpin a cast
		 */
		channelId: string;
	};
	path?: never;
	query?: never;
	url: "/fc/pinned-casts";
};

export type UnpinCastFromChannelErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type UnpinCastFromChannelError =
	UnpinCastFromChannelErrors[keyof UnpinCastFromChannelErrors];

export type UnpinCastFromChannelResponses = {
	/**
	 * Successful unpin operation
	 */
	200: SuccessResponse;
};

export type UnpinCastFromChannelResponse =
	UnpinCastFromChannelResponses[keyof UnpinCastFromChannelResponses];

export type PinCastToChannelData = {
	body: {
		/**
		 * Hash of the cast to pin
		 */
		castHash: string;
		/**
		 * Whether to notify followers of the channel about the pin
		 */
		notifyChannelFollowers?: boolean;
	};
	path?: never;
	query?: never;
	url: "/fc/pinned-casts";
};

export type PinCastToChannelErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type PinCastToChannelError =
	PinCastToChannelErrors[keyof PinCastToChannelErrors];

export type PinCastToChannelResponses = {
	/**
	 * Successful pin operation
	 */
	200: SuccessResponse;
};

export type PinCastToChannelResponse =
	PinCastToChannelResponses[keyof PinCastToChannelResponses];

export type GetDiscoverableActionsData = {
	body?: never;
	path?: never;
	query: {
		list: string;
		limit?: number;
	};
	url: "/v2/discover-actions";
};

export type GetDiscoverableActionsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetDiscoverableActionsError =
	GetDiscoverableActionsErrors[keyof GetDiscoverableActionsErrors];

export type GetDiscoverableActionsResponses = {
	/**
	 * Successful response with list of discoverable actions
	 */
	200: {
		result?: {
			actions?: Array<Action>;
			next?: {
				cursor?: string;
			};
		};
	};
};

export type GetDiscoverableActionsResponse =
	GetDiscoverableActionsResponses[keyof GetDiscoverableActionsResponses];

export type GetDiscoverableComposerActionsData = {
	body?: never;
	path?: never;
	query: {
		list: string;
		limit?: number;
	};
	url: "/v2/discover-composer-actions";
};

export type GetDiscoverableComposerActionsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetDiscoverableComposerActionsError =
	GetDiscoverableComposerActionsErrors[keyof GetDiscoverableComposerActionsErrors];

export type GetDiscoverableComposerActionsResponses = {
	/**
	 * Successful response with list of discoverable composer actions
	 */
	200: {
		result?: {
			actions?: Array<Action>;
			next?: {
				cursor?: string;
			};
		};
	};
};

export type GetDiscoverableComposerActionsResponse =
	GetDiscoverableComposerActionsResponses[keyof GetDiscoverableComposerActionsResponses];

export type UnblockUserData = {
	body: {
		/**
		 * Farcaster ID of the user to unblock
		 */
		unblockFid: number;
	};
	path?: never;
	query?: never;
	url: "/fc/blocked-users";
};

export type UnblockUserErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type UnblockUserError = UnblockUserErrors[keyof UnblockUserErrors];

export type UnblockUserResponses = {
	/**
	 * Successful unblock operation
	 */
	200: {
		result: {
			/**
			 * Indicates whether the unblock operation was successful
			 */
			success: boolean;
		};
	};
};

export type UnblockUserResponse =
	UnblockUserResponses[keyof UnblockUserResponses];

export type GetBlockedUsersData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/fc/blocked-users";
};

export type GetBlockedUsersErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetBlockedUsersError =
	GetBlockedUsersErrors[keyof GetBlockedUsersErrors];

export type GetBlockedUsersResponses = {
	/**
	 * Successful response with list of blocked users
	 */
	200: {
		result: {
			blockedUsers: Array<{
				/**
				 * Farcaster ID of the user who blocked
				 */
				blockerFid: number;
				/**
				 * Farcaster ID of the user who was blocked
				 */
				blockedFid: number;
				/**
				 * Unix timestamp of when the user was blocked
				 */
				createdAt: number;
			}>;
			next?: {
				/**
				 * Pagination cursor for fetching the next set of blocked users
				 */
				cursor?: string;
			};
		};
	};
};

export type GetBlockedUsersResponse =
	GetBlockedUsersResponses[keyof GetBlockedUsersResponses];

export type BlockUserData = {
	body: {
		/**
		 * Farcaster ID of the user to block
		 */
		blockFid: number;
	};
	path?: never;
	query?: never;
	url: "/fc/blocked-users";
};

export type BlockUserErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type BlockUserError = BlockUserErrors[keyof BlockUserErrors];

export type BlockUserResponses = {
	/**
	 * Successful block operation
	 */
	200: {
		result: {
			/**
			 * Indicates whether the block operation was successful
			 */
			success: boolean;
		};
	};
};

export type BlockUserResponse = BlockUserResponses[keyof BlockUserResponses];

export type GetAccountVerificationsData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The user's FID (Farcaster ID)
		 */
		fid: number;
	};
	url: "/fc/account-verifications";
};

export type GetAccountVerificationsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetAccountVerificationsError =
	GetAccountVerificationsErrors[keyof GetAccountVerificationsErrors];

export type GetAccountVerificationsResponses = {
	/**
	 * Successful response with list of account verifications
	 */
	200: {
		result?: {
			verifications?: Array<{
				fid?: number;
				platform?: string;
				platformId?: string;
				platformUsername?: string;
				verifiedAt?: number;
			}>;
		};
		next?: {
			cursor?: string;
		};
	};
};

export type GetAccountVerificationsResponse =
	GetAccountVerificationsResponses[keyof GetAccountVerificationsResponses];

export type GetCreatorRewardWinnersData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * How many periods ago to fetch the results for. 0 or undefined returns results for the most recent period.
		 */
		periodsAgo?: number;
	};
	url: "/v1/creator-rewards-winner-history";
};

export type GetCreatorRewardWinnersErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetCreatorRewardWinnersError =
	GetCreatorRewardWinnersErrors[keyof GetCreatorRewardWinnersErrors];

export type GetCreatorRewardWinnersResponses = {
	/**
	 * Successful response with creator reward winners history
	 */
	200: {
		result?: {
			periodStartTimestamp?: bigint;
			periodEndTimestamp?: bigint;
			winners?: Array<{
				fid?: number;
				score?: number;
				rank?: number;
				rewardCents?: number;
				walletAddress?: string;
			}>;
		};
		next?: {
			cursor?: string;
		};
	};
};

export type GetCreatorRewardWinnersResponse =
	GetCreatorRewardWinnersResponses[keyof GetCreatorRewardWinnersResponses];

export type GetUserPrimaryAddressData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The user's FID (Farcaster ID)
		 */
		fid: number;
		/**
		 * The protocol of the address to fetch.
		 */
		protocol: "ethereum" | "solana";
	};
	url: "/fc/primary-address";
};

export type GetUserPrimaryAddressErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetUserPrimaryAddressError =
	GetUserPrimaryAddressErrors[keyof GetUserPrimaryAddressErrors];

export type GetUserPrimaryAddressResponses = {
	/**
	 * Successful response with the user's primary address.
	 */
	200: {
		result?: {
			address?: VerifiedAddress;
		};
	};
};

export type GetUserPrimaryAddressResponse =
	GetUserPrimaryAddressResponses[keyof GetUserPrimaryAddressResponses];

export type GetUserPrimaryAddressesData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * Comma-separated list of FIDs to fetch primary addresses for.
		 */
		fids: string;
		/**
		 * The protocol of the addresses to fetch.
		 */
		protocol: "ethereum" | "solana";
	};
	url: "/fc/primary-addresses";
};

export type GetUserPrimaryAddressesErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetUserPrimaryAddressesError =
	GetUserPrimaryAddressesErrors[keyof GetUserPrimaryAddressesErrors];

export type GetUserPrimaryAddressesResponses = {
	/**
	 * Successful response with list of primary addresses.
	 */
	200: {
		result?: {
			addresses?: Array<{
				/**
				 * The Farcaster ID of the user
				 */
				fid: number;
				/**
				 * Whether the address was successfully retrieved
				 */
				success: boolean;
				/**
				 * Present only if success is true
				 */
				address?: VerifiedAddress;
			}>;
		};
	};
};

export type GetUserPrimaryAddressesResponse =
	GetUserPrimaryAddressesResponses[keyof GetUserPrimaryAddressesResponses];

export type GetStarterPackMembersData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * Starter pack ID, as found in the public Warpcast pack URL or in the non-authed public API of starter pack metadata.
		 *
		 */
		id: string;
	};
	url: "/fc/starter-pack-members";
};

export type GetStarterPackMembersErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetStarterPackMembersError =
	GetStarterPackMembersErrors[keyof GetStarterPackMembersErrors];

export type GetStarterPackMembersResponses = {
	/**
	 * Successful response with list of starter pack members.
	 */
	200: {
		result?: {
			members?: Array<{
				/**
				 * The Farcaster ID of the starter pack member
				 */
				fid: number;
				/**
				 * Timestamp in milliseconds when the user became a member
				 */
				memberAt: bigint;
			}>;
		};
		next?: {
			/**
			 * Pagination cursor for fetching the next set of results
			 */
			cursor?: string;
		};
	};
};

export type GetStarterPackMembersResponse =
	GetStarterPackMembersResponses[keyof GetStarterPackMembersResponses];

export type SendDirectCastData = {
	body: {
		/**
		 * The Farcaster ID of the recipient.
		 */
		recipientFid: number;
		/**
		 * The direct cast message.
		 */
		message: string;
		/**
		 * A unique key to ensure idempotency.
		 */
		idempotencyKey: string;
	};
	path?: never;
	query?: never;
	url: "/v2/ext-send-direct-cast";
};

export type SendDirectCastErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type SendDirectCastError =
	SendDirectCastErrors[keyof SendDirectCastErrors];

export type SendDirectCastResponses = {
	/**
	 * Direct cast sent successfully
	 */
	200: {
		result: {
			/**
			 * Indicates if the direct cast was sent successfully
			 */
			success: boolean;
		};
	};
};

export type SendDirectCastResponse =
	SendDirectCastResponses[keyof SendDirectCastResponses];

export type GetUserByVerificationAddressData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * Ethereum address used for user verification
		 */
		address: string;
	};
	url: "/v2/user-by-verification";
};

export type GetUserByVerificationAddressErrors = {
	/**
	 * Invalid address format
	 */
	400: {
		errors: Array<{
			/**
			 * JSON Pointer to the part of the request that failed validation
			 */
			instancePath: string;
			/**
			 * JSON Schema path that was violated
			 */
			schemaPath: string;
			/**
			 * The JSON Schema keyword that failed
			 */
			keyword: string;
			/**
			 * Additional parameters describing the validation error
			 */
			params?: {
				[key: string]: unknown;
			};
			/**
			 * Human-readable error description
			 */
			message: string;
		}>;
	};
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * The specified resource was not found
	 */
	404: ErrorResponse;
};

export type GetUserByVerificationAddressError =
	GetUserByVerificationAddressErrors[keyof GetUserByVerificationAddressErrors];

export type GetUserByVerificationAddressResponses = {
	/**
	 * User data successfully retrieved
	 */
	200: UserResponse;
};

export type GetUserByVerificationAddressResponse =
	GetUserByVerificationAddressResponses[keyof GetUserByVerificationAddressResponses];

export type GetDeveloperRewardWinnersData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * How many periods ago to fetch the results for. 0 or undefined returns results for the most recent period.
		 */
		periodsAgo?: number;
	};
	url: "/v1/developer-rewards-winner-history";
};

export type GetDeveloperRewardWinnersErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetDeveloperRewardWinnersError =
	GetDeveloperRewardWinnersErrors[keyof GetDeveloperRewardWinnersErrors];

export type GetDeveloperRewardWinnersResponses = {
	/**
	 * A paginated list of developer reward winners
	 */
	200: {
		result?: {
			/**
			 * Unix time in milliseconds when rewards period began
			 */
			periodStartTimestamp?: number;
			/**
			 * Unix time in milliseconds when rewards period ended
			 */
			periodEndTimestamp?: number;
			winners?: Array<Winner>;
		};
		next?: {
			/**
			 * Pagination cursor for the next set of results
			 */
			cursor?: string;
		};
	};
};

export type GetDeveloperRewardWinnersResponse =
	GetDeveloperRewardWinnersResponses[keyof GetDeveloperRewardWinnersResponses];

export type GetAppsByAuthorData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The user's FID (Farcaster ID)
		 */
		fid: number;
		/**
		 * Maximum number of items to return
		 */
		limit?: number;
	};
	url: "/v1/apps-by-author";
};

export type GetAppsByAuthorErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetAppsByAuthorError =
	GetAppsByAuthorErrors[keyof GetAppsByAuthorErrors];

export type GetAppsByAuthorResponses = {
	/**
	 * A list of frames by the author
	 */
	200: AppsByAuthorResponse;
};

export type GetAppsByAuthorResponse =
	GetAppsByAuthorResponses[keyof GetAppsByAuthorResponses];

export type GetDomainManifestData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The domain to retrieve manifest information for
		 */
		domain: string;
	};
	url: "/v1/domain-manifest";
};

export type GetDomainManifestErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetDomainManifestError =
	GetDomainManifestErrors[keyof GetDomainManifestErrors];

export type GetDomainManifestResponses = {
	/**
	 * Successfully retrieved domain manifest
	 */
	200: {
		result?: {
			state?: {
				/**
				 * Indicates if the domain is verified
				 */
				verified?: boolean;
				/**
				 * JSON string containing the raw manifest data
				 */
				manifest?: string;
				decodedManifest?: {
					accountAssociation?: {
						/**
						 * Farcaster ID associated with the domain
						 */
						fid?: number;
						/**
						 * Public key associated with the domain
						 */
						key?: string;
						/**
						 * The domain name
						 */
						domain?: string;
						/**
						 * Signature proving domain ownership
						 */
						signature?: string;
					};
				};
				/**
				 * Configuration for Farcaster Frames
				 */
				frameConfig?: {
					/**
					 * Name of the Frame
					 */
					name?: string;
					/**
					 * Version of the Frame
					 */
					version?: string;
					/**
					 * URL to the Frame's icon
					 */
					iconUrl?: string;
					/**
					 * Home URL of the Frame
					 */
					homeUrl?: string;
					/**
					 * Image URL for the Frame
					 */
					imageUrl?: string;
					/**
					 * Title for the Frame's button
					 */
					buttonTitle?: string;
					/**
					 * URL for the splash image
					 */
					splashImageUrl?: string;
					/**
					 * Background color for splash screen
					 */
					splashBackgroundColor?: string;
					/**
					 * Webhook URL for the Frame
					 */
					webhookUrl?: string;
				};
				/**
				 * Timestamp of when the data was last updated
				 */
				updatedAt?: number;
			};
		};
	};
};

export type GetDomainManifestResponse =
	GetDomainManifestResponses[keyof GetDomainManifestResponses];

export type GetMetaTagsData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The URL to fetch metadata from
		 */
		url: string;
	};
	url: "/v1/dev-tools/meta-tags";
};

export type GetMetaTagsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetMetaTagsError = GetMetaTagsErrors[keyof GetMetaTagsErrors];

export type GetMetaTagsResponses = {
	/**
	 * Successfully retrieved metadata
	 */
	200: {
		/**
		 * Viewport meta tag content
		 */
		viewport?: string;
		/**
		 * Theme color values
		 */
		"theme-color"?: Array<string>;
		/**
		 * Color scheme preference
		 */
		"color-scheme"?: string;
		/**
		 * Page description
		 */
		description?: string;
		/**
		 * Apple mobile web app capability setting
		 */
		"apple-mobile-web-app-capable"?: string;
		/**
		 * Apple mobile web app title
		 */
		"apple-mobile-web-app-title"?: string;
		/**
		 * Apple mobile status bar style
		 */
		"apple-mobile-web-app-status-bar-style"?: string;
		/**
		 * Open Graph title
		 */
		"og:title"?: string;
		/**
		 * Open Graph description
		 */
		"og:description"?: string;
		/**
		 * Open Graph URL
		 */
		"og:url"?: string;
		/**
		 * Open Graph site name
		 */
		"og:site_name"?: string;
		/**
		 * Open Graph image alt text
		 */
		"og:image:alt"?: string;
		/**
		 * Open Graph image MIME type
		 */
		"og:image:type"?: string;
		/**
		 * Open Graph image width
		 */
		"og:image:width"?: string;
		/**
		 * Open Graph image height
		 */
		"og:image:height"?: string;
		/**
		 * Open Graph image URL
		 */
		"og:image"?: string;
		/**
		 * Open Graph content type
		 */
		"og:type"?: string;
		/**
		 * Twitter card type
		 */
		"twitter:card"?: string;
		/**
		 * Twitter card title
		 */
		"twitter:title"?: string;
		/**
		 * Twitter card description
		 */
		"twitter:description"?: string;
		/**
		 * Twitter image alt text
		 */
		"twitter:image:alt"?: string;
		/**
		 * Twitter image MIME type
		 */
		"twitter:image:type"?: string;
		/**
		 * Twitter image width
		 */
		"twitter:image:width"?: string;
		/**
		 * Twitter image height
		 */
		"twitter:image:height"?: string;
		/**
		 * Twitter image URL
		 */
		"twitter:image"?: string;
	};
};

export type GetMetaTagsResponse =
	GetMetaTagsResponses[keyof GetMetaTagsResponses];

export type GetFarcasterJsonData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The domain to fetch Farcaster JSON data from
		 */
		domain: string;
	};
	url: "/v1/dev-tools/farcaster-json";
};

export type GetFarcasterJsonErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetFarcasterJsonError =
	GetFarcasterJsonErrors[keyof GetFarcasterJsonErrors];

export type GetFarcasterJsonResponses = {
	/**
	 * Successfully retrieved Farcaster JSON data
	 */
	200: {
		/**
		 * Farcaster account association information
		 */
		accountAssociation?: {
			/**
			 * Base64 encoded header containing FID, type, and key information
			 */
			header?: string;
			/**
			 * Base64 encoded payload containing domain information
			 */
			payload?: string;
			/**
			 * Cryptographic signature for verification
			 */
			signature?: string;
		};
		/**
		 * Farcaster frame configuration
		 */
		frame?: {
			/**
			 * URL of the frame's home page
			 */
			homeUrl?: string;
			/**
			 * URL of the frame's icon
			 */
			iconUrl?: string;
			/**
			 * Name of the frame
			 */
			name?: string;
			/**
			 * Background color for the splash screen in hex format
			 */
			splashBackgroundColor?: string;
			/**
			 * URL of the splash image
			 */
			splashImageUrl?: string;
			/**
			 * Version of the frame
			 */
			version?: string;
			/**
			 * URL of the frame's webhook
			 */
			webhookUrl?: string;
		};
	};
};

export type GetFarcasterJsonResponse =
	GetFarcasterJsonResponses[keyof GetFarcasterJsonResponses];

export type GetOwnedDomainsData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v1/dev-tools/domains-owned";
};

export type GetOwnedDomainsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Forbidden - insufficient permissions
	 */
	403: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type GetOwnedDomainsError =
	GetOwnedDomainsErrors[keyof GetOwnedDomainsErrors];

export type GetOwnedDomainsResponses = {
	/**
	 * Successfully retrieved owned domains
	 */
	200: {
		result: {
			/**
			 * List of domains owned by the authenticated user
			 */
			domains?: Array<string>;
		};
	};
};

export type GetOwnedDomainsResponse =
	GetOwnedDomainsResponses[keyof GetOwnedDomainsResponses];

export type GetApiKeysData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v2/api-keys";
};

export type GetApiKeysErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Forbidden - User doesn't have permission to access API keys
	 */
	403: unknown;
};

export type GetApiKeysError = GetApiKeysErrors[keyof GetApiKeysErrors];

export type GetApiKeysResponses = {
	/**
	 * Successfully retrieved API keys
	 */
	200: {
		result: {
			apiKeys: Array<ApiKey>;
		};
	};
};

export type GetApiKeysResponse = GetApiKeysResponses[keyof GetApiKeysResponses];

export type CreateApiKeyData = {
	body: {
		/**
		 * User-provided description of the API key's purpose
		 */
		description: string;
		/**
		 * Timestamp when the API key should expire (in milliseconds since epoch)
		 */
		expiresAt: bigint;
	};
	headers?: {
		/**
		 * A unique key to ensure idempotency of the request
		 */
		"idempotency-key"?: string;
	};
	path?: never;
	query?: never;
	url: "/v2/api-keys";
};

export type CreateApiKeyErrors = {
	/**
	 * Bad Request - Invalid input parameters
	 */
	400: unknown;
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Forbidden - User doesn't have permission to create API keys
	 */
	403: unknown;
};

export type CreateApiKeyError = CreateApiKeyErrors[keyof CreateApiKeyErrors];

export type CreateApiKeyResponses = {
	/**
	 * Successfully created API key
	 */
	200: {
		result: {
			/**
			 * Unique identifier for the created API key
			 */
			id: string;
			/**
			 * The secret key value that should be used for authentication (only returned once at creation)
			 */
			secretKey: string;
		};
	};
};

export type CreateApiKeyResponse =
	CreateApiKeyResponses[keyof CreateApiKeyResponses];

export type RevokeApiKeyData = {
	body: {
		/**
		 * ID of the API key to revoke
		 */
		id: string;
	};
	headers?: {
		/**
		 * A unique key to ensure idempotency of the request
		 */
		"idempotency-key"?: string;
	};
	path?: never;
	query?: never;
	url: "/v2/revoke-api-key";
};

export type RevokeApiKeyErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Forbidden - User doesn't have permission to revoke API keys
	 */
	403: unknown;
	/**
	 * Not Found - API key with specified ID does not exist
	 */
	404: unknown;
};

export type RevokeApiKeyError = RevokeApiKeyErrors[keyof RevokeApiKeyErrors];

export type RevokeApiKeyResponses = {
	/**
	 * Successfully revoked the API key
	 */
	200: {
		result: {
			success: boolean;
		};
	};
};

export type RevokeApiKeyResponse =
	RevokeApiKeyResponses[keyof RevokeApiKeyResponses];

export type GetConnectedAccountsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Maximum number of connected accounts to return
		 */
		limit?: number;
	};
	url: "/v2/connected-accounts";
};

export type GetConnectedAccountsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type GetConnectedAccountsError =
	GetConnectedAccountsErrors[keyof GetConnectedAccountsErrors];

export type GetConnectedAccountsResponses = {
	/**
	 * List of connected accounts
	 */
	200: {
		result: {
			accounts?: Array<{
				/**
				 * Unique identifier for the connected account
				 */
				connectedAccountId?: string;
				/**
				 * Social platform name (e.g., x, github, lens)
				 */
				platform?: "x" | "github" | "lens" | "ethereum";
				/**
				 * Username on the connected platform
				 */
				username?: string;
				/**
				 * Whether the connection has expired
				 */
				expired?: boolean;
			}>;
		};
	};
};

export type GetConnectedAccountsResponse =
	GetConnectedAccountsResponses[keyof GetConnectedAccountsResponses];

export type GetProfileCastsData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * Farcaster ID of the user
		 */
		fid: number;
		/**
		 * Maximum number of casts to return
		 */
		limit?: number;
		/**
		 * Cursor for pagination
		 */
		cursor?: string;
	};
	url: "/v2/profile-casts";
};

export type GetProfileCastsErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * User not found
	 */
	404: unknown;
};

export type GetProfileCastsError =
	GetProfileCastsErrors[keyof GetProfileCastsErrors];

export type GetProfileCastsResponses = {
	/**
	 * Successfully retrieved user's casts
	 */
	200: {
		result: {
			casts: Array<Cast>;
		};
		next?: {
			/**
			 * Cursor for fetching the next page of results
			 */
			cursor?: string;
		};
	};
};

export type GetProfileCastsResponse =
	GetProfileCastsResponses[keyof GetProfileCastsResponses];

export type GetUserLikedCastsData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The user's fid (user id) whose liked casts are to be retrieved.
		 */
		fid: number;
		/**
		 * Number of results to limit per request.
		 */
		limit?: number;
	};
	url: "/v2/user-liked-casts";
};

export type GetUserLikedCastsErrors = {
	/**
	 * Bad request (e.g., missing required parameters)
	 */
	400: unknown;
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Internal Server Error
	 */
	500: unknown;
};

export type GetUserLikedCastsError =
	GetUserLikedCastsErrors[keyof GetUserLikedCastsErrors];

export type GetUserLikedCastsResponses = {
	/**
	 * Successfully retrieved liked casts.
	 */
	200: {
		result: {
			casts?: Array<Cast>;
			next?: {
				cursor?: string;
			};
		};
	};
};

export type GetUserLikedCastsResponse =
	GetUserLikedCastsResponses[keyof GetUserLikedCastsResponses];

export type GetMiniAppAnalyticsRollupData = {
	body: {
		dateRange: {
			/**
			 * Start date in format 'YYYY-MM-DD' or relative like '28daysago'
			 */
			startDate: string;
			/**
			 * End date in format 'YYYY-MM-DD' or relative like 'today'
			 */
			endDate: string;
		};
		/**
		 * Analytics metrics to retrieve
		 */
		measures: Array<
			| "miniapp_opens"
			| "miniapp_transactions"
			| "miniapp_users_w_transaction"
			| "miniapp_users_w_open"
			| "miniapp_users_w_notifications_enabled"
			| "miniapp_users_w_notifications_disabled"
			| "miniapp_users_w_app_favorited"
			| "miniapp_users_w_app_unfavorited"
		>;
		/**
		 * Filtering restrictions for the data
		 */
		restrictions: Array<{
			/**
			 * Dimension to filter on
			 */
			dimension: string;
			/**
			 * Values to filter the dimension by
			 */
			values: Array<string>;
		}>;
		/**
		 * Configuration for data breakdown
		 */
		breakdownSettings?: {
			/**
			 * Dimensions to break down the data by
			 */
			dimensions?: Array<string>;
			/**
			 * Sort order for the breakdown results
			 */
			order?: "asc" | "desc";
		};
	};
	path?: never;
	query?: never;
	url: "/v1/analytics/miniapps/rollup";
};

export type GetMiniAppAnalyticsRollupErrors = {
	/**
	 * Bad request - Invalid parameters
	 */
	400: unknown;
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Forbidden - Not authorized to access this data
	 */
	403: unknown;
	/**
	 * Server error
	 */
	500: unknown;
};

export type GetMiniAppAnalyticsRollupError =
	GetMiniAppAnalyticsRollupErrors[keyof GetMiniAppAnalyticsRollupErrors];

export type GetMiniAppAnalyticsRollupResponses = {
	/**
	 * Successful analytics rollup retrieval
	 */
	200: {
		result?: {
			rollup?: {
				dateRange?: {
					startDate?: Date;
					endDate?: Date;
				};
				restrictions?: Array<{
					dimension?: string;
					values?: Array<string>;
				}>;
				/**
				 * Aggregate metric totals
				 */
				totals?: Array<{
					name?: string;
					value?: number;
				}>;
				/**
				 * Metrics broken down by dimensions
				 */
				breakdown?: Array<{
					slices?: Array<{
						dimension?: string;
						values?: Array<string>;
					}>;
					measures?: Array<{
						name?: string;
						value?: number;
					}>;
				}>;
			};
		};
	};
};

export type GetMiniAppAnalyticsRollupResponse =
	GetMiniAppAnalyticsRollupResponses[keyof GetMiniAppAnalyticsRollupResponses];

export type InspectMiniAppUrlData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The URL of the Mini App to inspect
		 */
		url: string;
	};
	url: "/v1/dev-tools/inspect-miniapp-url";
};

export type InspectMiniAppUrlErrors = {
	/**
	 * Bad request - Invalid URL format
	 */
	400: unknown;
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Forbidden - Not authorized to use this endpoint
	 */
	403: unknown;
	/**
	 * Server error
	 */
	500: unknown;
};

export type InspectMiniAppUrlError =
	InspectMiniAppUrlErrors[keyof InspectMiniAppUrlErrors];

export type InspectMiniAppUrlResponses = {
	/**
	 * Successful inspection of the Mini App URL
	 */
	200: {
		result?: {
			facts?: {
				/**
				 * The URL that was inspected
				 */
				url?: string;
				/**
				 * HTTP status code returned by the URL
				 */
				statusCode?: number;
				/**
				 * Indicates if the Mini App embedding code is present
				 */
				miniAppEmbedPresent?: boolean;
				/**
				 * Indicates if the Mini App manifest is present
				 */
				miniAppManifestPresent?: boolean;
				/**
				 * Indicates if the Mini App embedding code is valid
				 */
				miniAppEmbedValid?: boolean;
				/**
				 * Indicates if the Mini App manifest is valid
				 */
				miniAppManifestValid?: boolean;
			};
		};
	};
};

export type InspectMiniAppUrlResponse =
	InspectMiniAppUrlResponses[keyof InspectMiniAppUrlResponses];

export type InspectImageUrlData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The URL of the image to inspect
		 */
		url: string;
	};
	url: "/v1/dev-tools/inspect-image-url";
};

export type InspectImageUrlErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
};

export type InspectImageUrlError =
	InspectImageUrlErrors[keyof InspectImageUrlErrors];

export type InspectImageUrlResponses = {
	/**
	 * Image inspection successful
	 */
	200: {
		result: {
			facts?: {
				/**
				 * The URL of the inspected image
				 */
				url?: string;
				/**
				 * HTTP status code of the response
				 */
				statusCode?: number;
				/**
				 * The cache header used by the image
				 */
				cacheHeader?: string;
				/**
				 * Cache age in seconds
				 */
				cacheAge?: number;
				/**
				 * Size of the image in bytes
				 */
				imageSizeBytes?: number;
				/**
				 * Time taken to load the image in milliseconds
				 */
				imageLoadTimeMs?: number;
			};
		};
	};
};

export type InspectImageUrlResponse =
	InspectImageUrlResponses[keyof InspectImageUrlResponses];

export type ExportMiniAppUserDataData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The domain name of the mini app to export user data for
		 */
		domain: string;
	};
	url: "/v1/dev-tools/export/miniapp-user-data";
};

export type ExportMiniAppUserDataErrors = {
	/**
	 * Authentication is required or failed
	 */
	401: ErrorResponse;
	/**
	 * Forbidden - insufficient permissions or not the owner of the specified domain
	 */
	403: unknown;
	/**
	 * Domain not found or not registered as a mini app
	 */
	404: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type ExportMiniAppUserDataError =
	ExportMiniAppUserDataErrors[keyof ExportMiniAppUserDataErrors];

export type ExportMiniAppUserDataResponses = {
	/**
	 * Successfully retrieved mini app user data
	 */
	200: {
		result: {
			users?: Array<{
				/**
				 * Farcaster ID of the user
				 */
				fid: number;
				/**
				 * Token used for sending notifications to the user
				 */
				notificationToken?: string | null;
				/**
				 * Whether the user has been added/registered with the mini app
				 */
				added: boolean;
			}>;
		};
	};
};

export type ExportMiniAppUserDataResponse =
	ExportMiniAppUserDataResponses[keyof ExportMiniAppUserDataResponses];

export type ClientOptions = {
	baseUrl:
		| "https://api.farcaster.xyz"
		| "https://client.warpcccastt.com"
		| (string & {});
};
