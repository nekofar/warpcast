// This file is auto-generated by @hey-api/openapi-ts

export interface ProfilePicture {
  url?: string
  verified?: boolean
}

export interface Bio {
  text?: string
  mentions?: unknown[]
  channelMentions?: unknown[]
}

export interface Location {
  placeId?: string
  description?: string
}

export interface Profile {
  bio?: Bio
  location?: Location
}

export interface ViewerContext {
  following?: boolean
  followedBy?: boolean
  enableNotifications?: boolean
  canSendDirectCasts?: boolean
  hasUploadedInboxKeys?: boolean
}

export interface User {
  fid?: number
  username?: string
  displayName?: string
  pfp?: ProfilePicture
  profile?: Profile
  followerCount?: number
  followingCount?: number
  viewerContext?: ViewerContext
}

export interface OnboardingState {
  id?: string
  email?: string
  user?: User
  hasOnboarding?: boolean
  hasConfirmedEmail?: boolean
  handledConnectAddress?: boolean
  canRegisterUsername?: boolean
  needsRegistrationPayment?: boolean
  hasFid?: boolean
  hasFname?: boolean
  hasDelegatedSigner?: boolean
  hasSetupProfile?: boolean
  hasCompletedRegistration?: boolean
  hasStorage?: boolean
  handledPushNotificationsNudge?: boolean
  handledContactsNudge?: boolean
  handledInterestsNudge?: boolean
  hasValidPaidInvite?: boolean
  hasWarpcastWalletAddress?: boolean
  hasPhone?: boolean
  needsPhone?: boolean
  sponsoredRegisterEligible?: boolean
  geoRestricted?: boolean
}

export interface OnboardingStateResponse {
  result?: {
    state?: OnboardingState
  }
}

export interface ErrorResponse {
  errors?: {
    /**
     * Error message describing the issue
     */
    message?: string
  }[]
}

export type UserWithExtras = User & {
  connectedAccounts?: unknown[]
}

export interface UserExtras {
  fid?: number
  custodyAddress?: string
  ethWallets?: string[]
  solanaWallets?: string[]
}

export interface UserByFidResponse {
  result?: {
    user?: UserWithExtras
    collectionsOwned?: unknown[]
    extras?: UserExtras
  }
}

export interface DirectCastInboxResponse {
  result?: {
    hasArchived?: boolean
    hasUnreadRequests?: boolean
    requestsCount?: number
    conversations?: {
      conversationId?: string
      name?: string
      description?: string
      photoUrl?: string
      adminFids?: number[]
      lastReadTime?: number
      lastMessage?: {
        conversationId?: string
        senderFid?: number
        messageId?: string
        serverTimestamp?: number
        type?: string
        message?: string
        hasMention?: boolean
        reactions?: unknown[]
        isPinned?: boolean
        isDeleted?: boolean
        senderContext?: User
      }
      isGroup?: boolean
      createdAt?: number
      viewerContext?: {
        category?: string
        lastReadAt?: number
        muted?: boolean
        manuallyMarkedUnread?: boolean
        pinned?: boolean
        unreadCount?: number
        unreadMentionsCount?: number
      }
    }[]
  }
}

export interface CastAction {
  id?: string
  name?: string
  octicon?: string
  actionUrl?: string
  action?: {
    actionType?: string
    postUrl?: string
  }
}

export interface UserAppContextResponse {
  result?: {
    context?: {
      canAddLinks?: boolean
      showConnectedApps?: boolean
      signerRequestsEnabled?: boolean
      prompts?: unknown[]
      adminForChannelKeys?: string[]
      modOfChannelKeys?: string[]
      memberOfChannelKeys?: string[]
      canEditAllChannels?: boolean
      canUploadVideo?: boolean
      statsigEnabled?: boolean
      shouldPromptForPushNotifications?: boolean
      shouldPromptForUserFollowsSyncContacts?: boolean
      castActions?: CastAction[]
      canAddCastAction?: boolean
      enabledCastAction?: CastAction
      notificationTabsV2?: {
        id?: string
        name?: string
      }[]
      enabledVideoAutoplay?: boolean
      regularCastByteLimit?: number
      longCastByteLimit?: number
      newUserStatus?: Record<string, unknown>
      country?: string
      higherClientEventSamplingRateEnabled?: boolean
    }
  }
}

export interface UserPreferencesResponse {
  result?: {
    preferences?: Record<string, unknown>
  }
}

export interface Channel {
  type?: string
  key?: string
  name?: string
  imageUrl?: string
  fastImageUrl?: string
  feeds?: {
    name?: string
    type?: string
  }[]
  description?: string
  followerCount?: number
  memberCount?: number
  showCastSourceLabels?: boolean
  showCastTags?: boolean
  sectionRank?: number
  subscribable?: boolean
  publicCasting?: boolean
  inviteCode?: string
  headerImageUrl?: string
  headerAction?: {
    title?: string
    target?: string
  }
  headerActionMetadata?: Record<string, unknown>
  viewerContext?: {
    following?: boolean
    isMember?: boolean
    hasUnseenItems?: boolean
    favoritePosition?: number
    activityRank?: number
    canCast?: boolean
  }
}

export interface HighlightedChannelsResponse {
  result?: {
    channels?: Channel[]
    viewerContext?: {
      defaultFeed?: string
    }
  }
}

export interface FeedItemsResponse {
  result?: {
    items?: Record<string, unknown>[]
    latestMainCastTimestamp?: number
    feedTopSeenAtTimestamp?: number
    replaceFeed?: boolean
  }
}

export interface UserResponse {
  result?: {
    user?: UserWithExtras
    collectionsOwned?: Record<string, unknown>[]
    extras?: {
      fid?: number
      custodyAddress?: string
      ethWallets?: string[]
      solanaWallets?: string[]
    }
  }
}

export interface SuggestedUsersResponse {
  result?: {
    users?: Record<string, unknown>[]
    next?: {
      cursor?: string
    }
  }
}

export interface FavoriteFramesResponse {
  result: {
    frames: Record<string, unknown>[]
  }
}

export interface ChannelStreaksResponse {
  result: Record<string, unknown>
}

export interface UnseenCountsResponse {
  result: {
    notificationsCount?: number
    notificationTabs?: {
      tab: string
      unseenCount: number
    }[]
    inboxCount?: number
    channelFeeds?: {
      channelKey: string
      feedType: string
      hasNewItems: boolean
    }[]
    warpTransactionCount?: number
  }
}

export interface UserThreadCastsResponse {
  result: {
    casts: Record<string, unknown>[]
  }
}

export interface ChannelFollowersYouKnowResponse {
  result: {
    users: Record<string, unknown>[]
    totalCount: number
  }
}

export interface SuccessResponse {
  result: {
    /**
     * Indicates whether the operation was successful
     */
    success: boolean
  }
}

export interface NotificationsResponse {
  result: {
    notifications?: Record<string, unknown>[]
  }
}

export interface DirectCastConversationResponse {
  result: {
    conversation?: Record<string, unknown>
  }
}

export interface DiscoverChannelsResponse {
  result: {
    channels?: Record<string, unknown>[]
  }
}

export interface InvitesAvailableResponse {
  result: {
    /**
     * Total number of invites allocated to the user
     */
    allocatedInvitesCount: number
    /**
     * Number of invites currently available to send
     */
    availableInvitesCount: number
  }
}

export interface SponsoredInvitesResponse {
  result: {
    invites?: Record<string, unknown>[]
  }
}

export interface RewardsLeaderboardResponse {
  result: {
    leaderboard: {
      type: string
      users: {
        user?: Record<string, unknown>
        score?: number
        rank?: number
      }[]
    }
  }
}

export interface RewardsScoresResponse {
  result: {
    scores: {
      type?: string
      user?: Record<string, unknown>
      allTimeScore?: number
      currentPeriodScore?: number
      previousPeriodScore?: number
    }[]
  }
}

export interface RewardsMetadataResponse {
  result: {
    metadata: {
      type: string
      lastUpdateTimestamp: number
      currentPeriodStartTimestamp: number
      currentPeriodEndTimestamp: number
      tiers?: Record<string, unknown>[]
      proportionalPayout?: {
        numWinners?: number
        totalRewardCents?: number
      }
    }
  }
}

export type BookmarkedCast = Record<string, unknown>;

export interface BookmarkedCastsResponse {
  result: {
    bookmarks?: BookmarkedCast[]
  }
}

export type StarterPack = Record<string, unknown>;

export interface StarterPacksResponse {
  result: {
    starterPacks?: StarterPack[]
  }
}

export interface StarterPackResponse {
  result: {
    starterPack?: StarterPack
  }
}

export interface StarterPackUsersResponse {
  result: {
    users?: User[]
  }
}

export interface ChannelResponse {
  result: {
    channel?: Channel
  }
}

export interface ChannelUsersResponse {
  result: {
    users?: User[]
  }
}

export interface UsersResponse {
  result: {
    users: User[]
  }
}

export interface UsersWithCountResponse {
  result: {
    users: User[]
    totalCount: number
  }
}

export type FrameApp = Record<string, unknown>;

export interface FrameAppsResponse {
  result?: {
    frames?: FrameApp[]
  }
}

export interface VerifiedAddress {
  fid?: number
  address?: string
  timestamp?: number
  version?: string
  protocol?: string
  isPrimary?: boolean
  labels?: string[]
}

export interface MutedKeywordProperties {
  channels?: boolean
  frames?: boolean
  notifications?: boolean
}

export interface MutedKeyword {
  keyword: string
  properties: MutedKeywordProperties
}

export interface MutedKeywordsResponse {
  success: boolean
  result: {
    keywords: string[]
    mutedKeywords: MutedKeyword[]
  }
}

export interface CastHashResponse {
  result: {
    castHash?: string
  }
}

export interface AttachEmbedsResponse {
  result: Record<string, unknown>
}

export interface CastRecastersResponse {
  result: {
    users?: User[]
  }
}

export interface CastQuote {
  hash?: string
  threadHash?: string
  parentSource?: {
    type?: string
    url?: string
  }
  author?: User
  text?: string
  timestamp?: number
}

export interface CastQuotesResponse {
  result: {
    quotes?: CastQuote[]
  }
}

export interface UserResponseUserResponse {
  result?: {
    user?: User
  }
}

export interface SearchChannelsResponse {
  result?: {
    channels?: Channel[]
  }
}

export interface DraftsResponse {
  result?: {
    drafts?: unknown[]
  }
}

export interface DraftCast {
  text?: string
  embeds?: unknown[]
}

export interface Draft {
  draftId?: string
  casts?: DraftCast[]
}

export interface DraftCreatedResponse {
  result?: {
    draft?: Draft
  }
}

export interface ImageEmbed {
  type?: 'image'
  url?: string
  sourceUrl?: string
  media?: {
    version?: string
    width?: number
    height?: number
    staticRaster?: string
    mimeType?: string
  }
  alt?: string
}

export interface UrlEmbed {
  type?: 'url'
  openGraph?: {
    url?: string
    sourceUrl?: string
    title?: string
    description?: string
    domain?: string
    image?: string
    useLargeImage?: boolean
  }
}

export interface VideoEmbed {
  type?: 'video'
}

export interface Recaster {
  fid?: number
  username?: string
  displayName?: string
  recastHash?: string
}

export interface Cast {
  /**
   * Unique hash identifier for the cast
   */
  hash?: string
  /**
   * Hash identifier for the thread this cast belongs to
   */
  threadHash?: string
  /**
   * Hash identifier of the parent cast (if this is a reply)
   */
  parentHash?: string
  parentSource?: {
    type?: 'url'
    url?: string
  }
  author?: User
  /**
   * The text content of the cast
   */
  text?: string
  /**
   * Unix timestamp in milliseconds
   */
  timestamp?: bigint
  mentions?: User[]
  embeds?: {
    images?: ImageEmbed[]
    urls?: UrlEmbed[]
    videos?: VideoEmbed[]
    unknowns?: Record<string, unknown>[]
    processedCastText?: string
    groupInvites?: Record<string, unknown>[]
  }
  replies?: {
    count?: number
  }
  reactions?: {
    count?: number
  }
  recasts?: {
    count?: number
    recasters?: Recaster[]
  }
  watches?: {
    count?: number
  }
  recast?: boolean
  tags?: {
    type?: string
    id?: string
    name?: string
    imageUrl?: string
  }[]
  quoteCount?: number
  combinedRecastCount?: number
  channel?: {
    key?: string
    name?: string
    imageUrl?: string
    authorContext?: {
      role?: string
      restricted?: boolean
      banned?: boolean
    }
    authorRole?: string
  }
  viewerContext?: {
    reacted?: boolean
    recast?: boolean
    bookmarked?: boolean
  }
}

export interface CastCreatedResponse {
  result?: {
    cast?: Cast
  }
}

export interface RawChannel {
  id?: string
  url?: string
  name?: string
  description?: string
  descriptionMentions?: number[]
  descriptionMentionsPositions?: number[]
  imageUrl?: string
  headerImageUrl?: string
  leadFid?: number
  moderatorFids?: number[]
  createdAt?: number
  followerCount?: number
  memberCount?: number
  pinnedCastHash?: string
  publicCasting?: boolean
  externalLink?: {
    title?: string
    url?: string
  }
}

export interface ChannelListResponse {
  result?: {
    channels?: RawChannel[]
  }
}

export interface RawChannelResponse {
  result?: {
    channel?: RawChannel
  }
}

export interface ChannelFollower {
  fid?: number
  followedAt?: number
}

export interface ChannelFollowersResponse {
  result?: {
    users?: ChannelFollower[]
    next?: {
      cursor?: string
    }
  }
}

export interface ChannelFollowStatus {
  following?: boolean
  followedAt?: number
}

export interface ChannelFollowStatusResponse {
  result?: ChannelFollowStatus
}

export interface Action {
  name?: string
  icon?: string
  description?: string
  aboutUrl?: string
  imageUrl?: string
  actionUrl?: string
  action?: {
    actionType?: 'post' | 'get' | 'put' | 'delete'
    postUrl?: string
  }
}

export interface Winner {
  /**
   * The fid of the winner
   */
  fid?: number
  /**
   * The domain of the winner
   */
  domain?: string
  /**
   * The name of the frame (mini app)
   */
  frameName?: string
  /**
   * The score of the winner
   */
  score?: number
  /**
   * The rank of the winner
   */
  rank?: number
  /**
   * The reward amount in cents
   */
  rewardCents?: number
  /**
   * The wallet address of the winner (optional)
   */
  walletAddress?: string
}

export interface Frame {
  domain?: string
  name?: string
  iconUrl?: string
  homeUrl?: string
  splashImageUrl?: string
  splashBackgroundColor?: string
  buttonTitle?: string | null
  imageUrl?: string | null
  supportsNotifications?: boolean
  viewerContext?: Record<string, unknown>
  author?: User
}

export interface AppsByAuthorResponse {
  result?: {
    frames?: Frame[]
  }
}

export interface ApiKey {
  /**
   * Unique identifier for the API key
   */
  id: string
  /**
   * Timestamp when the API key was created (in milliseconds since epoch)
   */
  createdAt: bigint
  /**
   * Timestamp when the API key expires (in milliseconds since epoch)
   */
  expiresAt: bigint
  /**
   * Timestamp when the API key was revoked, if applicable (in milliseconds since epoch)
   */
  revokedAt?: string | null
  /**
   * Short identifier tag for the API key
   */
  tag: string
  /**
   * User-provided description of the API key's purpose
   */
  description: string
}

/**
 * The user's FID (Farcaster ID)
 */
export type FidParam = number

/**
 * Maximum number of items to return
 */
export type LimitParam = number

export interface GetUserOnboardingStateData {
  body?: never
  path?: never
  query?: never
  url: '/v2/onboarding-state'
}

export interface GetUserOnboardingStateErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetUserOnboardingStateError =
  GetUserOnboardingStateErrors[keyof GetUserOnboardingStateErrors]

export interface GetUserOnboardingStateResponses {
  /**
   * Successful retrieval of onboarding state
   */
  200: OnboardingStateResponse
}

export type GetUserOnboardingStateResponse =
  GetUserOnboardingStateResponses[keyof GetUserOnboardingStateResponses]

export interface GetUserByFidData {
  body?: never
  path?: never
  query: {
    /**
     * The user's FID (Farcaster ID)
     */
    fid: number
  }
  url: '/v2/user-by-fid'
}

export interface GetUserByFidErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * The specified resource was not found
   */
  404: ErrorResponse
}

export type GetUserByFidError = GetUserByFidErrors[keyof GetUserByFidErrors]

export interface GetUserByFidResponses {
  /**
   * Successful retrieval of user by fid
   */
  200: UserByFidResponse
}

export type GetUserByFidResponse =
  GetUserByFidResponses[keyof GetUserByFidResponses]

export interface GetDirectCastInboxData {
  body?: never
  path?: never
  query?: {
    /**
     * Maximum number of items to return
     */
    limit?: number
    /**
     * Filter by category of direct casts
     */
    category?: string
  }
  url: '/v2/direct-cast-inbox'
}

export interface GetDirectCastInboxErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetDirectCastInboxError =
  GetDirectCastInboxErrors[keyof GetDirectCastInboxErrors]

export interface GetDirectCastInboxResponses {
  /**
   * Successful retrieval of direct cast inbox
   */
  200: DirectCastInboxResponse
}

export type GetDirectCastInboxResponse =
  GetDirectCastInboxResponses[keyof GetDirectCastInboxResponses]

export interface GetUserAppContextData {
  body?: never
  path?: never
  query?: never
  url: '/v2/user-app-context'
}

export interface GetUserAppContextErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetUserAppContextError =
  GetUserAppContextErrors[keyof GetUserAppContextErrors]

export interface GetUserAppContextResponses {
  /**
   * Successful retrieval of user app context
   */
  200: UserAppContextResponse
}

export type GetUserAppContextResponse =
  GetUserAppContextResponses[keyof GetUserAppContextResponses]

export interface GetUserPreferencesData {
  body?: never
  path?: never
  query?: never
  url: '/v2/user-preferences'
}

export interface GetUserPreferencesErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetUserPreferencesError =
  GetUserPreferencesErrors[keyof GetUserPreferencesErrors]

export interface GetUserPreferencesResponses {
  /**
   * Successful retrieval of user preferences
   */
  200: UserPreferencesResponse
}

export type GetUserPreferencesResponse =
  GetUserPreferencesResponses[keyof GetUserPreferencesResponses]

export interface GetHighlightedChannelsData {
  body?: never
  path?: never
  query?: never
  url: '/v2/highlighted-channels'
}

export interface GetHighlightedChannelsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetHighlightedChannelsError =
  GetHighlightedChannelsErrors[keyof GetHighlightedChannelsErrors]

export interface GetHighlightedChannelsResponses {
  /**
   * Successful retrieval of highlighted channels
   */
  200: HighlightedChannelsResponse
}

export type GetHighlightedChannelsResponse =
  GetHighlightedChannelsResponses[keyof GetHighlightedChannelsResponses]

export interface GetFeedItemsData {
  body: {
    /**
     * Identifier for the specific feed
     */
    feedKey: string
    /**
     * Type of feed to retrieve
     */
    feedType: string
    /**
     * View events for casts
     */
    castViewEvents?: Record<string, unknown>[]
    /**
     * Whether to update the feed state
     */
    updateState?: boolean
  }
  path?: never
  query?: never
  url: '/v2/feed-items'
}

export interface GetFeedItemsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetFeedItemsError = GetFeedItemsErrors[keyof GetFeedItemsErrors]

export interface GetFeedItemsResponses {
  /**
   * Successful retrieval of feed items
   */
  200: FeedItemsResponse
}

export type GetFeedItemsResponse =
  GetFeedItemsResponses[keyof GetFeedItemsResponses]

export interface GetUserData {
  body?: never
  path?: never
  query: {
    /**
     * The user's FID (Farcaster ID)
     */
    fid: number
  }
  url: '/v2/user'
}

export interface GetUserErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * The specified resource was not found
   */
  404: ErrorResponse
}

export type GetUserError = GetUserErrors[keyof GetUserErrors]

export interface GetUserResponses {
  /**
   * Successful retrieval of user information
   */
  200: UserResponse
}

export type GetUserResponse = GetUserResponses[keyof GetUserResponses]

export interface GetUserFollowingChannelsData {
  body?: never
  path?: never
  query?: {
    /**
     * Whether results are intended for the composer interface
     */
    forComposer?: boolean
    /**
     * Maximum number of items to return
     */
    limit?: number
  }
  url: '/v2/user-following-channels'
}

export interface GetUserFollowingChannelsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetUserFollowingChannelsError =
  GetUserFollowingChannelsErrors[keyof GetUserFollowingChannelsErrors]

export interface GetUserFollowingChannelsResponses {
  /**
   * Successful retrieval of followed channels
   */
  200: HighlightedChannelsResponse
}

export type GetUserFollowingChannelsResponse =
  GetUserFollowingChannelsResponses[keyof GetUserFollowingChannelsResponses]

export interface GetSuggestedUsersData {
  body?: never
  path?: never
  query?: {
    /**
     * Maximum number of items to return
     */
    limit?: number
    randomized?: boolean
  }
  url: '/v2/suggested-users'
}

export interface GetSuggestedUsersErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetSuggestedUsersError =
  GetSuggestedUsersErrors[keyof GetSuggestedUsersErrors]

export interface GetSuggestedUsersResponses {
  /**
   * Successful retrieval of suggested users
   */
  200: SuggestedUsersResponse
}

export type GetSuggestedUsersResponse =
  GetSuggestedUsersResponses[keyof GetSuggestedUsersResponses]

export interface GetUserFavoriteFramesData {
  body?: never
  path?: never
  query?: {
    /**
     * Maximum number of items to return
     */
    limit?: number
  }
  url: '/v1/favorite-frames'
}

export interface GetUserFavoriteFramesErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetUserFavoriteFramesError =
  GetUserFavoriteFramesErrors[keyof GetUserFavoriteFramesErrors]

export interface GetUserFavoriteFramesResponses {
  /**
   * Successful retrieval of favorite frames
   */
  200: FavoriteFramesResponse
}

export type GetUserFavoriteFramesResponse =
  GetUserFavoriteFramesResponses[keyof GetUserFavoriteFramesResponses]

export interface GetUserByUsernameData {
  body?: never
  path?: never
  query: {
    username: string
  }
  url: '/v2/user-by-username'
}

export interface GetUserByUsernameErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * The specified resource was not found
   */
  404: ErrorResponse
}

export type GetUserByUsernameError =
  GetUserByUsernameErrors[keyof GetUserByUsernameErrors]

export interface GetUserByUsernameResponses {
  /**
   * Successful retrieval of user by username
   */
  200: UserResponse
}

export type GetUserByUsernameResponse =
  GetUserByUsernameResponses[keyof GetUserByUsernameResponses]

export interface GetChannelStreaksForUserData {
  body?: never
  path?: never
  query: {
    fid: number
  }
  url: '/v2/channel-streaks'
}

export interface GetChannelStreaksForUserErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetChannelStreaksForUserError =
  GetChannelStreaksForUserErrors[keyof GetChannelStreaksForUserErrors]

export interface GetChannelStreaksForUserResponses {
  /**
   * Successful retrieval of channel streaks
   */
  200: ChannelStreaksResponse
}

export type GetChannelStreaksForUserResponse =
  GetChannelStreaksForUserResponses[keyof GetChannelStreaksForUserResponses]

export interface GetUnseenCountsData {
  body?: never
  path?: never
  query?: never
  url: '/v2/unseen'
}

export interface GetUnseenCountsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetUnseenCountsError =
  GetUnseenCountsErrors[keyof GetUnseenCountsErrors]

export interface GetUnseenCountsResponses {
  /**
   * Successful retrieval of unseen feed and notification data
   */
  200: UnseenCountsResponse
}

export type GetUnseenCountsResponse =
  GetUnseenCountsResponses[keyof GetUnseenCountsResponses]

export interface GetUserThreadCastsData {
  body?: never
  path?: never
  query: {
    /**
     * Maximum number of items to return
     */
    limit?: number
    /**
     * The hash prefix of the cast
     */
    castHashPrefix: string
    /**
     * The username of the user
     */
    username: string
  }
  url: '/v2/user-thread-casts'
}

export interface GetUserThreadCastsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetUserThreadCastsError =
  GetUserThreadCastsErrors[keyof GetUserThreadCastsErrors]

export interface GetUserThreadCastsResponses {
  /**
   * Successful retrieval of user thread casts
   */
  200: UserThreadCastsResponse
}

export type GetUserThreadCastsResponse =
  GetUserThreadCastsResponses[keyof GetUserThreadCastsResponses]

export interface GetChannelFollowersYouKnowData {
  body?: never
  path?: never
  query: {
    channelKey: string
    limit?: number
  }
  url: '/v2/channel-followers-you-know'
}

export interface GetChannelFollowersYouKnowErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetChannelFollowersYouKnowError =
  GetChannelFollowersYouKnowErrors[keyof GetChannelFollowersYouKnowErrors]

export interface GetChannelFollowersYouKnowResponses {
  /**
   * Successful retrieval of known channel followers
   */
  200: ChannelFollowersYouKnowResponse
}

export type GetChannelFollowersYouKnowResponse =
  GetChannelFollowersYouKnowResponses[keyof GetChannelFollowersYouKnowResponses]

export interface MarkAllNotificationsReadData {
  body: Record<string, never>
  path?: never
  query?: never
  url: '/v2/mark-all-notifications-read'
}

export interface MarkAllNotificationsReadErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type MarkAllNotificationsReadError =
  MarkAllNotificationsReadErrors[keyof MarkAllNotificationsReadErrors]

export interface MarkAllNotificationsReadResponses {
  /**
   * Successful mark-all-read operation
   */
  200: SuccessResponse
}

export type MarkAllNotificationsReadResponse =
  MarkAllNotificationsReadResponses[keyof MarkAllNotificationsReadResponses]

export interface GetNotificationsData {
  body?: never
  path?: never
  query: {
    /**
     * Notification tab type
     */
    tab: 'all' | 'follows' | 'reactions' | 'mentions' | 'replies'
    /**
     * Number of notifications to return
     */
    limit?: number
  }
  url: '/v1/notifications-for-tab'
}

export interface GetNotificationsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Too many requests
   */
  429: unknown
}

export type GetNotificationsError =
  GetNotificationsErrors[keyof GetNotificationsErrors]

export interface GetNotificationsResponses {
  /**
   * A list of notifications
   */
  200: NotificationsResponse
}

export type GetNotificationsResponse =
  GetNotificationsResponses[keyof GetNotificationsResponses]

export interface SetLastCheckedTimestampData {
  /**
   * Empty object for now
   */
  body: Record<string, unknown>
  path?: never
  query?: never
  url: '/v2/set-last-checked-timestamp'
}

export interface SetLastCheckedTimestampErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Too many requests
   */
  429: unknown
}

export type SetLastCheckedTimestampError =
  SetLastCheckedTimestampErrors[keyof SetLastCheckedTimestampErrors]

export interface SetLastCheckedTimestampResponses {
  /**
   * Success
   */
  200: SuccessResponse
}

export type SetLastCheckedTimestampResponse =
  SetLastCheckedTimestampResponses[keyof SetLastCheckedTimestampResponses]

export interface GetDirectCastConversationData {
  body?: never
  path?: never
  query: {
    /**
     * Conversation ID in the format fid1-fid2
     */
    conversationId: string
  }
  url: '/v2/direct-cast-conversation'
}

export interface GetDirectCastConversationErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Too many requests
   */
  429: unknown
}

export type GetDirectCastConversationError =
  GetDirectCastConversationErrors[keyof GetDirectCastConversationErrors]

export interface GetDirectCastConversationResponses {
  /**
   * A direct cast conversation object
   */
  200: DirectCastConversationResponse
}

export type GetDirectCastConversationResponse =
  GetDirectCastConversationResponses[keyof GetDirectCastConversationResponses]

export interface DiscoverChannelsData {
  body?: never
  path?: never
  query?: {
    /**
     * Maximum number of channels to retrieve
     */
    limit?: number
  }
  url: '/v2/discover-channels'
}

export interface DiscoverChannelsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Too many requests
   */
  429: unknown
}

export type DiscoverChannelsError =
  DiscoverChannelsErrors[keyof DiscoverChannelsErrors]

export interface DiscoverChannelsResponses {
  /**
   * A list of channels
   */
  200: DiscoverChannelsResponse
}

export type DiscoverChannelsResponse2 =
  DiscoverChannelsResponses[keyof DiscoverChannelsResponses]

export interface GetAvailableInvitesData {
  body?: never
  path?: never
  query?: never
  url: '/v2/invites-available'
}

export interface GetAvailableInvitesErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Too many requests
   */
  429: unknown
}

export type GetAvailableInvitesError =
  GetAvailableInvitesErrors[keyof GetAvailableInvitesErrors]

export interface GetAvailableInvitesResponses {
  /**
   * Invite count information
   */
  200: InvitesAvailableResponse
}

export type GetAvailableInvitesResponse =
  GetAvailableInvitesResponses[keyof GetAvailableInvitesResponses]

export interface GetSponsoredInvitesData {
  body?: never
  path?: never
  query?: never
  url: '/v2/warpcast-sponsored-invites'
}

export interface GetSponsoredInvitesErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Too many requests
   */
  429: unknown
}

export type GetSponsoredInvitesError =
  GetSponsoredInvitesErrors[keyof GetSponsoredInvitesErrors]

export interface GetSponsoredInvitesResponses {
  /**
   * List of sponsored invites
   */
  200: SponsoredInvitesResponse
}

export type GetSponsoredInvitesResponse =
  GetSponsoredInvitesResponses[keyof GetSponsoredInvitesResponses]

export interface GetRewardsLeaderboardData {
  body?: never
  path?: never
  query: {
    /**
     * Maximum number of items to return
     */
    limit?: number
    rewardsType: 'invite'
    cursor?: string
  }
  url: '/v2/rewards-leaderboard'
}

export interface GetRewardsLeaderboardErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Too many requests
   */
  429: unknown
}

export type GetRewardsLeaderboardError =
  GetRewardsLeaderboardErrors[keyof GetRewardsLeaderboardErrors]

export interface GetRewardsLeaderboardResponses {
  /**
   * Rewards leaderboard
   */
  200: RewardsLeaderboardResponse
}

export type GetRewardsLeaderboardResponse =
  GetRewardsLeaderboardResponses[keyof GetRewardsLeaderboardResponses]

export interface GetUserRewardsScoresData {
  body?: never
  path?: never
  query: {
    /**
     * The user's FID (Farcaster ID)
     */
    fid: number
    rewardsType: 'invite'
  }
  url: '/v2/rewards-scores-for-user'
}

export interface GetUserRewardsScoresErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Too many requests
   */
  429: unknown
}

export type GetUserRewardsScoresError =
  GetUserRewardsScoresErrors[keyof GetUserRewardsScoresErrors]

export interface GetUserRewardsScoresResponses {
  /**
   * User rewards scores
   */
  200: RewardsScoresResponse
}

export type GetUserRewardsScoresResponse =
  GetUserRewardsScoresResponses[keyof GetUserRewardsScoresResponses]

export interface GetRewardsMetadataData {
  body?: never
  path?: never
  query: {
    rewardsType: 'invite'
  }
  url: '/v2/rewards-metadata'
}

export interface GetRewardsMetadataErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Too many requests
   */
  429: unknown
}

export type GetRewardsMetadataError =
  GetRewardsMetadataErrors[keyof GetRewardsMetadataErrors]

export interface GetRewardsMetadataResponses {
  /**
   * Invite rewards metadata
   */
  200: RewardsMetadataResponse
}

export type GetRewardsMetadataResponse =
  GetRewardsMetadataResponses[keyof GetRewardsMetadataResponses]

export interface GetBookmarkedCastsData {
  body?: never
  path?: never
  query?: {
    /**
     * Maximum number of items to return
     */
    limit?: number
  }
  url: '/v2/bookmarked-casts'
}

export interface GetBookmarkedCastsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetBookmarkedCastsError =
  GetBookmarkedCastsErrors[keyof GetBookmarkedCastsErrors]

export interface GetBookmarkedCastsResponses {
  /**
   * A list of bookmarked casts
   */
  200: BookmarkedCastsResponse
}

export type GetBookmarkedCastsResponse =
  GetBookmarkedCastsResponses[keyof GetBookmarkedCastsResponses]

export interface GetUserStarterPacksData {
  body?: never
  path?: never
  query: {
    fid: number
    limit?: number
  }
  url: '/v2/starter-packs'
}

export interface GetUserStarterPacksErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetUserStarterPacksError =
  GetUserStarterPacksErrors[keyof GetUserStarterPacksErrors]

export interface GetUserStarterPacksResponses {
  /**
   * A list of starter packs
   */
  200: StarterPacksResponse
}

export type GetUserStarterPacksResponse =
  GetUserStarterPacksResponses[keyof GetUserStarterPacksResponses]

export interface GetSuggestedStarterPacksData {
  body?: never
  path?: never
  query?: {
    limit?: number
  }
  url: '/v2/starter-packs/suggested'
}

export interface GetSuggestedStarterPacksErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetSuggestedStarterPacksError =
  GetSuggestedStarterPacksErrors[keyof GetSuggestedStarterPacksErrors]

export interface GetSuggestedStarterPacksResponses {
  /**
   * A list of suggested starter packs
   */
  200: StarterPacksResponse
}

export type GetSuggestedStarterPacksResponse =
  GetSuggestedStarterPacksResponses[keyof GetSuggestedStarterPacksResponses]

export interface GetStarterPackData {
  body?: never
  path?: never
  query: {
    id: string
  }
  url: '/v2/starter-pack'
}

export interface GetStarterPackErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetStarterPackError =
  GetStarterPackErrors[keyof GetStarterPackErrors]

export interface GetStarterPackResponses {
  /**
   * A starter pack object
   */
  200: StarterPackResponse
}

export type GetStarterPackResponse =
  GetStarterPackResponses[keyof GetStarterPackResponses]

export interface GetStarterPackUsersData {
  body?: never
  path?: never
  query: {
    /**
     * Maximum number of items to return
     */
    limit?: number
    id: string
  }
  url: '/v2/starter-pack-users'
}

export interface GetStarterPackUsersErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetStarterPackUsersError =
  GetStarterPackUsersErrors[keyof GetStarterPackUsersErrors]

export interface GetStarterPackUsersResponses {
  /**
   * List of users in the starter pack
   */
  200: StarterPackUsersResponse
}

export type GetStarterPackUsersResponse =
  GetStarterPackUsersResponses[keyof GetStarterPackUsersResponses]

export interface GetChannelData {
  body?: never
  path?: never
  query: {
    key: string
  }
  url: '/v2/channel'
}

export interface GetChannelErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetChannelError = GetChannelErrors[keyof GetChannelErrors]

export interface GetChannelResponses {
  /**
   * Channel metadata
   */
  200: ChannelResponse
}

export type GetChannelResponse = GetChannelResponses[keyof GetChannelResponses]

export interface GetChannelUsersData {
  body?: never
  path?: never
  query: {
    /**
     * Maximum number of items to return
     */
    limit?: number
    channelKey: string
    filterToMembers?: boolean
    query?: string
  }
  url: '/v1/channel-users'
}

export interface GetChannelUsersErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetChannelUsersError =
  GetChannelUsersErrors[keyof GetChannelUsersErrors]

export interface GetChannelUsersResponses {
  /**
   * A list of users in the specified channel
   */
  200: ChannelUsersResponse
}

export type GetChannelUsersResponse =
  GetChannelUsersResponses[keyof GetChannelUsersResponses]

export interface GetFollowingData {
  body?: never
  path?: never
  query: {
    fid: number
    limit?: number
  }
  url: '/v2/following'
}

export interface GetFollowingErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetFollowingError = GetFollowingErrors[keyof GetFollowingErrors]

export interface GetFollowingResponses {
  /**
   * A list of followed users
   */
  200: UsersResponse
}

export type GetFollowingResponse =
  GetFollowingResponses[keyof GetFollowingResponses]

export interface GetFollowersData {
  body?: never
  path?: never
  query: {
    fid: number
    limit?: number
  }
  url: '/v2/followers'
}

export interface GetFollowersErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetFollowersError = GetFollowersErrors[keyof GetFollowersErrors]

export interface GetFollowersResponses {
  /**
   * A list of followers
   */
  200: UsersResponse
}

export type GetFollowersResponse =
  GetFollowersResponses[keyof GetFollowersResponses]

export interface GetMutualFollowersData {
  body?: never
  path?: never
  query: {
    fid: number
    limit?: number
  }
  url: '/v2/followers-you-know'
}

export interface GetMutualFollowersErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetMutualFollowersError =
  GetMutualFollowersErrors[keyof GetMutualFollowersErrors]

export interface GetMutualFollowersResponses {
  /**
   * A list of mutual followers
   */
  200: UsersWithCountResponse
}

export type GetMutualFollowersResponse =
  GetMutualFollowersResponses[keyof GetMutualFollowersResponses]

export interface GetTopFrameAppsData {
  body?: never
  path?: never
  query?: {
    /**
     * Maximum number of items to return
     */
    limit?: number
    cursor?: string
  }
  url: '/v1/top-frameapps'
}

export interface GetTopFrameAppsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetTopFrameAppsError =
  GetTopFrameAppsErrors[keyof GetTopFrameAppsErrors]

export interface GetTopFrameAppsResponses {
  /**
   * A list of FrameApps
   */
  200: FrameAppsResponse
}

export type GetTopFrameAppsResponse =
  GetTopFrameAppsResponses[keyof GetTopFrameAppsResponses]

export interface GetVerificationsData {
  body?: never
  path?: never
  query: {
    /**
     * The user's FID (Farcaster ID)
     */
    fid: number
    /**
     * Maximum number of items to return
     */
    limit?: number
  }
  url: '/v2/verifications'
}

export interface GetVerificationsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetVerificationsError =
  GetVerificationsErrors[keyof GetVerificationsErrors]

export interface GetVerificationsResponses {
  /**
   * A list of verifications
   */
  200: {
    result?: {
      verifications?: VerifiedAddress[]
    }
  }
}

export type GetVerificationsResponse =
  GetVerificationsResponses[keyof GetVerificationsResponses]

export interface GetMutedKeywordsData {
  body?: never
  path?: never
  query?: never
  url: '/v2/get-muted-keywords'
}

export interface GetMutedKeywordsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetMutedKeywordsError =
  GetMutedKeywordsErrors[keyof GetMutedKeywordsErrors]

export interface GetMutedKeywordsResponses {
  /**
   * A list of muted keywords
   */
  200: MutedKeywordsResponse
}

export type GetMutedKeywordsResponse =
  GetMutedKeywordsResponses[keyof GetMutedKeywordsResponses]

export interface MuteKeywordData {
  body: {
    keyword?: string
    properties?: MutedKeywordProperties
  }
  path?: never
  query?: never
  url: '/v2/mute-keyword'
}

export interface MuteKeywordErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type MuteKeywordError = MuteKeywordErrors[keyof MuteKeywordErrors]

export interface MuteKeywordResponses {
  /**
   * The muted keyword and its settings
   */
  200: MutedKeywordsResponse
}

export type MuteKeywordResponse =
  MuteKeywordResponses[keyof MuteKeywordResponses]

export interface UnmuteKeywordData {
  body: {
    keyword?: string
  }
  path?: never
  query?: never
  url: '/v2/unmute-keyword'
}

export interface UnmuteKeywordErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type UnmuteKeywordError = UnmuteKeywordErrors[keyof UnmuteKeywordErrors]

export interface UnmuteKeywordResponses {
  /**
   * Keyword unmuted
   */
  200: MutedKeywordsResponse
}

export type UnmuteKeywordResponse =
  UnmuteKeywordResponses[keyof UnmuteKeywordResponses]

export interface UnlikeCastData {
  body: {
    castHash: string
  }
  path?: never
  query?: never
  url: '/v2/cast-likes'
}

export interface UnlikeCastErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type UnlikeCastError = UnlikeCastErrors[keyof UnlikeCastErrors]

export interface UnlikeCastResponses {
  /**
   * Unlike response
   */
  200: {
    result?: {
      success?: boolean
    }
  }
}

export type UnlikeCastResponse = UnlikeCastResponses[keyof UnlikeCastResponses]

export interface GetCastLikesData {
  body?: never
  path?: never
  query: {
    castHash: string
    limit?: number
  }
  url: '/v2/cast-likes'
}

export interface GetCastLikesErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetCastLikesError = GetCastLikesErrors[keyof GetCastLikesErrors]

export interface GetCastLikesResponses {
  /**
   * A list of cast likes
   */
  200: {
    result?: {
      likes?: {
        type?: string
        hash?: string
        castHash?: string
        timestamp?: number
        reactor?: User
      }[]
    }
  }
}

export type GetCastLikesResponse =
  GetCastLikesResponses[keyof GetCastLikesResponses]

export interface LikeCastData {
  body: {
    castHash: string
  }
  path?: never
  query?: never
  url: '/v2/cast-likes'
}

export interface LikeCastErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type LikeCastError = LikeCastErrors[keyof LikeCastErrors]

export interface LikeCastResponses {
  /**
   * Like response
   */
  200: {
    result?: {
      like?: {
        type?: string
        hash?: string
        castHash?: string
        timestamp?: number
        reactor?: User
      }
    }
  }
}

export type LikeCastResponse = LikeCastResponses[keyof LikeCastResponses]

export interface UndoRecastData {
  body: {
    castHash: string
  }
  path?: never
  query?: never
  url: '/v2/recasts'
}

export interface UndoRecastErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type UndoRecastError = UndoRecastErrors[keyof UndoRecastErrors]

export interface UndoRecastResponses {
  /**
   * Undo recast response
   */
  200: SuccessResponse
}

export type UndoRecastResponse = UndoRecastResponses[keyof UndoRecastResponses]

export interface RecastCastData {
  body: {
    castHash: string
  }
  path?: never
  query?: never
  url: '/v2/recasts'
}

export interface RecastCastErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type RecastCastError = RecastCastErrors[keyof RecastCastErrors]

export interface RecastCastResponses {
  /**
   * Recast response
   */
  200: CastHashResponse
}

export type RecastCastResponse = RecastCastResponses[keyof RecastCastResponses]

export interface AttachEmbedsData {
  body: {
    text?: string
    embeds?: string[]
  }
  path?: never
  query?: never
  url: '/v2/cast-attachments'
}

export interface AttachEmbedsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type AttachEmbedsError = AttachEmbedsErrors[keyof AttachEmbedsErrors]

export interface AttachEmbedsResponses {
  /**
   * Attachment response
   */
  200: AttachEmbedsResponse
}

export type AttachEmbedsResponse2 =
  AttachEmbedsResponses[keyof AttachEmbedsResponses]

export interface GetCastRecastersData {
  body?: never
  path?: never
  query: {
    /**
     * Maximum number of items to return
     */
    limit?: number
    castHash: string
  }
  url: '/v2/cast-recasters'
}

export interface GetCastRecastersErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetCastRecastersError =
  GetCastRecastersErrors[keyof GetCastRecastersErrors]

export interface GetCastRecastersResponses {
  /**
   * A list of users who recasted the cast
   */
  200: CastRecastersResponse
}

export type GetCastRecastersResponse =
  GetCastRecastersResponses[keyof GetCastRecastersResponses]

export interface GetCastQuotesData {
  body?: never
  path?: never
  query: {
    castHash: string
    limit?: number
  }
  url: '/v2/cast-quotes'
}

export interface GetCastQuotesErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetCastQuotesError = GetCastQuotesErrors[keyof GetCastQuotesErrors]

export interface GetCastQuotesResponses {
  /**
   * A list of quote casts referencing the given cast
   */
  200: CastQuotesResponse
}

export type GetCastQuotesResponse =
  GetCastQuotesResponses[keyof GetCastQuotesResponses]

export interface GetCurrentUserData {
  body?: never
  path?: never
  query?: never
  url: '/v2/me'
}

export interface GetCurrentUserErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetCurrentUserError =
  GetCurrentUserErrors[keyof GetCurrentUserErrors]

export interface GetCurrentUserResponses {
  /**
   * Successful retrieval of current user
   */
  200: UserResponseUserResponse
}

export type GetCurrentUserResponse =
  GetCurrentUserResponses[keyof GetCurrentUserResponses]

export interface SearchChannelsData {
  body?: never
  path?: never
  query?: {
    /**
     * Maximum number of items to return
     */
    limit?: number
    q?: string
    prioritizeFollowed?: boolean
    forComposer?: boolean
  }
  url: '/v2/search-channels'
}

export interface SearchChannelsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type SearchChannelsError =
  SearchChannelsErrors[keyof SearchChannelsErrors]

export interface SearchChannelsResponses {
  /**
   * A list of matched channels
   */
  200: SearchChannelsResponse
}

export type SearchChannelsResponse2 =
  SearchChannelsResponses[keyof SearchChannelsResponses]

export interface GetDraftCastsData {
  body?: never
  path?: never
  query?: {
    limit?: number
  }
  url: '/v2/draft-caststorms'
}

export interface GetDraftCastsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetDraftCastsError = GetDraftCastsErrors[keyof GetDraftCastsErrors]

export interface GetDraftCastsResponses {
  /**
   * A list of draft cast storms
   */
  200: DraftsResponse
}

export type GetDraftCastsResponse =
  GetDraftCastsResponses[keyof GetDraftCastsResponses]

export interface CreateDraftCastsData {
  body: {
    caststorm?: {
      casts?: DraftCast[]
    }
  }
  headers: {
    'idempotency-key': string
  }
  path?: never
  query?: never
  url: '/v2/draft-caststorms'
}

export interface CreateDraftCastsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type CreateDraftCastsError =
  CreateDraftCastsErrors[keyof CreateDraftCastsErrors]

export interface CreateDraftCastsResponses {
  /**
   * Created draft caststorm
   */
  200: DraftCreatedResponse
}

export type CreateDraftCastsResponse =
  CreateDraftCastsResponses[keyof CreateDraftCastsResponses]

export interface DeleteDraftCastData {
  body: {
    draftId?: string
  }
  path?: never
  query?: never
  url: '/v2/draft-casts'
}

export interface DeleteDraftCastErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type DeleteDraftCastError =
  DeleteDraftCastErrors[keyof DeleteDraftCastErrors]

export interface DeleteDraftCastResponses {
  /**
   * Draft cast deleted
   */
  200: SuccessResponse
}

export type DeleteDraftCastResponse =
  DeleteDraftCastResponses[keyof DeleteDraftCastResponses]

export interface DeleteCastData {
  body: {
    castHash?: string
  }
  path?: never
  query?: never
  url: '/v2/casts'
}

export interface DeleteCastErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type DeleteCastError = DeleteCastErrors[keyof DeleteCastErrors]

export interface DeleteCastResponses {
  /**
   * Cast deleted successfully
   */
  200: SuccessResponse
}

export type DeleteCastResponse = DeleteCastResponses[keyof DeleteCastResponses]

export interface GetCastsByFidData {
  body?: never
  path?: never
  query: {
    /**
     * The FID (Farcaster ID) of the user whose casts to retrieve
     */
    fid: number
    /**
     * Maximum number of casts to return
     */
    limit?: number
  }
  url: '/v2/casts'
}

export interface GetCastsByFidErrors {
  /**
   * Bad request
   */
  400: ErrorResponse
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetCastsByFidError = GetCastsByFidErrors[keyof GetCastsByFidErrors]

export interface GetCastsByFidResponses {
  /**
   * Successfully retrieved casts
   */
  200: {
    result?: {
      casts?: Cast[]
    }
  }
}

export type GetCastsByFidResponse =
  GetCastsByFidResponses[keyof GetCastsByFidResponses]

export interface CreateCastData {
  body: {
    text: string
    embeds?: unknown[]
    /**
     * Optional channel to post the cast to
     */
    channelKey?: string
  }
  path?: never
  query?: never
  url: '/v2/casts'
}

export interface CreateCastErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type CreateCastError = CreateCastErrors[keyof CreateCastErrors]

export interface CreateCastResponses {
  /**
   * Cast created successfully
   */
  200: CastCreatedResponse
}

export type CreateCastResponse = CreateCastResponses[keyof CreateCastResponses]

export interface GetAllChannelsData {
  body?: never
  path?: never
  query?: never
  url: '/v2/all-channels'
}

export interface GetAllChannelsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetAllChannelsError =
  GetAllChannelsErrors[keyof GetAllChannelsErrors]

export interface GetAllChannelsResponses {
  /**
   * Successful response
   */
  200: ChannelListResponse
}

export type GetAllChannelsResponse =
  GetAllChannelsResponses[keyof GetAllChannelsResponses]

export interface GetChannelDetailsData {
  body?: never
  path?: never
  query: {
    channelId: string
  }
  url: '/v1/channel'
}

export interface GetChannelDetailsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetChannelDetailsError =
  GetChannelDetailsErrors[keyof GetChannelDetailsErrors]

export interface GetChannelDetailsResponses {
  /**
   * Channel details
   */
  200: RawChannelResponse
}

export type GetChannelDetailsResponse =
  GetChannelDetailsResponses[keyof GetChannelDetailsResponses]

export interface GetChannelFollowersData {
  body?: never
  path?: never
  query: {
    channelId: string
    cursor?: string
  }
  url: '/v1/channel-followers'
}

export interface GetChannelFollowersErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetChannelFollowersError =
  GetChannelFollowersErrors[keyof GetChannelFollowersErrors]

export interface GetChannelFollowersResponses {
  /**
   * A list of channel followers
   */
  200: ChannelFollowersResponse
}

export type GetChannelFollowersResponse =
  GetChannelFollowersResponses[keyof GetChannelFollowersResponses]

export interface GetUserFollowedChannelsData {
  body?: never
  path?: never
  query: {
    /**
     * The user's FID (Farcaster ID)
     */
    fid: number
  }
  url: '/v1/user-following-channels'
}

export interface GetUserFollowedChannelsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetUserFollowedChannelsError =
  GetUserFollowedChannelsErrors[keyof GetUserFollowedChannelsErrors]

export interface GetUserFollowedChannelsResponses {
  /**
   * Successful response with list of followed channels
   */
  200: ChannelListResponse
}

export type GetUserFollowedChannelsResponse =
  GetUserFollowedChannelsResponses[keyof GetUserFollowedChannelsResponses]

export interface CheckUserChannelFollowStatusData {
  body?: never
  path?: never
  query: {
    /**
     * The user's FID (Farcaster ID)
     */
    fid: number
    channelId: string
  }
  url: '/v1/user-channel'
}

export interface CheckUserChannelFollowStatusErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type CheckUserChannelFollowStatusError =
  CheckUserChannelFollowStatusErrors[keyof CheckUserChannelFollowStatusErrors]

export interface CheckUserChannelFollowStatusResponses {
  /**
   * Successful response with follow status
   */
  200: ChannelFollowStatusResponse
}

export type CheckUserChannelFollowStatusResponse =
  CheckUserChannelFollowStatusResponses[keyof CheckUserChannelFollowStatusResponses]

export interface GetChannelMembersData {
  body?: never
  path?: never
  query: {
    channelId: string
  }
  url: '/fc/channel-members'
}

export interface GetChannelMembersErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetChannelMembersError =
  GetChannelMembersErrors[keyof GetChannelMembersErrors]

export interface GetChannelMembersResponses {
  /**
   * Successful response with list of members
   */
  200: {
    result: {
      members: {
        /**
         * Farcaster ID of the member
         */
        fid: number
        /**
         * Timestamp when the user became a member
         */
        memberAt: number
      }[]
    }
    next?: {
      /**
       * Cursor for pagination
       */
      cursor?: string
    }
  }
}

export type GetChannelMembersResponse =
  GetChannelMembersResponses[keyof GetChannelMembersResponses]

export interface RemoveChannelInviteData {
  body: {
    /**
     * ID of the channel from which the user's invite is being removed
     */
    channelId: string
    /**
     * Farcaster ID of the user whose invite is being removed
     */
    removeFid: number
    /**
     * Role associated with the invite being removed
     */
    role: 'member' | 'admin'
  }
  path?: never
  query?: never
  url: '/fc/channel-invites'
}

export interface RemoveChannelInviteErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type RemoveChannelInviteError =
  RemoveChannelInviteErrors[keyof RemoveChannelInviteErrors]

export interface RemoveChannelInviteResponses {
  /**
   * Successful removal of invite
   */
  200: SuccessResponse
}

export type RemoveChannelInviteResponse =
  RemoveChannelInviteResponses[keyof RemoveChannelInviteResponses]

export interface GetChannelInvitesData {
  body?: never
  path?: never
  query: {
    channelId: string
  }
  url: '/fc/channel-invites'
}

export interface GetChannelInvitesErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetChannelInvitesError =
  GetChannelInvitesErrors[keyof GetChannelInvitesErrors]

export interface GetChannelInvitesResponses {
  /**
   * Successful response with list of channel invites
   */
  200: {
    result?: {
      invites?: {
        channelId: string
        invitedFid: number
        invitedAt: number
        inviterFid: number
        role: 'member' | 'admin'
      }[]
    }
    next?: {
      cursor?: string
    }
  }
}

export type GetChannelInvitesResponse =
  GetChannelInvitesResponses[keyof GetChannelInvitesResponses]

export interface AcceptChannelInviteData {
  body: {
    /**
     * ID of the channel for which the invite is being accepted
     */
    channelId: string
    /**
     * Role that the user will have in the channel
     */
    role: 'member' | 'admin'
    /**
     * Flag indicating whether to accept the invite
     */
    accept: boolean
  }
  path?: never
  query?: never
  url: '/fc/channel-invites'
}

export interface AcceptChannelInviteErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type AcceptChannelInviteError =
  AcceptChannelInviteErrors[keyof AcceptChannelInviteErrors]

export interface AcceptChannelInviteResponses {
  /**
   * Successful acceptance of invite
   */
  200: SuccessResponse
}

export type AcceptChannelInviteResponse =
  AcceptChannelInviteResponses[keyof AcceptChannelInviteResponses]

export interface InviteUserToChannelData {
  body: {
    /**
     * ID of the channel to invite the user to
     */
    channelId: string
    /**
     * Farcaster ID of the user being invited
     */
    inviteFid: number
    /**
     * Role of the invited user within the channel
     */
    role: 'member' | 'admin'
  }
  path?: never
  query?: never
  url: '/fc/channel-invites'
}

export interface InviteUserToChannelErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type InviteUserToChannelError =
  InviteUserToChannelErrors[keyof InviteUserToChannelErrors]

export interface InviteUserToChannelResponses {
  /**
   * Successful invite operation
   */
  200: SuccessResponse
}

export type InviteUserToChannelResponse =
  InviteUserToChannelResponses[keyof InviteUserToChannelResponses]

export interface GetChannelModeratedCastsData {
  body?: never
  path?: never
  query: {
    /**
     * ID of the channel to get moderation actions for
     */
    channelId: string
  }
  url: '/fc/moderated-casts'
}

export interface GetChannelModeratedCastsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetChannelModeratedCastsError =
  GetChannelModeratedCastsErrors[keyof GetChannelModeratedCastsErrors]

export interface GetChannelModeratedCastsResponses {
  /**
   * Successful response with list of moderation actions
   */
  200: {
    result: {
      moderationActions: {
        /**
         * Hash of the moderated cast
         */
        castHash: string
        /**
         * ID of the channel where the cast was moderated
         */
        channelId: string
        /**
         * Type of moderation action applied
         */
        action: 'hide'
        /**
         * Unix timestamp of when the moderation action was taken
         */
        moderatedAt: number
      }[]
    }
    next?: {
      /**
       * Pagination cursor for fetching the next set of results
       */
      cursor?: string
    }
  }
}

export type GetChannelModeratedCastsResponse =
  GetChannelModeratedCastsResponses[keyof GetChannelModeratedCastsResponses]

export interface GetChannelRestrictedUsersData {
  body?: never
  path?: never
  query: {
    /**
     * ID of the channel to get restricted users for
     */
    channelId: string
  }
  url: '/fc/channel-restricted-users'
}

export interface GetChannelRestrictedUsersErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetChannelRestrictedUsersError =
  GetChannelRestrictedUsersErrors[keyof GetChannelRestrictedUsersErrors]

export interface GetChannelRestrictedUsersResponses {
  /**
   * Successful response with list of restricted users
   */
  200: {
    result: {
      restrictedUsers: {
        /**
         * Farcaster ID of the restricted user
         */
        fid: number
        /**
         * ID of the channel where the user is restricted
         */
        channelId: string
        /**
         * Unix timestamp of when the user was restricted
         */
        restrictedAt: number
      }[]
    }
    next?: {
      /**
       * Pagination cursor for fetching the next set of results
       */
      cursor?: string
    }
  }
}

export type GetChannelRestrictedUsersResponse =
  GetChannelRestrictedUsersResponses[keyof GetChannelRestrictedUsersResponses]

export interface UnbanUserFromChannelData {
  body: {
    /**
     * ID of the channel from which to unban the user
     */
    channelId: string
    /**
     * Farcaster ID of the user to unban
     */
    banFid: number
  }
  path?: never
  query?: never
  url: '/fc/channel-bans'
}

export interface UnbanUserFromChannelErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type UnbanUserFromChannelError =
  UnbanUserFromChannelErrors[keyof UnbanUserFromChannelErrors]

export interface UnbanUserFromChannelResponses {
  /**
   * Successful unban operation
   */
  200: SuccessResponse
}

export type UnbanUserFromChannelResponse =
  UnbanUserFromChannelResponses[keyof UnbanUserFromChannelResponses]

export interface GetChannelBannedUsersData {
  body?: never
  path?: never
  query: {
    /**
     * ID of the channel to get banned users for
     */
    channelId: string
  }
  url: '/fc/channel-bans'
}

export interface GetChannelBannedUsersErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetChannelBannedUsersError =
  GetChannelBannedUsersErrors[keyof GetChannelBannedUsersErrors]

export interface GetChannelBannedUsersResponses {
  /**
   * Successful response with list of banned users
   */
  200: {
    result: {
      bannedUsers: {
        /**
         * Farcaster ID of the banned user
         */
        fid: number
        /**
         * ID of the channel where the user is banned
         */
        channelId: string
        /**
         * Unix timestamp of when the user was banned
         */
        bannedAt: number
      }[]
    }
    next?: {
      /**
       * Pagination cursor for fetching the next set of banned users
       */
      cursor?: string
    }
  }
}

export type GetChannelBannedUsersResponse =
  GetChannelBannedUsersResponses[keyof GetChannelBannedUsersResponses]

export interface BanUserFromChannelData {
  body: {
    /**
     * ID of the channel from which to ban the user
     */
    channelId: string
    /**
     * Farcaster ID of the user to ban
     */
    banFid: number
  }
  path?: never
  query?: never
  url: '/fc/channel-bans'
}

export interface BanUserFromChannelErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type BanUserFromChannelError =
  BanUserFromChannelErrors[keyof BanUserFromChannelErrors]

export interface BanUserFromChannelResponses {
  /**
   * Successful ban operation
   */
  200: SuccessResponse
}

export type BanUserFromChannelResponse =
  BanUserFromChannelResponses[keyof BanUserFromChannelResponses]

export interface UnfollowChannelData {
  body: {
    /**
     * ID of the channel to unfollow
     */
    channelId: string
  }
  path?: never
  query?: never
  url: '/fc/channel-follows'
}

export interface UnfollowChannelErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type UnfollowChannelError =
  UnfollowChannelErrors[keyof UnfollowChannelErrors]

export interface UnfollowChannelResponses {
  /**
   * Successful unfollow operation
   */
  200: SuccessResponse
}

export type UnfollowChannelResponse =
  UnfollowChannelResponses[keyof UnfollowChannelResponses]

export interface FollowChannelData {
  body: {
    /**
     * ID of the channel to follow
     */
    channelId: string
  }
  path?: never
  query?: never
  url: '/fc/channel-follows'
}

export interface FollowChannelErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type FollowChannelError = FollowChannelErrors[keyof FollowChannelErrors]

export interface FollowChannelResponses {
  /**
   * Successful follow operation
   */
  200: SuccessResponse
}

export type FollowChannelResponse =
  FollowChannelResponses[keyof FollowChannelResponses]

export interface ModerateCastData {
  body: {
    /**
     * Hash of the cast to moderate
     */
    castHash: string
    /**
     * Type of moderation action to apply
     */
    action: 'hide'
  }
  path?: never
  query?: never
  url: '/fc/moderate-cast'
}

export interface ModerateCastErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type ModerateCastError = ModerateCastErrors[keyof ModerateCastErrors]

export interface ModerateCastResponses {
  /**
   * Successful moderation action
   */
  200: SuccessResponse
}

export type ModerateCastResponse =
  ModerateCastResponses[keyof ModerateCastResponses]

export interface UnpinCastFromChannelData {
  body: {
    /**
     * ID of the channel from which to unpin a cast
     */
    channelId: string
  }
  path?: never
  query?: never
  url: '/fc/pinned-casts'
}

export interface UnpinCastFromChannelErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type UnpinCastFromChannelError =
  UnpinCastFromChannelErrors[keyof UnpinCastFromChannelErrors]

export interface UnpinCastFromChannelResponses {
  /**
   * Successful unpin operation
   */
  200: SuccessResponse
}

export type UnpinCastFromChannelResponse =
  UnpinCastFromChannelResponses[keyof UnpinCastFromChannelResponses]

export interface PinCastToChannelData {
  body: {
    /**
     * Hash of the cast to pin
     */
    castHash: string
    /**
     * Whether to notify followers of the channel about the pin
     */
    notifyChannelFollowers?: boolean
  }
  path?: never
  query?: never
  url: '/fc/pinned-casts'
}

export interface PinCastToChannelErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type PinCastToChannelError =
  PinCastToChannelErrors[keyof PinCastToChannelErrors]

export interface PinCastToChannelResponses {
  /**
   * Successful pin operation
   */
  200: SuccessResponse
}

export type PinCastToChannelResponse =
  PinCastToChannelResponses[keyof PinCastToChannelResponses]

export interface GetDiscoverableActionsData {
  body?: never
  path?: never
  query: {
    list: string
    limit?: number
  }
  url: '/v2/discover-actions'
}

export interface GetDiscoverableActionsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetDiscoverableActionsError =
  GetDiscoverableActionsErrors[keyof GetDiscoverableActionsErrors]

export interface GetDiscoverableActionsResponses {
  /**
   * Successful response with list of discoverable actions
   */
  200: {
    result?: {
      actions?: Action[]
      next?: {
        cursor?: string
      }
    }
  }
}

export type GetDiscoverableActionsResponse =
  GetDiscoverableActionsResponses[keyof GetDiscoverableActionsResponses]

export interface GetDiscoverableComposerActionsData {
  body?: never
  path?: never
  query: {
    list: string
    limit?: number
  }
  url: '/v2/discover-composer-actions'
}

export interface GetDiscoverableComposerActionsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetDiscoverableComposerActionsError =
  GetDiscoverableComposerActionsErrors[keyof GetDiscoverableComposerActionsErrors]

export interface GetDiscoverableComposerActionsResponses {
  /**
   * Successful response with list of discoverable composer actions
   */
  200: {
    result?: {
      actions?: Action[]
      next?: {
        cursor?: string
      }
    }
  }
}

export type GetDiscoverableComposerActionsResponse =
  GetDiscoverableComposerActionsResponses[keyof GetDiscoverableComposerActionsResponses]

export interface UnblockUserData {
  body: {
    /**
     * Farcaster ID of the user to unblock
     */
    unblockFid: number
  }
  path?: never
  query?: never
  url: '/fc/blocked-users'
}

export interface UnblockUserErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type UnblockUserError = UnblockUserErrors[keyof UnblockUserErrors]

export interface UnblockUserResponses {
  /**
   * Successful unblock operation
   */
  200: {
    result: {
      /**
       * Indicates whether the unblock operation was successful
       */
      success: boolean
    }
  }
}

export type UnblockUserResponse =
  UnblockUserResponses[keyof UnblockUserResponses]

export interface GetBlockedUsersData {
  body?: never
  path?: never
  query?: never
  url: '/fc/blocked-users'
}

export interface GetBlockedUsersErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetBlockedUsersError =
  GetBlockedUsersErrors[keyof GetBlockedUsersErrors]

export interface GetBlockedUsersResponses {
  /**
   * Successful response with list of blocked users
   */
  200: {
    result: {
      blockedUsers: {
        /**
         * Farcaster ID of the user who blocked
         */
        blockerFid: number
        /**
         * Farcaster ID of the user who was blocked
         */
        blockedFid: number
        /**
         * Unix timestamp of when the user was blocked
         */
        createdAt: number
      }[]
      next?: {
        /**
         * Pagination cursor for fetching the next set of blocked users
         */
        cursor?: string
      }
    }
  }
}

export type GetBlockedUsersResponse =
  GetBlockedUsersResponses[keyof GetBlockedUsersResponses]

export interface BlockUserData {
  body: {
    /**
     * Farcaster ID of the user to block
     */
    blockFid: number
  }
  path?: never
  query?: never
  url: '/fc/blocked-users'
}

export interface BlockUserErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type BlockUserError = BlockUserErrors[keyof BlockUserErrors]

export interface BlockUserResponses {
  /**
   * Successful block operation
   */
  200: {
    result: {
      /**
       * Indicates whether the block operation was successful
       */
      success: boolean
    }
  }
}

export type BlockUserResponse = BlockUserResponses[keyof BlockUserResponses]

export interface GetAccountVerificationsData {
  body?: never
  path?: never
  query: {
    /**
     * The user's FID (Farcaster ID)
     */
    fid: number
  }
  url: '/fc/account-verifications'
}

export interface GetAccountVerificationsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetAccountVerificationsError =
  GetAccountVerificationsErrors[keyof GetAccountVerificationsErrors]

export interface GetAccountVerificationsResponses {
  /**
   * Successful response with list of account verifications
   */
  200: {
    result?: {
      verifications?: {
        fid?: number
        platform?: string
        platformId?: string
        platformUsername?: string
        verifiedAt?: number
      }[]
    }
    next?: {
      cursor?: string
    }
  }
}

export type GetAccountVerificationsResponse =
  GetAccountVerificationsResponses[keyof GetAccountVerificationsResponses]

export interface GetCreatorRewardWinnersData {
  body?: never
  path?: never
  query?: {
    /**
     * How many periods ago to fetch the results for. 0 or undefined returns results for the most recent period.
     */
    periodsAgo?: number
  }
  url: '/v1/creator-rewards-winner-history'
}

export interface GetCreatorRewardWinnersErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetCreatorRewardWinnersError =
  GetCreatorRewardWinnersErrors[keyof GetCreatorRewardWinnersErrors]

export interface GetCreatorRewardWinnersResponses {
  /**
   * Successful response with creator reward winners history
   */
  200: {
    result?: {
      periodStartTimestamp?: bigint
      periodEndTimestamp?: bigint
      winners?: {
        fid?: number
        score?: number
        rank?: number
        rewardCents?: number
        walletAddress?: string
      }[]
    }
    next?: {
      cursor?: string
    }
  }
}

export type GetCreatorRewardWinnersResponse =
  GetCreatorRewardWinnersResponses[keyof GetCreatorRewardWinnersResponses]

export interface GetUserPrimaryAddressData {
  body?: never
  path?: never
  query: {
    /**
     * The user's FID (Farcaster ID)
     */
    fid: number
    /**
     * The protocol of the address to fetch.
     */
    protocol: 'ethereum' | 'solana'
  }
  url: '/fc/primary-address'
}

export interface GetUserPrimaryAddressErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetUserPrimaryAddressError =
  GetUserPrimaryAddressErrors[keyof GetUserPrimaryAddressErrors]

export interface GetUserPrimaryAddressResponses {
  /**
   * Successful response with the user's primary address.
   */
  200: {
    result?: {
      address?: VerifiedAddress
    }
  }
}

export type GetUserPrimaryAddressResponse =
  GetUserPrimaryAddressResponses[keyof GetUserPrimaryAddressResponses]

export interface GetUserPrimaryAddressesData {
  body?: never
  path?: never
  query: {
    /**
     * Comma-separated list of FIDs to fetch primary addresses for.
     */
    fids: string
    /**
     * The protocol of the addresses to fetch.
     */
    protocol: 'ethereum' | 'solana'
  }
  url: '/fc/primary-addresses'
}

export interface GetUserPrimaryAddressesErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetUserPrimaryAddressesError =
  GetUserPrimaryAddressesErrors[keyof GetUserPrimaryAddressesErrors]

export interface GetUserPrimaryAddressesResponses {
  /**
   * Successful response with list of primary addresses.
   */
  200: {
    result?: {
      addresses?: {
        /**
         * The Farcaster ID of the user
         */
        fid: number
        /**
         * Whether the address was successfully retrieved
         */
        success: boolean
        /**
         * Present only if success is true
         */
        address?: VerifiedAddress
      }[]
    }
  }
}

export type GetUserPrimaryAddressesResponse =
  GetUserPrimaryAddressesResponses[keyof GetUserPrimaryAddressesResponses]

export interface GetStarterPackMembersData {
  body?: never
  path?: never
  query: {
    /**
     * Starter pack ID, as found in the public Warpcast pack URL or in the non-authed public API of starter pack metadata.
     *
     */
    id: string
  }
  url: '/fc/starter-pack-members'
}

export interface GetStarterPackMembersErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetStarterPackMembersError =
  GetStarterPackMembersErrors[keyof GetStarterPackMembersErrors]

export interface GetStarterPackMembersResponses {
  /**
   * Successful response with list of starter pack members.
   */
  200: {
    result?: {
      members?: {
        /**
         * The Farcaster ID of the starter pack member
         */
        fid: number
        /**
         * Timestamp in milliseconds when the user became a member
         */
        memberAt: bigint
      }[]
    }
    next?: {
      /**
       * Pagination cursor for fetching the next set of results
       */
      cursor?: string
    }
  }
}

export type GetStarterPackMembersResponse =
  GetStarterPackMembersResponses[keyof GetStarterPackMembersResponses]

export interface SendDirectCastData {
  body: {
    /**
     * The Farcaster ID of the recipient.
     */
    recipientFid: number
    /**
     * The direct cast message.
     */
    message: string
    /**
     * A unique key to ensure idempotency.
     */
    idempotencyKey: string
  }
  path?: never
  query?: never
  url: '/v2/ext-send-direct-cast'
}

export interface SendDirectCastErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type SendDirectCastError =
  SendDirectCastErrors[keyof SendDirectCastErrors]

export interface SendDirectCastResponses {
  /**
   * Direct cast sent successfully
   */
  200: {
    result: {
      /**
       * Indicates if the direct cast was sent successfully
       */
      success: boolean
    }
  }
}

export type SendDirectCastResponse =
  SendDirectCastResponses[keyof SendDirectCastResponses]

export interface GetUserByVerificationAddressData {
  body?: never
  path?: never
  query: {
    /**
     * Ethereum address used for user verification
     */
    address: string
  }
  url: '/v2/user-by-verification'
}

export interface GetUserByVerificationAddressErrors {
  /**
   * Invalid address format
   */
  400: unknown
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * No user found for the provided address
   */
  404: unknown
}

export type GetUserByVerificationAddressError =
  GetUserByVerificationAddressErrors[keyof GetUserByVerificationAddressErrors]

export interface GetUserByVerificationAddressResponses {
  /**
   * User data successfully retrieved
   */
  200: UserResponse
}

export type GetUserByVerificationAddressResponse =
  GetUserByVerificationAddressResponses[keyof GetUserByVerificationAddressResponses]

export interface GetDeveloperRewardWinnersData {
  body?: never
  path?: never
  query?: {
    /**
     * How many periods ago to fetch the results for. 0 or undefined returns results for the most recent period.
     */
    periodsAgo?: number
  }
  url: '/v1/developer-rewards-winner-history'
}

export interface GetDeveloperRewardWinnersErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetDeveloperRewardWinnersError =
  GetDeveloperRewardWinnersErrors[keyof GetDeveloperRewardWinnersErrors]

export interface GetDeveloperRewardWinnersResponses {
  /**
   * A paginated list of developer reward winners
   */
  200: {
    result?: {
      /**
       * Unix time in milliseconds when rewards period began
       */
      periodStartTimestamp?: number
      /**
       * Unix time in milliseconds when rewards period ended
       */
      periodEndTimestamp?: number
      winners?: Winner[]
    }
    next?: {
      /**
       * Pagination cursor for the next set of results
       */
      cursor?: string
    }
  }
}

export type GetDeveloperRewardWinnersResponse =
  GetDeveloperRewardWinnersResponses[keyof GetDeveloperRewardWinnersResponses]

export interface GetAppsByAuthorData {
  body?: never
  path?: never
  query: {
    /**
     * The user's FID (Farcaster ID)
     */
    fid: number
    /**
     * Maximum number of items to return
     */
    limit?: number
  }
  url: '/v1/apps-by-author'
}

export interface GetAppsByAuthorErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetAppsByAuthorError =
  GetAppsByAuthorErrors[keyof GetAppsByAuthorErrors]

export interface GetAppsByAuthorResponses {
  /**
   * A list of frames by the author
   */
  200: AppsByAuthorResponse
}

export type GetAppsByAuthorResponse =
  GetAppsByAuthorResponses[keyof GetAppsByAuthorResponses]

export interface GetDomainManifestData {
  body?: never
  path?: never
  query: {
    /**
     * The domain to retrieve manifest information for
     */
    domain: string
  }
  url: '/v1/domain-manifest'
}

export interface GetDomainManifestErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetDomainManifestError =
  GetDomainManifestErrors[keyof GetDomainManifestErrors]

export interface GetDomainManifestResponses {
  /**
   * Successfully retrieved domain manifest
   */
  200: {
    result?: {
      state?: {
        /**
         * Indicates if the domain is verified
         */
        verified?: boolean
        /**
         * JSON string containing the raw manifest data
         */
        manifest?: string
        decodedManifest?: {
          accountAssociation?: {
            /**
             * Farcaster ID associated with the domain
             */
            fid?: number
            /**
             * Public key associated with the domain
             */
            key?: string
            /**
             * The domain name
             */
            domain?: string
            /**
             * Signature proving domain ownership
             */
            signature?: string
          }
        }
        /**
         * Configuration for Farcaster Frames
         */
        frameConfig?: {
          /**
           * Name of the Frame
           */
          name?: string
          /**
           * Version of the Frame
           */
          version?: string
          /**
           * URL to the Frame's icon
           */
          iconUrl?: string
          /**
           * Home URL of the Frame
           */
          homeUrl?: string
          /**
           * Image URL for the Frame
           */
          imageUrl?: string
          /**
           * Title for the Frame's button
           */
          buttonTitle?: string
          /**
           * URL for the splash image
           */
          splashImageUrl?: string
          /**
           * Background color for splash screen
           */
          splashBackgroundColor?: string
          /**
           * Webhook URL for the Frame
           */
          webhookUrl?: string
        }
        /**
         * Timestamp of when the data was last updated
         */
        updatedAt?: number
      }
    }
  }
}

export type GetDomainManifestResponse =
  GetDomainManifestResponses[keyof GetDomainManifestResponses]

export interface GetMetaTagsData {
  body?: never
  path?: never
  query: {
    /**
     * The URL to fetch metadata from
     */
    url: string
  }
  url: '/v1/dev-tools/meta-tags'
}

export interface GetMetaTagsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetMetaTagsError = GetMetaTagsErrors[keyof GetMetaTagsErrors]

export interface GetMetaTagsResponses {
  /**
   * Successfully retrieved metadata
   */
  200: {
    /**
     * Viewport meta tag content
     */
    viewport?: string
    /**
     * Theme color values
     */
    'theme-color'?: string[]
    /**
     * Color scheme preference
     */
    'color-scheme'?: string
    /**
     * Page description
     */
    description?: string
    /**
     * Apple mobile web app capability setting
     */
    'apple-mobile-web-app-capable'?: string
    /**
     * Apple mobile web app title
     */
    'apple-mobile-web-app-title'?: string
    /**
     * Apple mobile status bar style
     */
    'apple-mobile-web-app-status-bar-style'?: string
    /**
     * Open Graph title
     */
    'og:title'?: string
    /**
     * Open Graph description
     */
    'og:description'?: string
    /**
     * Open Graph URL
     */
    'og:url'?: string
    /**
     * Open Graph site name
     */
    'og:site_name'?: string
    /**
     * Open Graph image alt text
     */
    'og:image:alt'?: string
    /**
     * Open Graph image MIME type
     */
    'og:image:type'?: string
    /**
     * Open Graph image width
     */
    'og:image:width'?: string
    /**
     * Open Graph image height
     */
    'og:image:height'?: string
    /**
     * Open Graph image URL
     */
    'og:image'?: string
    /**
     * Open Graph content type
     */
    'og:type'?: string
    /**
     * Twitter card type
     */
    'twitter:card'?: string
    /**
     * Twitter card title
     */
    'twitter:title'?: string
    /**
     * Twitter card description
     */
    'twitter:description'?: string
    /**
     * Twitter image alt text
     */
    'twitter:image:alt'?: string
    /**
     * Twitter image MIME type
     */
    'twitter:image:type'?: string
    /**
     * Twitter image width
     */
    'twitter:image:width'?: string
    /**
     * Twitter image height
     */
    'twitter:image:height'?: string
    /**
     * Twitter image URL
     */
    'twitter:image'?: string
  }
}

export type GetMetaTagsResponse =
  GetMetaTagsResponses[keyof GetMetaTagsResponses]

export interface GetFarcasterJsonData {
  body?: never
  path?: never
  query: {
    /**
     * The domain to fetch Farcaster JSON data from
     */
    domain: string
  }
  url: '/v1/dev-tools/farcaster-json'
}

export interface GetFarcasterJsonErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetFarcasterJsonError =
  GetFarcasterJsonErrors[keyof GetFarcasterJsonErrors]

export interface GetFarcasterJsonResponses {
  /**
   * Successfully retrieved Farcaster JSON data
   */
  200: {
    /**
     * Farcaster account association information
     */
    accountAssociation?: {
      /**
       * Base64 encoded header containing FID, type, and key information
       */
      header?: string
      /**
       * Base64 encoded payload containing domain information
       */
      payload?: string
      /**
       * Cryptographic signature for verification
       */
      signature?: string
    }
    /**
     * Farcaster frame configuration
     */
    frame?: {
      /**
       * URL of the frame's home page
       */
      homeUrl?: string
      /**
       * URL of the frame's icon
       */
      iconUrl?: string
      /**
       * Name of the frame
       */
      name?: string
      /**
       * Background color for the splash screen in hex format
       */
      splashBackgroundColor?: string
      /**
       * URL of the splash image
       */
      splashImageUrl?: string
      /**
       * Version of the frame
       */
      version?: string
      /**
       * URL of the frame's webhook
       */
      webhookUrl?: string
    }
  }
}

export type GetFarcasterJsonResponse =
  GetFarcasterJsonResponses[keyof GetFarcasterJsonResponses]

export interface GetOwnedDomainsData {
  body?: never
  path?: never
  query?: never
  url: '/v1/dev-tools/domains-owned'
}

export interface GetOwnedDomainsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Forbidden - insufficient permissions
   */
  403: unknown
  /**
   * Internal server error
   */
  500: unknown
}

export type GetOwnedDomainsError =
  GetOwnedDomainsErrors[keyof GetOwnedDomainsErrors]

export interface GetOwnedDomainsResponses {
  /**
   * Successfully retrieved owned domains
   */
  200: {
    result: {
      /**
       * List of domains owned by the authenticated user
       */
      domains?: string[]
    }
  }
}

export type GetOwnedDomainsResponse =
  GetOwnedDomainsResponses[keyof GetOwnedDomainsResponses]

export interface GetApiKeysData {
  body?: never
  path?: never
  query?: never
  url: '/v2/api-keys'
}

export interface GetApiKeysErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Forbidden - User doesn't have permission to access API keys
   */
  403: unknown
}

export type GetApiKeysError = GetApiKeysErrors[keyof GetApiKeysErrors]

export interface GetApiKeysResponses {
  /**
   * Successfully retrieved API keys
   */
  200: {
    result: {
      apiKeys: ApiKey[]
    }
  }
}

export type GetApiKeysResponse = GetApiKeysResponses[keyof GetApiKeysResponses]

export interface CreateApiKeyData {
  body: {
    /**
     * User-provided description of the API key's purpose
     */
    description: string
    /**
     * Timestamp when the API key should expire (in milliseconds since epoch)
     */
    expiresAt: bigint
  }
  headers?: {
    /**
     * A unique key to ensure idempotency of the request
     */
    'idempotency-key'?: string
  }
  path?: never
  query?: never
  url: '/v2/api-keys'
}

export interface CreateApiKeyErrors {
  /**
   * Bad Request - Invalid input parameters
   */
  400: unknown
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Forbidden - User doesn't have permission to create API keys
   */
  403: unknown
}

export type CreateApiKeyError = CreateApiKeyErrors[keyof CreateApiKeyErrors]

export interface CreateApiKeyResponses {
  /**
   * Successfully created API key
   */
  200: {
    result: {
      /**
       * Unique identifier for the created API key
       */
      id: string
      /**
       * The secret key value that should be used for authentication (only returned once at creation)
       */
      secretKey: string
    }
  }
}

export type CreateApiKeyResponse =
  CreateApiKeyResponses[keyof CreateApiKeyResponses]

export interface RevokeApiKeyData {
  body: {
    /**
     * ID of the API key to revoke
     */
    id: string
  }
  headers?: {
    /**
     * A unique key to ensure idempotency of the request
     */
    'idempotency-key'?: string
  }
  path?: never
  query?: never
  url: '/v2/revoke-api-key'
}

export interface RevokeApiKeyErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Forbidden - User doesn't have permission to revoke API keys
   */
  403: unknown
  /**
   * Not Found - API key with specified ID does not exist
   */
  404: unknown
}

export type RevokeApiKeyError = RevokeApiKeyErrors[keyof RevokeApiKeyErrors]

export interface RevokeApiKeyResponses {
  /**
   * Successfully revoked the API key
   */
  200: {
    result: {
      success: boolean
    }
  }
}

export type RevokeApiKeyResponse =
  RevokeApiKeyResponses[keyof RevokeApiKeyResponses]

export interface GetConnectedAccountsData {
  body?: never
  path?: never
  query?: {
    /**
     * Maximum number of connected accounts to return
     */
    limit?: number
  }
  url: '/v2/connected-accounts'
}

export interface GetConnectedAccountsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type GetConnectedAccountsError =
  GetConnectedAccountsErrors[keyof GetConnectedAccountsErrors]

export interface GetConnectedAccountsResponses {
  /**
   * List of connected accounts
   */
  200: {
    result: {
      accounts?: {
        /**
         * Unique identifier for the connected account
         */
        connectedAccountId?: string
        /**
         * Social platform name (e.g., x, github, lens)
         */
        platform?: 'x' | 'github' | 'lens' | 'ethereum'
        /**
         * Username on the connected platform
         */
        username?: string
        /**
         * Whether the connection has expired
         */
        expired?: boolean
      }[]
    }
  }
}

export type GetConnectedAccountsResponse =
  GetConnectedAccountsResponses[keyof GetConnectedAccountsResponses]

export interface GetProfileCastsData {
  body?: never
  path?: never
  query: {
    /**
     * Farcaster ID of the user
     */
    fid: number
    /**
     * Maximum number of casts to return
     */
    limit?: number
    /**
     * Cursor for pagination
     */
    cursor?: string
  }
  url: '/v2/profile-casts'
}

export interface GetProfileCastsErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * User not found
   */
  404: unknown
}

export type GetProfileCastsError =
  GetProfileCastsErrors[keyof GetProfileCastsErrors]

export interface GetProfileCastsResponses {
  /**
   * Successfully retrieved user's casts
   */
  200: {
    result: {
      casts: Cast[]
    }
    next?: {
      /**
       * Cursor for fetching the next page of results
       */
      cursor?: string
    }
  }
}

export type GetProfileCastsResponse =
  GetProfileCastsResponses[keyof GetProfileCastsResponses]

export interface GetUserLikedCastsData {
  body?: never
  path?: never
  query: {
    /**
     * The user's fid (user id) whose liked casts are to be retrieved.
     */
    fid: number
    /**
     * Number of results to limit per request.
     */
    limit?: number
  }
  url: '/v2/user-liked-casts'
}

export interface GetUserLikedCastsErrors {
  /**
   * Bad request (e.g., missing required parameters)
   */
  400: unknown
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Internal Server Error
   */
  500: unknown
}

export type GetUserLikedCastsError =
  GetUserLikedCastsErrors[keyof GetUserLikedCastsErrors]

export interface GetUserLikedCastsResponses {
  /**
   * Successfully retrieved liked casts.
   */
  200: {
    result: {
      casts?: Cast[]
      next?: {
        cursor?: string
      }
    }
  }
}

export type GetUserLikedCastsResponse =
  GetUserLikedCastsResponses[keyof GetUserLikedCastsResponses]

export interface GetMiniappAnalyticsRollupData {
  body: {
    dateRange: {
      /**
       * Start date in format 'YYYY-MM-DD' or relative like '28daysago'
       */
      startDate: string
      /**
       * End date in format 'YYYY-MM-DD' or relative like 'today'
       */
      endDate: string
    }
    /**
     * Analytics metrics to retrieve
     */
    measures: (| 'miniapp_opens'
      | 'miniapp_transactions'
      | 'miniapp_users_w_transaction'
      | 'miniapp_users_w_open'
      | 'miniapp_users_w_notifications_enabled'
      | 'miniapp_users_w_notifications_disabled'
      | 'miniapp_users_w_app_favorited'
      | 'miniapp_users_w_app_unfavorited')[]
    /**
     * Filtering restrictions for the data
     */
    restrictions: {
      /**
       * Dimension to filter on
       */
      dimension: string
      /**
       * Values to filter the dimension by
       */
      values: string[]
    }[]
    /**
     * Configuration for data breakdown
     */
    breakdownSettings?: {
      /**
       * Dimensions to break down the data by
       */
      dimensions?: string[]
      /**
       * Sort order for the breakdown results
       */
      order?: 'asc' | 'desc'
    }
  }
  path?: never
  query?: never
  url: '/v1/analytics/miniapps/rollup'
}

export interface GetMiniappAnalyticsRollupErrors {
  /**
   * Bad request - Invalid parameters
   */
  400: unknown
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Forbidden - Not authorized to access this data
   */
  403: unknown
  /**
   * Server error
   */
  500: unknown
}

export type GetMiniappAnalyticsRollupError =
  GetMiniappAnalyticsRollupErrors[keyof GetMiniappAnalyticsRollupErrors]

export interface GetMiniappAnalyticsRollupResponses {
  /**
   * Successful analytics rollup retrieval
   */
  200: {
    result?: {
      rollup?: {
        dateRange?: {
          startDate?: Date
          endDate?: Date
        }
        restrictions?: {
          dimension?: string
          values?: string[]
        }[]
        /**
         * Aggregate metric totals
         */
        totals?: {
          name?: string
          value?: number
        }[]
        /**
         * Metrics broken down by dimensions
         */
        breakdown?: {
          slices?: {
            dimension?: string
            values?: string[]
          }[]
          measures?: {
            name?: string
            value?: number
          }[]
        }[]
      }
    }
  }
}

export type GetMiniappAnalyticsRollupResponse =
  GetMiniappAnalyticsRollupResponses[keyof GetMiniappAnalyticsRollupResponses]

export interface InspectMiniAppUrlData {
  body?: never
  path?: never
  query: {
    /**
     * The URL of the Mini App to inspect
     */
    url: string
  }
  url: '/v1/dev-tools/inspect-miniapp-url'
}

export interface InspectMiniAppUrlErrors {
  /**
   * Bad request - Invalid URL format
   */
  400: unknown
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
  /**
   * Forbidden - Not authorized to use this endpoint
   */
  403: unknown
  /**
   * Server error
   */
  500: unknown
}

export type InspectMiniAppUrlError =
  InspectMiniAppUrlErrors[keyof InspectMiniAppUrlErrors]

export interface InspectMiniAppUrlResponses {
  /**
   * Successful inspection of the Mini App URL
   */
  200: {
    result?: {
      facts?: {
        /**
         * The URL that was inspected
         */
        url?: string
        /**
         * HTTP status code returned by the URL
         */
        statusCode?: number
        /**
         * Indicates if the Mini App embedding code is present
         */
        miniAppEmbedPresent?: boolean
        /**
         * Indicates if the Mini App manifest is present
         */
        miniAppManifestPresent?: boolean
        /**
         * Indicates if the Mini App embedding code is valid
         */
        miniAppEmbedValid?: boolean
        /**
         * Indicates if the Mini App manifest is valid
         */
        miniAppManifestValid?: boolean
      }
    }
  }
}

export type InspectMiniAppUrlResponse =
  InspectMiniAppUrlResponses[keyof InspectMiniAppUrlResponses]

export interface InspectImageUrlData {
  body?: never
  path?: never
  query: {
    /**
     * The URL of the image to inspect
     */
    url: string
  }
  url: '/v1/dev-tools/inspect-image-url'
}

export interface InspectImageUrlErrors {
  /**
   * Authentication is required or failed
   */
  401: ErrorResponse
}

export type InspectImageUrlError =
  InspectImageUrlErrors[keyof InspectImageUrlErrors]

export interface InspectImageUrlResponses {
  /**
   * Image inspection successful
   */
  200: {
    result: {
      facts?: {
        /**
         * The URL of the inspected image
         */
        url?: string
        /**
         * HTTP status code of the response
         */
        statusCode?: number
        /**
         * The cache header used by the image
         */
        cacheHeader?: string
        /**
         * Cache age in seconds
         */
        cacheAge?: number
        /**
         * Size of the image in bytes
         */
        imageSizeBytes?: number
        /**
         * Time taken to load the image in milliseconds
         */
        imageLoadTimeMs?: number
      }
    }
  }
}

export type InspectImageUrlResponse =
  InspectImageUrlResponses[keyof InspectImageUrlResponses]

export interface ClientOptions {
  baseUrl:
    | 'https://api.warpcast.com'
    | 'https://client.warpcccastt.com'
    | (string & {})
}
